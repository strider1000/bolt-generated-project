import "./chunk-ZC22LKFR.js";

// node_modules/.pnpm/@vue+shared@3.5.13/node_modules/@vue/shared/dist/shared.esm-bundler.js
function makeMap(str) {
  const map2 = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(","))
    map2[key] = 1;
  return (val) => val in map2;
}
var EMPTY_OBJ = true ? Object.freeze({}) : {};
var EMPTY_ARR = true ? Object.freeze([]) : [];
var NOOP = () => {
};
var NO = () => false;
var isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
var isModelListener = (key) => key.startsWith("onUpdate:");
var extend = Object.assign;
var remove = (arr, el2) => {
  const i = arr.indexOf(el2);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
var hasOwnProperty = Object.prototype.hasOwnProperty;
var hasOwn = (val, key) => hasOwnProperty.call(val, key);
var isArray = Array.isArray;
var isMap = (val) => toTypeString(val) === "[object Map]";
var isSet = (val) => toTypeString(val) === "[object Set]";
var isFunction = (val) => typeof val === "function";
var isString = (val) => typeof val === "string";
var isSymbol = (val) => typeof val === "symbol";
var isObject = (val) => val !== null && typeof val === "object";
var isPromise = (val) => {
  return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
};
var objectToString = Object.prototype.toString;
var toTypeString = (value) => objectToString.call(value);
var toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
var isPlainObject = (val) => toTypeString(val) === "[object Object]";
var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
var isReservedProp = makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
var isBuiltInDirective = makeMap(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
);
var cacheStringFunction = (fn2) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn2(str));
  };
};
var camelizeRE = /-(\w)/g;
var camelize = cacheStringFunction(
  (str) => {
    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
  }
);
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
var capitalize = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
var toHandlerKey = cacheStringFunction(
  (str) => {
    const s = str ? `on${capitalize(str)}` : ``;
    return s;
  }
);
var hasChanged = (value, oldValue) => !Object.is(value, oldValue);
var invokeArrayFns = (fns, ...arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](...arg);
  }
};
var def = (obj, key, value, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value
  });
};
var looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
var toNumber = (val) => {
  const n = isString(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
var _globalThis;
var getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
var GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol";
var isGloballyAllowed = makeMap(GLOBALS_ALLOWED);
function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value) || isObject(value)) {
    return value;
  }
}
var listDelimiterRE = /;(?![^(]*\))/g;
var propertyDelimiterRE = /:([^]+)/;
var styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props)
    return null;
  let { class: klass, style } = props;
  if (klass && !isString(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}
var HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
var SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
var MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
var VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
var isHTMLTag = makeMap(HTML_TAGS);
var isSVGTag = makeMap(SVG_TAGS);
var isMathMLTag = makeMap(MATH_TAGS);
var isVoidTag = makeMap(VOID_TAGS);
var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
var isSpecialBooleanAttr = makeMap(specialBooleanAttrs);
var isBooleanAttr = makeMap(
  specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`
);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
var isKnownHtmlAttr = makeMap(
  `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`
);
var isKnownSvgAttr = makeMap(
  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`
);
var isKnownMathMLAttr = makeMap(
  `accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns`
);
var isRef = (val) => {
  return !!(val && val["__v_isRef"] === true);
};
var toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
var replacer = (_key, val) => {
  if (isRef(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i) => {
          entries[stringifySymbol(key, i) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
    };
  } else if (isSymbol(val)) {
    return stringifySymbol(val);
  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
var stringifySymbol = (v, i = "") => {
  var _a2;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol(v) ? `Symbol(${(_a2 = v.description) != null ? _a2 : i})` : v
  );
};

// node_modules/.pnpm/@vue+reactivity@3.5.13/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js
function warn(msg, ...args) {
  console.warn(`[Vue warn] ${msg}`, ...args);
}
var activeEffectScope;
var EffectScope = class {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this._isPaused = false;
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = true;
      let i, l;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].pause();
        }
      }
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].pause();
      }
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active) {
      if (this._isPaused) {
        this._isPaused = false;
        let i, l;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].resume();
          }
        }
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].resume();
        }
      }
    }
  }
  run(fn2) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn2();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    } else if (true) {
      warn(`cannot run an inactive effect scope.`);
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      this._active = false;
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      this.effects.length = 0;
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      this.cleanups.length = 0;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
    }
  }
};
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn2, failSilently = false) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn2);
  } else if (!failSilently) {
    warn(
      `onScopeDispose() is called when there is no active effect scope to be associated with.`
    );
  }
}
var activeSub;
var pausedQueueEffects = /* @__PURE__ */ new WeakSet();
var ReactiveEffect = class {
  constructor(fn2) {
    this.fn = fn2;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 1 | 4;
    this.next = void 0;
    this.cleanup = void 0;
    this.scheduler = void 0;
    if (activeEffectScope && activeEffectScope.active) {
      activeEffectScope.effects.push(this);
    }
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    if (this.flags & 64) {
      this.flags &= ~64;
      if (pausedQueueEffects.has(this)) {
        pausedQueueEffects.delete(this);
        this.trigger();
      }
    }
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags & 2 && !(this.flags & 32)) {
      return;
    }
    if (!(this.flags & 8)) {
      batch(this);
    }
  }
  run() {
    if (!(this.flags & 1)) {
      return this.fn();
    }
    this.flags |= 2;
    cleanupEffect(this);
    prepareDeps(this);
    const prevEffect = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = this;
    shouldTrack = true;
    try {
      return this.fn();
    } finally {
      if (activeSub !== this) {
        warn(
          "Active effect was not restored correctly - this is likely a Vue internal bug."
        );
      }
      cleanupDeps(this);
      activeSub = prevEffect;
      shouldTrack = prevShouldTrack;
      this.flags &= ~2;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let link = this.deps; link; link = link.nextDep) {
        removeSub(link);
      }
      this.deps = this.depsTail = void 0;
      cleanupEffect(this);
      this.onStop && this.onStop();
      this.flags &= ~1;
    }
  }
  trigger() {
    if (this.flags & 64) {
      pausedQueueEffects.add(this);
    } else if (this.scheduler) {
      this.scheduler();
    } else {
      this.runIfDirty();
    }
  }
  /**
   * @internal
   */
  runIfDirty() {
    if (isDirty(this)) {
      this.run();
    }
  }
  get dirty() {
    return isDirty(this);
  }
};
var batchDepth = 0;
var batchedSub;
var batchedComputed;
function batch(sub, isComputed = false) {
  sub.flags |= 8;
  if (isComputed) {
    sub.next = batchedComputed;
    batchedComputed = sub;
    return;
  }
  sub.next = batchedSub;
  batchedSub = sub;
}
function startBatch() {
  batchDepth++;
}
function endBatch() {
  if (--batchDepth > 0) {
    return;
  }
  if (batchedComputed) {
    let e = batchedComputed;
    batchedComputed = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= ~8;
      e = next;
    }
  }
  let error;
  while (batchedSub) {
    let e = batchedSub;
    batchedSub = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= ~8;
      if (e.flags & 1) {
        try {
          ;
          e.trigger();
        } catch (err) {
          if (!error)
            error = err;
        }
      }
      e = next;
    }
  }
  if (error)
    throw error;
}
function prepareDeps(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    link.version = -1;
    link.prevActiveLink = link.dep.activeLink;
    link.dep.activeLink = link;
  }
}
function cleanupDeps(sub) {
  let head;
  let tail = sub.depsTail;
  let link = tail;
  while (link) {
    const prev = link.prevDep;
    if (link.version === -1) {
      if (link === tail)
        tail = prev;
      removeSub(link);
      removeDep(link);
    } else {
      head = link;
    }
    link.dep.activeLink = link.prevActiveLink;
    link.prevActiveLink = void 0;
    link = prev;
  }
  sub.deps = head;
  sub.depsTail = tail;
}
function isDirty(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
      return true;
    }
  }
  if (sub._dirty) {
    return true;
  }
  return false;
}
function refreshComputed(computed3) {
  if (computed3.flags & 4 && !(computed3.flags & 16)) {
    return;
  }
  computed3.flags &= ~16;
  if (computed3.globalVersion === globalVersion) {
    return;
  }
  computed3.globalVersion = globalVersion;
  const dep = computed3.dep;
  computed3.flags |= 2;
  if (dep.version > 0 && !computed3.isSSR && computed3.deps && !isDirty(computed3)) {
    computed3.flags &= ~2;
    return;
  }
  const prevSub = activeSub;
  const prevShouldTrack = shouldTrack;
  activeSub = computed3;
  shouldTrack = true;
  try {
    prepareDeps(computed3);
    const value = computed3.fn(computed3._value);
    if (dep.version === 0 || hasChanged(value, computed3._value)) {
      computed3._value = value;
      dep.version++;
    }
  } catch (err) {
    dep.version++;
    throw err;
  } finally {
    activeSub = prevSub;
    shouldTrack = prevShouldTrack;
    cleanupDeps(computed3);
    computed3.flags &= ~2;
  }
}
function removeSub(link, soft = false) {
  const { dep, prevSub, nextSub } = link;
  if (prevSub) {
    prevSub.nextSub = nextSub;
    link.prevSub = void 0;
  }
  if (nextSub) {
    nextSub.prevSub = prevSub;
    link.nextSub = void 0;
  }
  if (dep.subsHead === link) {
    dep.subsHead = nextSub;
  }
  if (dep.subs === link) {
    dep.subs = prevSub;
    if (!prevSub && dep.computed) {
      dep.computed.flags &= ~4;
      for (let l = dep.computed.deps; l; l = l.nextDep) {
        removeSub(l, true);
      }
    }
  }
  if (!soft && !--dep.sc && dep.map) {
    dep.map.delete(dep.key);
  }
}
function removeDep(link) {
  const { prevDep, nextDep } = link;
  if (prevDep) {
    prevDep.nextDep = nextDep;
    link.prevDep = void 0;
  }
  if (nextDep) {
    nextDep.prevDep = prevDep;
    link.nextDep = void 0;
  }
}
var shouldTrack = true;
var trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function cleanupEffect(e) {
  const { cleanup } = e;
  e.cleanup = void 0;
  if (cleanup) {
    const prevSub = activeSub;
    activeSub = void 0;
    try {
      cleanup();
    } finally {
      activeSub = prevSub;
    }
  }
}
var globalVersion = 0;
var Link = class {
  constructor(sub, dep) {
    this.sub = sub;
    this.dep = dep;
    this.version = dep.version;
    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
};
var Dep = class {
  constructor(computed3) {
    this.computed = computed3;
    this.version = 0;
    this.activeLink = void 0;
    this.subs = void 0;
    this.map = void 0;
    this.key = void 0;
    this.sc = 0;
    if (true) {
      this.subsHead = void 0;
    }
  }
  track(debugInfo) {
    if (!activeSub || !shouldTrack || activeSub === this.computed) {
      return;
    }
    let link = this.activeLink;
    if (link === void 0 || link.sub !== activeSub) {
      link = this.activeLink = new Link(activeSub, this);
      if (!activeSub.deps) {
        activeSub.deps = activeSub.depsTail = link;
      } else {
        link.prevDep = activeSub.depsTail;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
      }
      addSub(link);
    } else if (link.version === -1) {
      link.version = this.version;
      if (link.nextDep) {
        const next = link.nextDep;
        next.prevDep = link.prevDep;
        if (link.prevDep) {
          link.prevDep.nextDep = next;
        }
        link.prevDep = activeSub.depsTail;
        link.nextDep = void 0;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
        if (activeSub.deps === link) {
          activeSub.deps = next;
        }
      }
    }
    if (activeSub.onTrack) {
      activeSub.onTrack(
        extend(
          {
            effect: activeSub
          },
          debugInfo
        )
      );
    }
    return link;
  }
  trigger(debugInfo) {
    this.version++;
    globalVersion++;
    this.notify(debugInfo);
  }
  notify(debugInfo) {
    startBatch();
    try {
      if (true) {
        for (let head = this.subsHead; head; head = head.nextSub) {
          if (head.sub.onTrigger && !(head.sub.flags & 8)) {
            head.sub.onTrigger(
              extend(
                {
                  effect: head.sub
                },
                debugInfo
              )
            );
          }
        }
      }
      for (let link = this.subs; link; link = link.prevSub) {
        if (link.sub.notify()) {
          ;
          link.sub.dep.notify();
        }
      }
    } finally {
      endBatch();
    }
  }
};
function addSub(link) {
  link.dep.sc++;
  if (link.sub.flags & 4) {
    const computed3 = link.dep.computed;
    if (computed3 && !link.dep.subs) {
      computed3.flags |= 4 | 16;
      for (let l = computed3.deps; l; l = l.nextDep) {
        addSub(l);
      }
    }
    const currentTail = link.dep.subs;
    if (currentTail !== link) {
      link.prevSub = currentTail;
      if (currentTail)
        currentTail.nextSub = link;
    }
    if (link.dep.subsHead === void 0) {
      link.dep.subsHead = link;
    }
    link.dep.subs = link;
  }
}
var targetMap = /* @__PURE__ */ new WeakMap();
var ITERATE_KEY = Symbol(
  true ? "Object iterate" : ""
);
var MAP_KEY_ITERATE_KEY = Symbol(
  true ? "Map keys iterate" : ""
);
var ARRAY_ITERATE_KEY = Symbol(
  true ? "Array iterate" : ""
);
function track(target, type, key) {
  if (shouldTrack && activeSub) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = new Dep());
      dep.map = depsMap;
      dep.key = key;
    }
    if (true) {
      dep.track({
        target,
        type,
        key
      });
    } else {
      dep.track();
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++;
    return;
  }
  const run = (dep) => {
    if (dep) {
      if (true) {
        dep.trigger({
          target,
          type,
          key,
          newValue,
          oldValue,
          oldTarget
        });
      } else {
        dep.trigger();
      }
    }
  };
  startBatch();
  if (type === "clear") {
    depsMap.forEach(run);
  } else {
    const targetIsArray = isArray(target);
    const isArrayIndex = targetIsArray && isIntegerKey(key);
    if (targetIsArray && key === "length") {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
          run(dep);
        }
      });
    } else {
      if (key !== void 0 || depsMap.has(void 0)) {
        run(depsMap.get(key));
      }
      if (isArrayIndex) {
        run(depsMap.get(ARRAY_ITERATE_KEY));
      }
      switch (type) {
        case "add":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isArrayIndex) {
            run(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            run(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
  }
  endBatch();
}
function getDepFromReactive(object, key) {
  const depMap = targetMap.get(object);
  return depMap && depMap.get(key);
}
function reactiveReadArray(array) {
  const raw = toRaw(array);
  if (raw === array)
    return raw;
  track(raw, "iterate", ARRAY_ITERATE_KEY);
  return isShallow(array) ? raw : raw.map(toReactive);
}
function shallowReadArray(arr) {
  track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
  return arr;
}
var arrayInstrumentations = {
  __proto__: null,
  [Symbol.iterator]() {
    return iterator(this, Symbol.iterator, toReactive);
  },
  concat(...args) {
    return reactiveReadArray(this).concat(
      ...args.map((x) => isArray(x) ? reactiveReadArray(x) : x)
    );
  },
  entries() {
    return iterator(this, "entries", (value) => {
      value[1] = toReactive(value[1]);
      return value;
    });
  },
  every(fn2, thisArg) {
    return apply(this, "every", fn2, thisArg, void 0, arguments);
  },
  filter(fn2, thisArg) {
    return apply(this, "filter", fn2, thisArg, (v) => v.map(toReactive), arguments);
  },
  find(fn2, thisArg) {
    return apply(this, "find", fn2, thisArg, toReactive, arguments);
  },
  findIndex(fn2, thisArg) {
    return apply(this, "findIndex", fn2, thisArg, void 0, arguments);
  },
  findLast(fn2, thisArg) {
    return apply(this, "findLast", fn2, thisArg, toReactive, arguments);
  },
  findLastIndex(fn2, thisArg) {
    return apply(this, "findLastIndex", fn2, thisArg, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(fn2, thisArg) {
    return apply(this, "forEach", fn2, thisArg, void 0, arguments);
  },
  includes(...args) {
    return searchProxy(this, "includes", args);
  },
  indexOf(...args) {
    return searchProxy(this, "indexOf", args);
  },
  join(separator) {
    return reactiveReadArray(this).join(separator);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...args) {
    return searchProxy(this, "lastIndexOf", args);
  },
  map(fn2, thisArg) {
    return apply(this, "map", fn2, thisArg, void 0, arguments);
  },
  pop() {
    return noTracking(this, "pop");
  },
  push(...args) {
    return noTracking(this, "push", args);
  },
  reduce(fn2, ...args) {
    return reduce(this, "reduce", fn2, args);
  },
  reduceRight(fn2, ...args) {
    return reduce(this, "reduceRight", fn2, args);
  },
  shift() {
    return noTracking(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(fn2, thisArg) {
    return apply(this, "some", fn2, thisArg, void 0, arguments);
  },
  splice(...args) {
    return noTracking(this, "splice", args);
  },
  toReversed() {
    return reactiveReadArray(this).toReversed();
  },
  toSorted(comparer) {
    return reactiveReadArray(this).toSorted(comparer);
  },
  toSpliced(...args) {
    return reactiveReadArray(this).toSpliced(...args);
  },
  unshift(...args) {
    return noTracking(this, "unshift", args);
  },
  values() {
    return iterator(this, "values", toReactive);
  }
};
function iterator(self2, method, wrapValue) {
  const arr = shallowReadArray(self2);
  const iter = arr[method]();
  if (arr !== self2 && !isShallow(self2)) {
    iter._next = iter.next;
    iter.next = () => {
      const result = iter._next();
      if (result.value) {
        result.value = wrapValue(result.value);
      }
      return result;
    };
  }
  return iter;
}
var arrayProto = Array.prototype;
function apply(self2, method, fn2, thisArg, wrappedRetFn, args) {
  const arr = shallowReadArray(self2);
  const needsWrap = arr !== self2 && !isShallow(self2);
  const methodFn = arr[method];
  if (methodFn !== arrayProto[method]) {
    const result2 = methodFn.apply(self2, args);
    return needsWrap ? toReactive(result2) : result2;
  }
  let wrappedFn = fn2;
  if (arr !== self2) {
    if (needsWrap) {
      wrappedFn = function(item, index) {
        return fn2.call(this, toReactive(item), index, self2);
      };
    } else if (fn2.length > 2) {
      wrappedFn = function(item, index) {
        return fn2.call(this, item, index, self2);
      };
    }
  }
  const result = methodFn.call(arr, wrappedFn, thisArg);
  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
}
function reduce(self2, method, fn2, args) {
  const arr = shallowReadArray(self2);
  let wrappedFn = fn2;
  if (arr !== self2) {
    if (!isShallow(self2)) {
      wrappedFn = function(acc, item, index) {
        return fn2.call(this, acc, toReactive(item), index, self2);
      };
    } else if (fn2.length > 3) {
      wrappedFn = function(acc, item, index) {
        return fn2.call(this, acc, item, index, self2);
      };
    }
  }
  return arr[method](wrappedFn, ...args);
}
function searchProxy(self2, method, args) {
  const arr = toRaw(self2);
  track(arr, "iterate", ARRAY_ITERATE_KEY);
  const res = arr[method](...args);
  if ((res === -1 || res === false) && isProxy(args[0])) {
    args[0] = toRaw(args[0]);
    return arr[method](...args);
  }
  return res;
}
function noTracking(self2, method, args = []) {
  pauseTracking();
  startBatch();
  const res = toRaw(self2)[method].apply(self2, args);
  endBatch();
  resetTracking();
  return res;
}
var isNonTrackableKeys = makeMap(`__proto__,__v_isRef,__isVue`);
var builtInSymbols = new Set(
  Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
function hasOwnProperty2(key) {
  if (!isSymbol(key))
    key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
var BaseReactiveHandler = class {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    if (key === "__v_skip")
      return target["__v_skip"];
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly2) {
      let fn2;
      if (targetIsArray && (fn2 = arrayInstrumentations[key])) {
        return fn2;
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty2;
      }
    }
    const res = Reflect.get(
      target,
      key,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      isRef2(target) ? target : receiver
    );
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef2(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
};
var MutableReactiveHandler = class extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray(target) && isRef2(oldValue) && !isRef2(value)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(
      target,
      key,
      value,
      isRef2(target) ? target : receiver
    );
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
};
var ReadonlyReactiveHandler = class extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    if (true) {
      warn(
        `Set operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  }
  deleteProperty(target, key) {
    if (true) {
      warn(
        `Delete operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  }
};
var mutableHandlers = new MutableReactiveHandler();
var readonlyHandlers = new ReadonlyReactiveHandler();
var shallowReactiveHandlers = new MutableReactiveHandler(true);
var shallowReadonlyHandlers = new ReadonlyReactiveHandler(true);
var toShallow = (value) => value;
var getProto = (v) => Reflect.getPrototypeOf(v);
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    if (true) {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      warn(
        `${capitalize(type)} operation ${key}failed: target is readonly.`,
        toRaw(this)
      );
    }
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations(readonly2, shallow) {
  const instrumentations = {
    get(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has } = getProto(rawTarget);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    },
    get size() {
      const target = this["__v_raw"];
      !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    },
    has(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    },
    forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    }
  };
  extend(
    instrumentations,
    readonly2 ? {
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear")
    } : {
      add(value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger(target, "add", value, value);
        }
        return this;
      },
      set(key, value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        } else if (true) {
          checkIdentityKeys(target, has, key);
        }
        const oldValue = get.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
        return this;
      },
      delete(key) {
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        } else if (true) {
          checkIdentityKeys(target, has, key);
        }
        const oldValue = get ? get.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0, oldValue);
        }
        return result;
      },
      clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const oldTarget = true ? isMap(target) ? new Map(target) : new Set(target) : void 0;
        const result = target.clear();
        if (hadItems) {
          trigger(
            target,
            "clear",
            void 0,
            void 0,
            oldTarget
          );
        }
        return result;
      }
    }
  );
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    instrumentations[method] = createIterableMethod(method, readonly2, shallow);
  });
  return instrumentations;
}
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = createInstrumentations(isReadonly2, shallow);
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
var mutableCollectionHandlers = {
  get: createInstrumentationGetter(false, false)
};
var shallowCollectionHandlers = {
  get: createInstrumentationGetter(false, true)
};
var readonlyCollectionHandlers = {
  get: createInstrumentationGetter(true, false)
};
var shallowReadonlyCollectionHandlers = {
  get: createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has.call(target, rawKey)) {
    const type = toRawType(target);
    warn(
      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
var reactiveMap = /* @__PURE__ */ new WeakMap();
var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
var readonlyMap = /* @__PURE__ */ new WeakMap();
var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject(target)) {
    if (true) {
      warn(
        `value cannot be made ${isReadonly2 ? "readonly" : "reactive"}: ${String(
          target
        )}`
      );
    }
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return value ? !!value["__v_raw"] : false;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
    def(value, "__v_skip", true);
  }
  return value;
}
var toReactive = (value) => isObject(value) ? reactive(value) : value;
var toReadonly = (value) => isObject(value) ? readonly(value) : value;
function isRef2(r) {
  return r ? r["__v_isRef"] === true : false;
}
function ref(value) {
  return createRef(value, false);
}
function createRef(rawValue, shallow) {
  if (isRef2(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
var RefImpl = class {
  constructor(value, isShallow2) {
    this.dep = new Dep();
    this["__v_isRef"] = true;
    this["__v_isShallow"] = false;
    this._rawValue = isShallow2 ? value : toRaw(value);
    this._value = isShallow2 ? value : toReactive(value);
    this["__v_isShallow"] = isShallow2;
  }
  get value() {
    if (true) {
      this.dep.track({
        target: this,
        type: "get",
        key: "value"
      });
    } else {
      this.dep.track();
    }
    return this._value;
  }
  set value(newValue) {
    const oldValue = this._rawValue;
    const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
    newValue = useDirectValue ? newValue : toRaw(newValue);
    if (hasChanged(newValue, oldValue)) {
      this._rawValue = newValue;
      this._value = useDirectValue ? newValue : toReactive(newValue);
      if (true) {
        this.dep.trigger({
          target: this,
          type: "set",
          key: "value",
          newValue,
          oldValue
        });
      } else {
        this.dep.trigger();
      }
    }
  }
};
function unref(ref2) {
  return isRef2(ref2) ? ref2.value : ref2;
}
var shallowUnwrapHandlers = {
  get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef2(oldValue) && !isRef2(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
function toRefs(object) {
  if (!isProxy(object)) {
    warn(`toRefs() expects a reactive object but received a plain one.`);
  }
  const ret = isArray(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
var ObjectRefImpl = class {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this["__v_isRef"] = true;
    this._value = void 0;
  }
  get value() {
    const val = this._object[this._key];
    return this._value = val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
};
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef2(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
var ComputedRefImpl = class {
  constructor(fn2, setter, isSSR) {
    this.fn = fn2;
    this.setter = setter;
    this._value = void 0;
    this.dep = new Dep(this);
    this.__v_isRef = true;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 16;
    this.globalVersion = globalVersion - 1;
    this.next = void 0;
    this.effect = this;
    this["__v_isReadonly"] = !setter;
    this.isSSR = isSSR;
  }
  /**
   * @internal
   */
  notify() {
    this.flags |= 16;
    if (!(this.flags & 8) && // avoid infinite self recursion
    activeSub !== this) {
      batch(this, true);
      return true;
    } else if (true)
      ;
  }
  get value() {
    const link = true ? this.dep.track({
      target: this,
      type: "get",
      key: "value"
    }) : this.dep.track();
    refreshComputed(this);
    if (link) {
      link.version = this.dep.version;
    }
    return this._value;
  }
  set value(newValue) {
    if (this.setter) {
      this.setter(newValue);
    } else if (true) {
      warn("Write operation failed: computed value is readonly");
    }
  }
};
function computed(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  if (isFunction(getterOrOptions)) {
    getter = getterOrOptions;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, isSSR);
  if (debugOptions && !isSSR) {
    cRef.onTrack = debugOptions.onTrack;
    cRef.onTrigger = debugOptions.onTrigger;
  }
  return cRef;
}
var INITIAL_WATCHER_VALUE = {};
var cleanupMap = /* @__PURE__ */ new WeakMap();
var activeWatcher = void 0;
function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
  if (owner) {
    let cleanups = cleanupMap.get(owner);
    if (!cleanups)
      cleanupMap.set(owner, cleanups = []);
    cleanups.push(cleanupFn);
  } else if (!failSilently) {
    warn(
      `onWatcherCleanup() was called when there was no active watcher to associate with.`
    );
  }
}
function watch(source, cb2, options = EMPTY_OBJ) {
  const { immediate, deep, once, scheduler, augmentJob, call } = options;
  const warnInvalidSource = (s) => {
    (options.onWarn || warn)(
      `Invalid watch source: `,
      s,
      `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`
    );
  };
  const reactiveGetter = (source2) => {
    if (deep)
      return source2;
    if (isShallow(source2) || deep === false || deep === 0)
      return traverse(source2, 1);
    return traverse(source2);
  };
  let effect2;
  let getter;
  let cleanup;
  let boundCleanup;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef2(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef2(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if (isFunction(s)) {
        return call ? call(s, 2) : s();
      } else {
        warnInvalidSource(s);
      }
    });
  } else if (isFunction(source)) {
    if (cb2) {
      getter = call ? () => call(source, 2) : source;
    } else {
      getter = () => {
        if (cleanup) {
          pauseTracking();
          try {
            cleanup();
          } finally {
            resetTracking();
          }
        }
        const currentEffect = activeWatcher;
        activeWatcher = effect2;
        try {
          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
        } finally {
          activeWatcher = currentEffect;
        }
      };
    }
  } else {
    getter = NOOP;
    warnInvalidSource(source);
  }
  if (cb2 && deep) {
    const baseGetter = getter;
    const depth = deep === true ? Infinity : deep;
    getter = () => traverse(baseGetter(), depth);
  }
  const scope = getCurrentScope();
  const watchHandle = () => {
    effect2.stop();
    if (scope && scope.active) {
      remove(scope.effects, effect2);
    }
  };
  if (once && cb2) {
    const _cb = cb2;
    cb2 = (...args) => {
      _cb(...args);
      watchHandle();
    };
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = (immediateFirstRun) => {
    if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
      return;
    }
    if (cb2) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
        if (cleanup) {
          cleanup();
        }
        const currentWatcher = activeWatcher;
        activeWatcher = effect2;
        try {
          const args = [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            boundCleanup
          ];
          call ? call(cb2, 3, args) : (
            // @ts-expect-error
            cb2(...args)
          );
          oldValue = newValue;
        } finally {
          activeWatcher = currentWatcher;
        }
      }
    } else {
      effect2.run();
    }
  };
  if (augmentJob) {
    augmentJob(job);
  }
  effect2 = new ReactiveEffect(getter);
  effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
  boundCleanup = (fn2) => onWatcherCleanup(fn2, false, effect2);
  cleanup = effect2.onStop = () => {
    const cleanups = cleanupMap.get(effect2);
    if (cleanups) {
      if (call) {
        call(cleanups, 4);
      } else {
        for (const cleanup2 of cleanups)
          cleanup2();
      }
      cleanupMap.delete(effect2);
    }
  };
  if (true) {
    effect2.onTrack = options.onTrack;
    effect2.onTrigger = options.onTrigger;
  }
  if (cb2) {
    if (immediate) {
      job(true);
    } else {
      oldValue = effect2.run();
    }
  } else if (scheduler) {
    scheduler(job.bind(null, true), true);
  } else {
    effect2.run();
  }
  watchHandle.pause = effect2.pause.bind(effect2);
  watchHandle.resume = effect2.resume.bind(effect2);
  watchHandle.stop = watchHandle;
  return watchHandle;
}
function traverse(value, depth = Infinity, seen) {
  if (depth <= 0 || !isObject(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  depth--;
  if (isRef2(value)) {
    traverse(value.value, depth, seen);
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], depth, seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, depth, seen);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], depth, seen);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      if (Object.prototype.propertyIsEnumerable.call(value, key)) {
        traverse(value[key], depth, seen);
      }
    }
  }
  return value;
}

// node_modules/.pnpm/@vue+runtime-core@3.5.13/node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js
var stack = [];
function pushWarningContext(vnode) {
  stack.push(vnode);
}
function popWarningContext() {
  stack.pop();
}
var isWarning = false;
function warn$1(msg, ...args) {
  if (isWarning)
    return;
  isWarning = true;
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        msg + args.map((a) => {
          var _a2, _b2;
          return (_b2 = (_a2 = a.toString) == null ? void 0 : _a2.call(a)) != null ? _b2 : JSON.stringify(a);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
  isWarning = false;
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef2(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
function assertNumber(val, type) {
  if (false)
    return;
  if (val === void 0) {
    return;
  } else if (typeof val !== "number") {
    warn$1(`${type} is not a valid number - got ${JSON.stringify(val)}.`);
  } else if (isNaN(val)) {
    warn$1(`${type} is NaN - the duration expression might be incorrect.`);
  }
}
var ErrorTypeStrings$1 = {
  ["sp"]: "serverPrefetch hook",
  ["bc"]: "beforeCreate hook",
  ["c"]: "created hook",
  ["bm"]: "beforeMount hook",
  ["m"]: "mounted hook",
  ["bu"]: "beforeUpdate hook",
  ["u"]: "updated",
  ["bum"]: "beforeUnmount hook",
  ["um"]: "unmounted hook",
  ["a"]: "activated hook",
  ["da"]: "deactivated hook",
  ["ec"]: "errorCaptured hook",
  ["rtc"]: "renderTracked hook",
  ["rtg"]: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush",
  [15]: "component update",
  [16]: "app unmount cleanup function"
};
function callWithErrorHandling(fn2, instance, type, args) {
  try {
    return args ? fn2(...args) : fn2();
  } catch (err) {
    handleError(err, instance, type);
  }
}
function callWithAsyncErrorHandling(fn2, instance, type, args) {
  if (isFunction(fn2)) {
    const res = callWithErrorHandling(fn2, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  if (isArray(fn2)) {
    const values = [];
    for (let i = 0; i < fn2.length; i++) {
      values.push(callWithAsyncErrorHandling(fn2[i], instance, type, args));
    }
    return values;
  } else if (true) {
    warn$1(
      `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof fn2}`
    );
  }
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = true ? ErrorTypeStrings$1[type] : `https://vuejs.org/error-reference/#runtime-${type}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    if (errorHandler) {
      pauseTracking();
      callWithErrorHandling(errorHandler, null, 10, [
        err,
        exposedInstance,
        errorInfo
      ]);
      resetTracking();
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
}
function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
  if (true) {
    const info = ErrorTypeStrings$1[type];
    if (contextVNode) {
      pushWarningContext(contextVNode);
    }
    warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
    if (contextVNode) {
      popWarningContext();
    }
    if (throwInDev) {
      throw err;
    } else {
      console.error(err);
    }
  } else if (throwInProd) {
    throw err;
  } else {
    console.error(err);
  }
}
var queue = [];
var flushIndex = -1;
var pendingPostFlushCbs = [];
var activePostFlushCbs = null;
var postFlushIndex = 0;
var resolvedPromise = Promise.resolve();
var currentFlushPromise = null;
var RECURSION_LIMIT = 100;
function nextTick(fn2) {
  const p5 = currentFlushPromise || resolvedPromise;
  return fn2 ? p5.then(this ? fn2.bind(this) : fn2) : p5;
}
function findInsertionIndex(id2) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id2 || middleJobId === id2 && middleJob.flags & 2) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!(job.flags & 1)) {
    const jobId = getId(job);
    const lastJob = queue[queue.length - 1];
    if (!lastJob || // fast path when the job id is larger than the tail
    !(job.flags & 2) && jobId >= getId(lastJob)) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(jobId), 0, job);
    }
    job.flags |= 1;
    queueFlush();
  }
}
function queueFlush() {
  if (!currentFlushPromise) {
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function queuePostFlushCb(cb2) {
  if (!isArray(cb2)) {
    if (activePostFlushCbs && cb2.id === -1) {
      activePostFlushCbs.splice(postFlushIndex + 1, 0, cb2);
    } else if (!(cb2.flags & 1)) {
      pendingPostFlushCbs.push(cb2);
      cb2.flags |= 1;
    }
  } else {
    pendingPostFlushCbs.push(...cb2);
  }
  queueFlush();
}
function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
  if (true) {
    seen = seen || /* @__PURE__ */ new Map();
  }
  for (; i < queue.length; i++) {
    const cb2 = queue[i];
    if (cb2 && cb2.flags & 2) {
      if (instance && cb2.id !== instance.uid) {
        continue;
      }
      if (checkRecursiveUpdates(seen, cb2)) {
        continue;
      }
      queue.splice(i, 1);
      i--;
      if (cb2.flags & 4) {
        cb2.flags &= ~1;
      }
      cb2();
      if (!(cb2.flags & 4)) {
        cb2.flags &= ~1;
      }
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a, b) => getId(a) - getId(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    if (true) {
      seen = seen || /* @__PURE__ */ new Map();
    }
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      const cb2 = activePostFlushCbs[postFlushIndex];
      if (checkRecursiveUpdates(seen, cb2)) {
        continue;
      }
      if (cb2.flags & 4) {
        cb2.flags &= ~1;
      }
      if (!(cb2.flags & 8))
        cb2();
      cb2.flags &= ~1;
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
var getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
function flushJobs(seen) {
  if (true) {
    seen = seen || /* @__PURE__ */ new Map();
  }
  const check = true ? (job) => checkRecursiveUpdates(seen, job) : NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && !(job.flags & 8)) {
        if (check(job)) {
          continue;
        }
        if (job.flags & 4) {
          job.flags &= ~1;
        }
        callWithErrorHandling(
          job,
          job.i,
          job.i ? 15 : 14
        );
        if (!(job.flags & 4)) {
          job.flags &= ~1;
        }
      }
    }
  } finally {
    for (; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job) {
        job.flags &= ~1;
      }
    }
    flushIndex = -1;
    queue.length = 0;
    flushPostFlushCbs(seen);
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}
function checkRecursiveUpdates(seen, fn2) {
  const count = seen.get(fn2) || 0;
  if (count > RECURSION_LIMIT) {
    const instance = fn2.i;
    const componentName = instance && getComponentName(instance.type);
    handleError(
      `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
      null,
      10
    );
    return true;
  }
  seen.set(fn2, count + 1);
  return false;
}
var isHmrUpdating = false;
var hmrDirtyComponents = /* @__PURE__ */ new Map();
if (true) {
  getGlobalThis().__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
  };
}
var map = /* @__PURE__ */ new Map();
function registerHMR(instance) {
  const id2 = instance.type.__hmrId;
  let record = map.get(id2);
  if (!record) {
    createRecord(id2, instance.type);
    record = map.get(id2);
  }
  record.instances.add(instance);
}
function unregisterHMR(instance) {
  map.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id2, initialDef) {
  if (map.has(id2)) {
    return false;
  }
  map.set(id2, {
    initialDef: normalizeClassComponent(initialDef),
    instances: /* @__PURE__ */ new Set()
  });
  return true;
}
function normalizeClassComponent(component) {
  return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id2, newRender) {
  const record = map.get(id2);
  if (!record) {
    return;
  }
  record.initialDef.render = newRender;
  [...record.instances].forEach((instance) => {
    if (newRender) {
      instance.render = newRender;
      normalizeClassComponent(instance.type).render = newRender;
    }
    instance.renderCache = [];
    isHmrUpdating = true;
    instance.update();
    isHmrUpdating = false;
  });
}
function reload(id2, newComp) {
  const record = map.get(id2);
  if (!record)
    return;
  newComp = normalizeClassComponent(newComp);
  updateComponentDef(record.initialDef, newComp);
  const instances = [...record.instances];
  for (let i = 0; i < instances.length; i++) {
    const instance = instances[i];
    const oldComp = normalizeClassComponent(instance.type);
    let dirtyInstances = hmrDirtyComponents.get(oldComp);
    if (!dirtyInstances) {
      if (oldComp !== record.initialDef) {
        updateComponentDef(oldComp, newComp);
      }
      hmrDirtyComponents.set(oldComp, dirtyInstances = /* @__PURE__ */ new Set());
    }
    dirtyInstances.add(instance);
    instance.appContext.propsCache.delete(instance.type);
    instance.appContext.emitsCache.delete(instance.type);
    instance.appContext.optionsCache.delete(instance.type);
    if (instance.ceReload) {
      dirtyInstances.add(instance);
      instance.ceReload(newComp.styles);
      dirtyInstances.delete(instance);
    } else if (instance.parent) {
      queueJob(() => {
        isHmrUpdating = true;
        instance.parent.update();
        isHmrUpdating = false;
        dirtyInstances.delete(instance);
      });
    } else if (instance.appContext.reload) {
      instance.appContext.reload();
    } else if (typeof window !== "undefined") {
      window.location.reload();
    } else {
      console.warn(
        "[HMR] Root or manually mounted instance modified. Full reload required."
      );
    }
    if (instance.root.ce && instance !== instance.root) {
      instance.root.ce._removeChildStyle(oldComp);
    }
  }
  queuePostFlushCb(() => {
    hmrDirtyComponents.clear();
  });
}
function updateComponentDef(oldComp, newComp) {
  extend(oldComp, newComp);
  for (const key in oldComp) {
    if (key !== "__file" && !(key in newComp)) {
      delete oldComp[key];
    }
  }
}
function tryWrap(fn2) {
  return (id2, arg) => {
    try {
      return fn2(id2, arg);
    } catch (e) {
      console.error(e);
      console.warn(
        `[HMR] Something went wrong during Vue component hot-reload. Full reload required.`
      );
    }
  };
}
var devtools$1;
var buffer = [];
var devtoolsNotInstalled = false;
function emit$1(event, ...args) {
  if (devtools$1) {
    devtools$1.emit(event, ...args);
  } else if (!devtoolsNotInstalled) {
    buffer.push({ event, args });
  }
}
function setDevtoolsHook$1(hook, target) {
  var _a2, _b2;
  devtools$1 = hook;
  if (devtools$1) {
    devtools$1.enabled = true;
    buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));
    buffer = [];
  } else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    // eslint-disable-next-line no-restricted-syntax
    !((_b2 = (_a2 = window.navigator) == null ? void 0 : _a2.userAgent) == null ? void 0 : _b2.includes("jsdom"))
  ) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook$1(newHook, target);
    });
    setTimeout(() => {
      if (!devtools$1) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        devtoolsNotInstalled = true;
        buffer = [];
      }
    }, 3e3);
  } else {
    devtoolsNotInstalled = true;
    buffer = [];
  }
}
function devtoolsInitApp(app, version2) {
  emit$1("app:init", app, version2, {
    Fragment,
    Text,
    Comment,
    Static
  });
}
function devtoolsUnmountApp(app) {
  emit$1("app:unmount", app);
}
var devtoolsComponentAdded = createDevtoolsComponentHook(
  "component:added"
  /* COMPONENT_ADDED */
);
var devtoolsComponentUpdated = createDevtoolsComponentHook(
  "component:updated"
  /* COMPONENT_UPDATED */
);
var _devtoolsComponentRemoved = createDevtoolsComponentHook(
  "component:removed"
  /* COMPONENT_REMOVED */
);
var devtoolsComponentRemoved = (component) => {
  if (devtools$1 && typeof devtools$1.cleanupBuffer === "function" && // remove the component if it wasn't buffered
  !devtools$1.cleanupBuffer(component)) {
    _devtoolsComponentRemoved(component);
  }
};
function createDevtoolsComponentHook(hook) {
  return (component) => {
    emit$1(
      hook,
      component.appContext.app,
      component.uid,
      component.parent ? component.parent.uid : void 0,
      component
    );
  };
}
var devtoolsPerfStart = createDevtoolsPerformanceHook(
  "perf:start"
  /* PERFORMANCE_START */
);
var devtoolsPerfEnd = createDevtoolsPerformanceHook(
  "perf:end"
  /* PERFORMANCE_END */
);
function createDevtoolsPerformanceHook(hook) {
  return (component, type, time) => {
    emit$1(hook, component.appContext.app, component.uid, component, type, time);
  };
}
function devtoolsComponentEmit(component, event, params) {
  emit$1(
    "component:emit",
    component.appContext.app,
    component,
    event,
    params
  );
}
var currentRenderingInstance = null;
var currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn2;
  if (fn2._n) {
    return fn2;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn2(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    if (true) {
      devtoolsComponentUpdated(ctx);
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function validateDirectiveName(name) {
  if (isBuiltInDirective(name)) {
    warn$1("Do not use built-in directive ids as custom directive id: " + name);
  }
}
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
    warn$1(`withDirectives can only be used inside render functions.`);
    return vnode;
  }
  const instance = getComponentPublicInstance(currentRenderingInstance);
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (dir) {
      if (isFunction(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
var TeleportEndKey = Symbol("_vte");
var isTeleport = (type) => type.__isTeleport;
var leaveCbKey = Symbol("_leaveCb");
var enterCbKey = Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
var TransitionHookValidator = [Function, Array];
var BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
var recursiveGetSubtree = (instance) => {
  const subTree = instance.subTree;
  return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
};
var BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      const child = findNonCommentChild(children);
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (mode && mode !== "in-out" && mode !== "out-in" && mode !== "default") {
        warn$1(`invalid <transition> mode: ${mode}`);
      }
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getInnerChild$1(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      let enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance,
        // #11061, ensure enterHooks is fresh after clone
        (hooks) => enterHooks = hooks
      );
      if (innerChild.type !== Comment) {
        setTransitionHooks(innerChild, enterHooks);
      }
      let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
        let leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in" && innerChild.type !== Comment) {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (!(instance.job.flags & 8)) {
              instance.update();
            }
            delete leavingHooks.afterLeave;
            oldInnerChild = void 0;
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el2, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el2[leaveCbKey] = () => {
              earlyRemove();
              el2[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
            enterHooks.delayedLeave = () => {
              delayedLeave();
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
          };
        } else {
          oldInnerChild = void 0;
        }
      } else if (oldInnerChild) {
        oldInnerChild = void 0;
      }
      return child;
    };
  }
};
function findNonCommentChild(children) {
  let child = children[0];
  if (children.length > 1) {
    let hasFound = false;
    for (const c of children) {
      if (c.type !== Comment) {
        if (hasFound) {
          warn$1(
            "<transition> can only be used on a single element or component. Use <transition-group> for lists."
          );
          break;
        }
        child = c;
        hasFound = true;
        if (false)
          break;
      }
    }
  }
  return child;
}
var BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance, postClone) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook3 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook3(hook, args);
    if (isArray(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el2) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el2[leaveCbKey]) {
        el2[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook3(hook, [el2]);
    },
    enter(el2) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el2[enterCbKey] = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook3(cancelHook, [el2]);
        } else {
          callHook3(afterHook, [el2]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el2[enterCbKey] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el2, done]);
      } else {
        done();
      }
    },
    leave(el2, remove2) {
      const key2 = String(vnode.key);
      if (el2[enterCbKey]) {
        el2[enterCbKey](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook3(onBeforeLeave, [el2]);
      let called = false;
      const done = el2[leaveCbKey] = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook3(onLeaveCancelled, [el2]);
        } else {
          callHook3(onAfterLeave, [el2]);
        }
        el2[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el2, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      const hooks2 = resolveTransitionHooks(
        vnode2,
        props,
        state,
        instance,
        postClone
      );
      if (postClone)
        postClone(hooks2);
      return hooks2;
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getInnerChild$1(vnode) {
  if (!isKeepAlive(vnode)) {
    if (isTeleport(vnode.type) && vnode.children) {
      return findNonCommentChild(vnode.children);
    }
    return vnode;
  }
  if (vnode.component) {
    return vnode.component.subTree;
  }
  const { shapeFlag, children } = vnode;
  if (children) {
    if (shapeFlag & 16) {
      return children[0];
    }
    if (shapeFlag & 32 && isFunction(children.default)) {
      return children.default();
    }
  }
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    vnode.transition = hooks;
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
function defineComponent(options, extraOptions) {
  return isFunction(options) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    (() => extend({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
function markAsyncBoundary(instance) {
  instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
}
var knownTemplateRefs = /* @__PURE__ */ new WeakSet();
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray(rawRef)) {
    rawRef.forEach(
      (r, i) => setRef(
        r,
        oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
      setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
    }
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  if (!owner) {
    warn$1(
      `Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`
    );
    return;
  }
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  const rawSetupState = toRaw(setupState);
  const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
    if (true) {
      if (hasOwn(rawSetupState, key) && !isRef2(rawSetupState[key])) {
        warn$1(
          `Template ref "${key}" used on a non-ref value. It will not work in the production build.`
        );
      }
      if (knownTemplateRefs.has(rawSetupState[key])) {
        return false;
      }
    }
    return hasOwn(rawSetupState, key);
  };
  if (oldRef != null && oldRef !== ref2) {
    if (isString(oldRef)) {
      refs[oldRef] = null;
      if (canSetSetupRef(oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef2(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else {
    const _isString = isString(ref2);
    const _isRef = isRef2(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? canSetSetupRef(ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray(existing) && remove(existing, refValue);
          } else {
            if (!isArray(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                if (canSetSetupRef(ref2)) {
                  setupState[ref2] = refs[ref2];
                }
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value;
          if (canSetSetupRef(ref2)) {
            setupState[ref2] = value;
          }
        } else if (_isRef) {
          ref2.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else if (true) {
          warn$1("Invalid template ref type:", ref2, `(${typeof ref2})`);
        }
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    } else if (true) {
      warn$1("Invalid template ref type:", ref2, `(${typeof ref2})`);
    }
  }
}
var requestIdleCallback = getGlobalThis().requestIdleCallback || ((cb2) => setTimeout(cb2, 1));
var cancelIdleCallback = getGlobalThis().cancelIdleCallback || ((id2) => clearTimeout(id2));
var isAsyncWrapper = (i) => !!i.type.__asyncLoader;
var isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      pauseTracking();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      reset();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  } else if (true) {
    const apiName = toHandlerKey(ErrorTypeStrings$1[type].replace(/ hook$/, ""));
    warn$1(
      `${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
    );
  }
}
var createHook = (lifecycle) => (hook, target = currentInstance) => {
  if (!isInSSRComponentSetup || lifecycle === "sp") {
    injectHook(lifecycle, (...args) => hook(...args), target);
  }
};
var onBeforeMount = createHook("bm");
var onMounted = createHook("m");
var onBeforeUpdate = createHook(
  "bu"
);
var onUpdated = createHook("u");
var onBeforeUnmount = createHook(
  "bum"
);
var onUnmounted = createHook("um");
var onServerPrefetch = createHook(
  "sp"
);
var onRenderTriggered = createHook("rtg");
var onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
var COMPONENTS = "components";
var NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name) || // global registration
      resolve(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    if (warnMissing && !res) {
      const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
      warn$1(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
    }
    return res;
  } else if (true) {
    warn$1(
      `resolve${capitalize(type.slice(0, -1))} can only be used in render() or setup().`
    );
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
}
function renderList(source, renderItem, cache, index) {
  let ret;
  const cached = cache && cache[index];
  const sourceIsArray = isArray(source);
  if (sourceIsArray || isString(source)) {
    const sourceIsReactiveArray = sourceIsArray && isReactive(source);
    let needsWrap = false;
    if (sourceIsReactiveArray) {
      needsWrap = !isShallow(source);
      source = shallowReadArray(source);
    }
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(
        needsWrap ? toReactive(source[i]) : source[i],
        i,
        void 0,
        cached && cached[i]
      );
    }
  } else if (typeof source === "number") {
    if (!Number.isInteger(source)) {
      warn$1(`The v-for range expect an integer value but got ${source}.`);
    }
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if (isObject(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached && cached[i])
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index] = ret;
  }
  return ret;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
    if (name !== "default")
      props.name = name;
    return openBlock(), createBlock(
      Fragment,
      null,
      [createVNode("slot", props, fallback && fallback())],
      64
    );
  }
  let slot = slots[name];
  if (slot && slot.length > 1) {
    warn$1(
      `SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`
    );
    slot = () => [];
  }
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  validSlotContent && validSlotContent.key;
  const rendered = createBlock(
    Fragment,
    {
      key: (slotKey && !isSymbol(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
      (!validSlotContent && fallback ? "_fb" : "")
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
var getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getComponentPublicInstance(i);
  return getPublicInstance(i.parent);
};
var publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  extend(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => true ? shallowReadonly(i.props) : i.props,
    $attrs: (i) => true ? shallowReadonly(i.attrs) : i.attrs,
    $slots: (i) => true ? shallowReadonly(i.slots) : i.slots,
    $refs: (i) => true ? shallowReadonly(i.refs) : i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $host: (i) => i.ce,
    $emit: (i) => i.emit,
    $options: (i) => __VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type,
    $forceUpdate: (i) => i.f || (i.f = () => {
      queueJob(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => __VUE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP
  })
);
var isReservedPrefix = (key) => key === "_" || key === "$";
var hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
var PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    if (key === "__v_skip") {
      return true;
    }
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    if (key === "__isVue") {
      return true;
    }
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance.attrs, "get", "");
        markAttrsAccessed();
      } else if (key === "$slots") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else if (currentRenderingInstance && (!isString(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    key.indexOf("__v") !== 0)) {
      if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {
        warn$1(
          `Property ${JSON.stringify(
            key
          )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
        );
      } else if (instance === currentRenderingInstance) {
        warn$1(
          `Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`
        );
      }
    }
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (setupState.__isScriptSetup && hasOwn(setupState, key)) {
      warn$1(`Cannot mutate <script setup> binding "${key}" from Options API.`);
      return false;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      warn$1(`Attempting to mutate prop "${key}". Props are readonly.`);
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      warn$1(
        `Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`
      );
      return false;
    } else {
      if (key in instance.appContext.config.globalProperties) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          value
        });
      } else {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
if (true) {
  PublicInstanceProxyHandlers.ownKeys = (target) => {
    warn$1(
      `Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`
    );
    return Reflect.ownKeys(target);
  };
}
var RuntimeCompiledPublicInstanceProxyHandlers = extend({}, PublicInstanceProxyHandlers, {
  get(target, key) {
    if (key === Symbol.unscopables) {
      return;
    }
    return PublicInstanceProxyHandlers.get(target, key, target);
  },
  has(_, key) {
    const has = key[0] !== "_" && !isGloballyAllowed(key);
    if (!has && PublicInstanceProxyHandlers.has(_, key)) {
      warn$1(
        `Property ${JSON.stringify(
          key
        )} should not start with _ which is a reserved prefix for Vue internals.`
      );
    }
    return has;
  }
});
function createDevRenderContext(instance) {
  const target = {};
  Object.defineProperty(target, `_`, {
    configurable: true,
    enumerable: false,
    get: () => instance
  });
  Object.keys(publicPropertiesMap).forEach((key) => {
    Object.defineProperty(target, key, {
      configurable: true,
      enumerable: false,
      get: () => publicPropertiesMap[key](instance),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: NOOP
    });
  });
  return target;
}
function exposePropsOnRenderContext(instance) {
  const {
    ctx,
    propsOptions: [propsOptions]
  } = instance;
  if (propsOptions) {
    Object.keys(propsOptions).forEach((key) => {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => instance.props[key],
        set: NOOP
      });
    });
  }
}
function exposeSetupStateOnRenderContext(instance) {
  const { ctx, setupState } = instance;
  Object.keys(toRaw(setupState)).forEach((key) => {
    if (!setupState.__isScriptSetup) {
      if (isReservedPrefix(key[0])) {
        warn$1(
          `setup() return property ${JSON.stringify(
            key
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => setupState[key],
        set: NOOP
      });
    }
  });
}
function normalizePropsOrEmits(props) {
  return isArray(props) ? props.reduce(
    (normalized, p5) => (normalized[p5] = null, normalized),
    {}
  ) : props;
}
function createDuplicateChecker() {
  const cache = /* @__PURE__ */ Object.create(null);
  return (type, key) => {
    if (cache[key]) {
      warn$1(`${type} property "${key}" is already defined in ${cache[key]}.`);
    } else {
      cache[key] = type;
    }
  };
}
var shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = true ? createDuplicateChecker() : null;
  if (true) {
    const [propsOptions] = instance.propsOptions;
    if (propsOptions) {
      for (const key in propsOptions) {
        checkDuplicateProperties("Props", key);
      }
    }
  }
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction(methodHandler)) {
        if (true) {
          Object.defineProperty(ctx, key, {
            value: methodHandler.bind(publicThis),
            configurable: true,
            enumerable: true,
            writable: true
          });
        } else {
          ctx[key] = methodHandler.bind(publicThis);
        }
        if (true) {
          checkDuplicateProperties("Methods", key);
        }
      } else if (true) {
        warn$1(
          `Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`
        );
      }
    }
  }
  if (dataOptions) {
    if (!isFunction(dataOptions)) {
      warn$1(
        `The data option must be a function. Plain object usage is no longer supported.`
      );
    }
    const data = dataOptions.call(publicThis, publicThis);
    if (isPromise(data)) {
      warn$1(
        `data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`
      );
    }
    if (!isObject(data)) {
      warn$1(`data() should return an object.`);
    } else {
      instance.data = reactive(data);
      if (true) {
        for (const key in data) {
          checkDuplicateProperties("Data", key);
          if (!isReservedPrefix(key[0])) {
            Object.defineProperty(ctx, key, {
              configurable: true,
              enumerable: true,
              get: () => data[key],
              set: NOOP
            });
          }
        }
      }
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      if (get === NOOP) {
        warn$1(`Computed property "${key}" has no getter.`);
      }
      const set = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : true ? () => {
        warn$1(
          `Write operation failed: computed property "${key}" is readonly.`
        );
      } : NOOP;
      const c = computed2({
        get,
        set
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
      if (true) {
        checkDuplicateProperties("Computed", key);
      }
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
  if (serverPrefetch) {
    markAsyncBoundary(instance);
  }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef2(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
    if (true) {
      checkDuplicateProperties("Inject", key);
    }
  }
}
function callHook(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray(hook) ? hook.map((h5) => h5.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString(raw)) {
    const handler = ctx[raw];
    if (isFunction(handler)) {
      {
        watch2(getter, handler);
      }
    } else if (true) {
      warn$1(`Invalid watch handler specified by key "${raw}"`, handler);
    }
  } else if (isFunction(raw)) {
    {
      watch2(getter, raw.bind(publicThis));
    }
  } else if (isObject(raw)) {
    if (isArray(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction(handler)) {
        watch2(getter, handler, raw);
      } else if (true) {
        warn$1(`Invalid watch handler specified by key "${raw.handler}"`, handler);
      }
    }
  } else if (true) {
    warn$1(`Invalid watch option: "${key}"`, raw);
  }
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to2, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to2, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions(to2, m, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") {
      warn$1(
        `"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`
      );
    } else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to2[key] = strat ? strat(to2[key], from[key]) : from[key];
    }
  }
  return to2;
}
var internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to2, from) {
  if (!from) {
    return to2;
  }
  if (!to2) {
    return from;
  }
  return function mergedDataFn() {
    return extend(
      isFunction(to2) ? to2.call(this, this) : to2,
      isFunction(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to2, from) {
  return mergeObjectOptions(normalizeInject(to2), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to2, from) {
  return to2 ? [...new Set([].concat(to2, from))] : from;
}
function mergeObjectOptions(to2, from) {
  return to2 ? extend(/* @__PURE__ */ Object.create(null), to2, from) : from;
}
function mergeEmitsOrPropsOptions(to2, from) {
  if (to2) {
    if (isArray(to2) && isArray(from)) {
      return [.../* @__PURE__ */ new Set([...to2, ...from])];
    }
    return extend(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to2),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to2, from) {
  if (!to2)
    return from;
  if (!from)
    return to2;
  const merged = extend(/* @__PURE__ */ Object.create(null), to2);
  for (const key in from) {
    merged[key] = mergeAsArray(to2[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
var uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction(rootComponent)) {
      rootComponent = extend({}, rootComponent);
    }
    if (rootProps != null && !isObject(rootProps)) {
      warn$1(`root props passed to app.mount() must be an object.`);
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    const pluginCleanupFns = [];
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
        if (true) {
          warn$1(
            `app.config cannot be replaced. Modify individual options instead.`
          );
        }
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) {
          warn$1(`Plugin has already been applied to target app.`);
        } else if (plugin && isFunction(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else if (true) {
          warn$1(
            `A plugin must either be a function or an object with an "install" function.`
          );
        }
        return app;
      },
      mixin(mixin) {
        if (__VUE_OPTIONS_API__) {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          } else if (true) {
            warn$1(
              "Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : "")
            );
          }
        } else if (true) {
          warn$1("Mixins are only available in builds supporting Options API");
        }
        return app;
      },
      component(name, component) {
        if (true) {
          validateComponentName(name, context.config);
        }
        if (!component) {
          return context.components[name];
        }
        if (context.components[name]) {
          warn$1(`Component "${name}" has already been registered in target app.`);
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (true) {
          validateDirectiveName(name);
        }
        if (!directive) {
          return context.directives[name];
        }
        if (context.directives[name]) {
          warn$1(`Directive "${name}" has already been registered in target app.`);
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, namespace) {
        if (!isMounted) {
          if (rootContainer.__vue_app__) {
            warn$1(
              `There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`
            );
          }
          const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace === true) {
            namespace = "svg";
          } else if (namespace === false) {
            namespace = void 0;
          }
          if (true) {
            context.reload = () => {
              render(
                cloneVNode(vnode),
                rootContainer,
                namespace
              );
            };
          }
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, namespace);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          if (true) {
            app._instance = vnode.component;
            devtoolsInitApp(app, version);
          }
          return getComponentPublicInstance(vnode.component);
        } else if (true) {
          warn$1(
            `App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``
          );
        }
      },
      onUnmount(cleanupFn) {
        if (typeof cleanupFn !== "function") {
          warn$1(
            `Expected function as first argument to app.onUnmount(), but got ${typeof cleanupFn}`
          );
        }
        pluginCleanupFns.push(cleanupFn);
      },
      unmount() {
        if (isMounted) {
          callWithAsyncErrorHandling(
            pluginCleanupFns,
            app._instance,
            16
          );
          render(null, app._container);
          if (true) {
            app._instance = null;
            devtoolsUnmountApp(app);
          }
          delete app._container.__vue_app__;
        } else if (true) {
          warn$1(`Cannot unmount an app that is not mounted.`);
        }
      },
      provide(key, value) {
        if (key in context.provides) {
          warn$1(
            `App already provides property with key "${String(key)}". It will be overwritten with the new value.`
          );
        }
        context.provides[key] = value;
        return app;
      },
      runWithContext(fn2) {
        const lastApp = currentApp;
        currentApp = app;
        try {
          return fn2();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app;
  };
}
var currentApp = null;
function provide(key, value) {
  if (!currentInstance) {
    if (true) {
      warn$1(`provide() can only be used inside setup().`);
    }
  } else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else if (true) {
      warn$1(`injection "${String(key)}" not found.`);
    }
  } else if (true) {
    warn$1(`inject() can only be used inside setup() or functional components.`);
  }
}
var internalObjectProto = {};
var createInternalObject = () => Object.create(internalObjectProto);
var isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = createInternalObject();
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (true) {
    validateProps(rawProps || {}, props, instance);
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function isInHmrContext(instance) {
  while (instance) {
    if (instance.type.__hmrId)
      return true;
    instance = instance.parent;
  }
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !isInHmrContext(instance) && (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance.attrs, "set", "");
  }
  if (true) {
    validateProps(rawProps || {}, props, instance);
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset();
        }
      } else {
        value = defaultValue;
      }
      if (instance.ce) {
        instance.ce._setProp(key, value);
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
var mixinPropsCache = /* @__PURE__ */ new WeakMap();
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = __VUE_OPTIONS_API__ && asMixin ? mixinPropsCache : appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (__VUE_OPTIONS_API__ && !isFunction(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys)
        needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray(raw)) {
    for (let i = 0; i < raw.length; i++) {
      if (!isString(raw[i])) {
        warn$1(`props must be strings when using array syntax.`, raw[i]);
      }
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    if (!isObject(raw)) {
      warn$1(`invalid props options`, raw);
    }
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : extend({}, opt);
        const propType = prop.type;
        let shouldCast = false;
        let shouldCastTrue = true;
        if (isArray(propType)) {
          for (let index = 0; index < propType.length; ++index) {
            const type = propType[index];
            const typeName = isFunction(type) && type.name;
            if (typeName === "Boolean") {
              shouldCast = true;
              break;
            } else if (typeName === "String") {
              shouldCastTrue = false;
            }
          }
        } else {
          shouldCast = isFunction(propType) && propType.name === "Boolean";
        }
        prop[
          0
          /* shouldCast */
        ] = shouldCast;
        prop[
          1
          /* shouldCastTrue */
        ] = shouldCastTrue;
        if (shouldCast || hasOwn(prop, "default")) {
          needCastKeys.push(normalizedKey);
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  } else if (true) {
    warn$1(`Invalid prop name: "${key}" is a reserved property.`);
  }
  return false;
}
function getType(ctor) {
  if (ctor === null) {
    return "null";
  }
  if (typeof ctor === "function") {
    return ctor.name || "";
  } else if (typeof ctor === "object") {
    const name = ctor.constructor && ctor.constructor.name;
    return name || "";
  }
  return "";
}
function validateProps(rawProps, props, instance) {
  const resolvedValues = toRaw(props);
  const options = instance.propsOptions[0];
  const camelizePropsKey = Object.keys(rawProps).map((key) => camelize(key));
  for (const key in options) {
    let opt = options[key];
    if (opt == null)
      continue;
    validateProp(
      key,
      resolvedValues[key],
      opt,
      true ? shallowReadonly(resolvedValues) : resolvedValues,
      !camelizePropsKey.includes(key)
    );
  }
}
function validateProp(name, value, prop, props, isAbsent) {
  const { type, required, validator, skipCheck } = prop;
  if (required && isAbsent) {
    warn$1('Missing required prop: "' + name + '"');
    return;
  }
  if (value == null && !required) {
    return;
  }
  if (type != null && type !== true && !skipCheck) {
    let isValid = false;
    const types = isArray(type) ? type : [type];
    const expectedTypes = [];
    for (let i = 0; i < types.length && !isValid; i++) {
      const { valid, expectedType } = assertType(value, types[i]);
      expectedTypes.push(expectedType || "");
      isValid = valid;
    }
    if (!isValid) {
      warn$1(getInvalidTypeMessage(name, value, expectedTypes));
      return;
    }
  }
  if (validator && !validator(value, props)) {
    warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
  }
}
var isSimpleType = makeMap(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function assertType(value, type) {
  let valid;
  const expectedType = getType(type);
  if (expectedType === "null") {
    valid = value === null;
  } else if (isSimpleType(expectedType)) {
    const t = typeof value;
    valid = t === expectedType.toLowerCase();
    if (!valid && t === "object") {
      valid = value instanceof type;
    }
  } else if (expectedType === "Object") {
    valid = isObject(value);
  } else if (expectedType === "Array") {
    valid = isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid,
    expectedType
  };
}
function getInvalidTypeMessage(name, value, expectedTypes) {
  if (expectedTypes.length === 0) {
    return `Prop type [] for prop "${name}" won't match anything. Did you mean to use type Array instead?`;
  }
  let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize).join(" | ")}`;
  const expectedType = expectedTypes[0];
  const receivedType = toRawType(value);
  const expectedValue = styleValue(value, expectedType);
  const receivedValue = styleValue(value, receivedType);
  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += ` with value ${expectedValue}`;
  }
  message += `, got ${receivedType} `;
  if (isExplicable(receivedType)) {
    message += `with value ${receivedValue}.`;
  }
  return message;
}
function styleValue(value, type) {
  if (type === "String") {
    return `"${value}"`;
  } else if (type === "Number") {
    return `${Number(value)}`;
  } else {
    return `${value}`;
  }
}
function isExplicable(type) {
  const explicitTypes = ["string", "number", "boolean"];
  return explicitTypes.some((elem) => type.toLowerCase() === elem);
}
function isBoolean(...args) {
  return args.some((elem) => elem.toLowerCase() === "boolean");
}
var isInternalKey = (key) => key[0] === "_" || key === "$stable";
var normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
var normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (currentInstance && (!ctx || ctx.root === currentInstance.root)) {
      warn$1(
        `Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
      );
    }
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
var normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      if (true) {
        warn$1(
          `Non-function value encountered for slot "${key}". Prefer function slots for better performance.`
        );
      }
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
var normalizeVNodeSlots = (instance, children) => {
  if (!isKeepAlive(instance.vnode) && true) {
    warn$1(
      `Non-function value encountered for default slot. Prefer function slots for better performance.`
    );
  }
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
var assignSlots = (slots, children, optimized) => {
  for (const key in children) {
    if (optimized || key !== "_") {
      slots[key] = children[key];
    }
  }
};
var initSlots = (instance, children, optimized) => {
  const slots = instance.slots = createInternalObject();
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      assignSlots(slots, children, optimized);
      if (optimized) {
        def(slots, "_", type, true);
      }
    } else {
      normalizeObjectSlots(children, slots);
    }
  } else if (children) {
    normalizeVNodeSlots(instance, children);
  }
};
var updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (isHmrUpdating) {
        assignSlots(slots, children, optimized);
        trigger(instance, "set", "$slots");
      } else if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        assignSlots(slots, children, optimized);
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};
var supported;
var perf;
function startMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    perf.mark(`vue-${type}-${instance.uid}`);
  }
  if (true) {
    devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
  }
}
function endMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    const startTag = `vue-${type}-${instance.uid}`;
    const endTag = startTag + `:end`;
    perf.mark(endTag);
    perf.measure(
      `<${formatComponentName(instance, instance.type)}> ${type}`,
      startTag,
      endTag
    );
    perf.clearMarks(startTag);
    perf.clearMarks(endTag);
  }
  if (true) {
    devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
  }
}
function isSupported() {
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else {
    supported = false;
  }
  return supported;
}
function initFeatureFlags() {
  const needWarn = [];
  if (typeof __VUE_OPTIONS_API__ !== "boolean") {
    needWarn.push(`__VUE_OPTIONS_API__`);
    getGlobalThis().__VUE_OPTIONS_API__ = true;
  }
  if (typeof __VUE_PROD_DEVTOOLS__ !== "boolean") {
    needWarn.push(`__VUE_PROD_DEVTOOLS__`);
    getGlobalThis().__VUE_PROD_DEVTOOLS__ = false;
  }
  if (typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ !== "boolean") {
    needWarn.push(`__VUE_PROD_HYDRATION_MISMATCH_DETAILS__`);
    getGlobalThis().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = false;
  }
  if (needWarn.length) {
    const multi = needWarn.length > 1;
    console.warn(
      `Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
    );
  }
}
var queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  {
    initFeatureFlags();
  }
  const target = getGlobalThis();
  target.__VUE__ = true;
  if (true) {
    setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
  }
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n12, n22, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n22.dynamicChildren) => {
    if (n12 === n22) {
      return;
    }
    if (n12 && !isSameVNodeType(n12, n22)) {
      anchor = getNextHostNode(n12);
      unmount(n12, parentComponent, parentSuspense, true);
      n12 = null;
    }
    if (n22.patchFlag === -2) {
      optimized = false;
      n22.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n22;
    switch (type) {
      case Text:
        processText(n12, n22, container, anchor);
        break;
      case Comment:
        processCommentNode(n12, n22, container, anchor);
        break;
      case Static:
        if (n12 == null) {
          mountStaticNode(n22, container, anchor, namespace);
        } else if (true) {
          patchStaticNode(n12, n22, container, namespace);
        }
        break;
      case Fragment:
        processFragment(
          n12,
          n22,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n12,
            n22,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n12,
            n22,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n12,
            n22,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n12,
            n22,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (true) {
          warn$1("Invalid VNode type:", type, `(${typeof type})`);
        }
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n12 && n12.ref, parentSuspense, n22 || n12, !n22);
    }
  };
  const processText = (n12, n22, container, anchor) => {
    if (n12 == null) {
      hostInsert(
        n22.el = hostCreateText(n22.children),
        container,
        anchor
      );
    } else {
      const el2 = n22.el = n12.el;
      if (n22.children !== n12.children) {
        hostSetText(el2, n22.children);
      }
    }
  };
  const processCommentNode = (n12, n22, container, anchor) => {
    if (n12 == null) {
      hostInsert(
        n22.el = hostCreateComment(n22.children || ""),
        container,
        anchor
      );
    } else {
      n22.el = n12.el;
    }
  };
  const mountStaticNode = (n22, container, anchor, namespace) => {
    [n22.el, n22.anchor] = hostInsertStaticContent(
      n22.children,
      container,
      anchor,
      namespace,
      n22.el,
      n22.anchor
    );
  };
  const patchStaticNode = (n12, n22, container, namespace) => {
    if (n22.children !== n12.children) {
      const anchor = hostNextSibling(n12.anchor);
      removeStaticNode(n12);
      [n22.el, n22.anchor] = hostInsertStaticContent(
        n22.children,
        container,
        anchor,
        namespace
      );
    } else {
      n22.el = n12.el;
      n22.anchor = n12.anchor;
    }
  };
  const moveStaticNode = ({ el: el2, anchor }, container, nextSibling) => {
    let next;
    while (el2 && el2 !== anchor) {
      next = hostNextSibling(el2);
      hostInsert(el2, container, nextSibling);
      el2 = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el: el2, anchor }) => {
    let next;
    while (el2 && el2 !== anchor) {
      next = hostNextSibling(el2);
      hostRemove(el2);
      el2 = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n12, n22, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    if (n22.type === "svg") {
      namespace = "svg";
    } else if (n22.type === "math") {
      namespace = "mathml";
    }
    if (n12 == null) {
      mountElement(
        n22,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n12,
        n22,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let el2;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el2 = vnode.el = hostCreateElement(
      vnode.type,
      namespace,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el2, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el2,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el2, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el2, key, null, props[key], namespace, parentComponent);
        }
      }
      if ("value" in props) {
        hostPatchProp(el2, "value", null, props.value, namespace);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (true) {
      def(el2, "__vnode", vnode, true);
      def(el2, "__vueParentComponent", parentComponent, true);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el2);
    }
    hostInsert(el2, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el2);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el2, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el2, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el2, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
        subTree = filterSingleRoot(subTree.children) || subTree;
      }
      if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el2,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n12, n22, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const el2 = n22.el = n12.el;
    if (true) {
      el2.__vnode = n22;
    }
    let { patchFlag, dynamicChildren, dirs } = n22;
    patchFlag |= n12.patchFlag & 16;
    const oldProps = n12.props || EMPTY_OBJ;
    const newProps = n22.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n22, n12);
    }
    if (dirs) {
      invokeDirectiveHook(n22, n12, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (isHmrUpdating) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
      hostSetElementText(el2, "");
    }
    if (dynamicChildren) {
      patchBlockChildren(
        n12.dynamicChildren,
        dynamicChildren,
        el2,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n22, namespace),
        slotScopeIds
      );
      if (true) {
        traverseStaticChildren(n12, n22);
      }
    } else if (!optimized) {
      patchChildren(
        n12,
        n22,
        el2,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n22, namespace),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el2, oldProps, newProps, parentComponent, namespace);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el2, "class", null, newProps.class, namespace);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el2, "style", oldProps.style, newProps.style, namespace);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n22.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el2, key, prev, next, namespace, parentComponent);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n12.children !== n22.children) {
          hostSetElementText(el2, n22.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el2, oldProps, newProps, parentComponent, namespace);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n22, n12);
        dirs && invokeDirectiveHook(n22, n12, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el2, oldProps, newProps, parentComponent, namespace) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el2,
              key,
              oldProps[key],
              null,
              namespace,
              parentComponent
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el2, key, prev, next, namespace, parentComponent);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el2, "value", oldProps.value, newProps.value, namespace);
      }
    }
  };
  const processFragment = (n12, n22, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n22.el = n12 ? n12.el : hostCreateText("");
    const fragmentEndAnchor = n22.anchor = n12 ? n12.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n22;
    if (
      // #5523 dev root fragment may inherit directives
      isHmrUpdating || patchFlag & 2048
    ) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n12 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n22.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n12.dynamicChildren) {
        patchBlockChildren(
          n12.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        if (true) {
          traverseStaticChildren(n12, n22);
        } else if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n22.key != null || parentComponent && n22 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n12,
            n22,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n12,
          n22,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n12, n22, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    n22.slotScopeIds = slotScopeIds;
    if (n12 == null) {
      if (n22.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n22,
          container,
          anchor,
          namespace,
          optimized
        );
      } else {
        mountComponent(
          n22,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          optimized
        );
      }
    } else {
      updateComponent(n12, n22, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (instance.type.__hmrId) {
      registerHMR(instance);
    }
    if (true) {
      pushWarningContext(initialVNode);
      startMeasure(instance, `mount`);
    }
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      if (true) {
        startMeasure(instance, `init`);
      }
      setupComponent(instance, false, optimized);
      if (true) {
        endMeasure(instance, `init`);
      }
    }
    if (instance.asyncDep) {
      if (isHmrUpdating)
        initialVNode.el = null;
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
    } else {
      setupRenderEffect(
        instance,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace,
        optimized
      );
    }
    if (true) {
      popWarningContext();
      endMeasure(instance, `mount`);
    }
  };
  const updateComponent = (n12, n22, optimized) => {
    const instance = n22.component = n12.component;
    if (shouldUpdateComponent(n12, n22, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        if (true) {
          pushWarningContext(n22);
        }
        updateComponentPreRender(instance, n22, optimized);
        if (true) {
          popWarningContext();
        }
        return;
      } else {
        instance.next = n22;
        instance.update();
      }
    } else {
      n22.el = n12.el;
      instance.vnode = n22;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el: el2, props } = initialVNode;
        const { bm: bm2, m, parent, root, type } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm2) {
          invokeArrayFns(bm2);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el2 && hydrateNode) {
          const hydrateSubTree = () => {
            if (true) {
              startMeasure(instance, `render`);
            }
            instance.subTree = renderComponentRoot(instance);
            if (true) {
              endMeasure(instance, `render`);
            }
            if (true) {
              startMeasure(instance, `hydrate`);
            }
            hydrateNode(
              el2,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
            if (true) {
              endMeasure(instance, `hydrate`);
            }
          };
          if (isAsyncWrapperVNode && type.__asyncHydrate) {
            type.__asyncHydrate(
              el2,
              instance,
              hydrateSubTree
            );
          } else {
            hydrateSubTree();
          }
        } else {
          if (root.ce) {
            root.ce._injectChildStyle(type);
          }
          if (true) {
            startMeasure(instance, `render`);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          if (true) {
            endMeasure(instance, `render`);
          }
          if (true) {
            startMeasure(instance, `patch`);
          }
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            namespace
          );
          if (true) {
            endMeasure(instance, `patch`);
          }
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        if (true) {
          devtoolsComponentAdded(instance);
        }
        initialVNode = container = anchor = null;
      } else {
        let { next, bu: bu2, u, parent, vnode } = instance;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
          if (nonHydratedAsyncRoot) {
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next;
        let vnodeHook;
        if (true) {
          pushWarningContext(next || instance.vnode);
        }
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu2) {
          invokeArrayFns(bu2);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        if (true) {
          startMeasure(instance, `render`);
        }
        const nextTree = renderComponentRoot(instance);
        if (true) {
          endMeasure(instance, `render`);
        }
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        if (true) {
          startMeasure(instance, `patch`);
        }
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          namespace
        );
        if (true) {
          endMeasure(instance, `patch`);
        }
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
        if (true) {
          devtoolsComponentUpdated(instance);
        }
        if (true) {
          popWarningContext();
        }
      }
    };
    instance.scope.on();
    const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
    instance.scope.off();
    const update = instance.update = effect2.run.bind(effect2);
    const job = instance.job = effect2.runIfDirty.bind(effect2);
    job.i = instance;
    job.id = instance.uid;
    effect2.scheduler = () => queueJob(job);
    toggleRecurse(instance, true);
    if (true) {
      effect2.onTrack = instance.rtc ? (e) => invokeArrayFns(instance.rtc, e) : void 0;
      effect2.onTrigger = instance.rtg ? (e) => invokeArrayFns(instance.rtg, e) : void 0;
    }
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(instance);
    resetTracking();
  };
  const patchChildren = (n12, n22, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
    const c12 = n12 && n12.children;
    const prevShapeFlag = n12 ? n12.shapeFlag : 0;
    const c22 = n22.children;
    const { patchFlag, shapeFlag } = n22;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c12,
          c22,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c12,
          c22,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c12, parentComponent, parentSuspense);
      }
      if (c22 !== c12) {
        hostSetElementText(container, c22);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c12,
            c22,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c12, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c22,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c12, c22, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    c12 = c12 || EMPTY_ARR;
    c22 = c22 || EMPTY_ARR;
    const oldLength = c12.length;
    const newLength = c22.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c22[i] = optimized ? cloneIfMounted(c22[i]) : normalizeVNode(c22[i]);
      patch(
        c12[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c12,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c22,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c12, c22, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let i = 0;
    const l22 = c22.length;
    let e12 = c12.length - 1;
    let e22 = l22 - 1;
    while (i <= e12 && i <= e22) {
      const n12 = c12[i];
      const n22 = c22[i] = optimized ? cloneIfMounted(c22[i]) : normalizeVNode(c22[i]);
      if (isSameVNodeType(n12, n22)) {
        patch(
          n12,
          n22,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e12 && i <= e22) {
      const n12 = c12[e12];
      const n22 = c22[e22] = optimized ? cloneIfMounted(c22[e22]) : normalizeVNode(c22[e22]);
      if (isSameVNodeType(n12, n22)) {
        patch(
          n12,
          n22,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e12--;
      e22--;
    }
    if (i > e12) {
      if (i <= e22) {
        const nextPos = e22 + 1;
        const anchor = nextPos < l22 ? c22[nextPos].el : parentAnchor;
        while (i <= e22) {
          patch(
            null,
            c22[i] = optimized ? cloneIfMounted(c22[i]) : normalizeVNode(c22[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e22) {
      while (i <= e12) {
        unmount(c12[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s12 = i;
      const s22 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s22; i <= e22; i++) {
        const nextChild = c22[i] = optimized ? cloneIfMounted(c22[i]) : normalizeVNode(c22[i]);
        if (nextChild.key != null) {
          if (keyToNewIndexMap.has(nextChild.key)) {
            warn$1(
              `Duplicate keys found during update:`,
              JSON.stringify(nextChild.key),
              `Make sure keys are unique.`
            );
          }
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e22 - s22 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++)
        newIndexToOldIndexMap[i] = 0;
      for (i = s12; i <= e12; i++) {
        const prevChild = c12[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s22; j <= e22; j++) {
            if (newIndexToOldIndexMap[j - s22] === 0 && isSameVNodeType(prevChild, c22[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s22] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c22[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s22 + i;
        const nextChild = c22[nextIndex];
        const anchor = nextIndex + 1 < l22 ? c22[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el: el2, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el2, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el2);
        hostInsert(el2, container, anchor);
        queuePostRenderEffect(() => transition.enter(el2), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => hostInsert(el2, container, anchor);
        const performLeave = () => {
          leave(el2, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el2, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el2, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref: ref2,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs,
      cacheIndex
    } = vnode;
    if (patchFlag === -2) {
      optimized = false;
    }
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (cacheIndex != null) {
      parentComponent.renderCache[cacheIndex] = void 0;
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el: el2, anchor, transition } = vnode;
    if (type === Fragment) {
      if (vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {
        vnode.children.forEach((child) => {
          if (child.type === Comment) {
            hostRemove(child.el);
          } else {
            remove2(child);
          }
        });
      } else {
        removeFragment(el2, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el2);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el2, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    if (instance.type.__hmrId) {
      unregisterHMR(instance);
    }
    const { bum, scope, job, subTree, um: um2, m, a } = instance;
    invalidateMount(m);
    invalidateMount(a);
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (job) {
      job.flags |= 8;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um2) {
      queuePostRenderEffect(um2, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
    if (true) {
      devtoolsComponentRemoved(instance);
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    const el2 = hostNextSibling(vnode.anchor || vnode.el);
    const teleportEnd = el2 && el2[TeleportEndKey];
    return teleportEnd ? hostNextSibling(teleportEnd) : el2;
  };
  let isFlushing = false;
  const render = (vnode, container, namespace) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace
      );
    }
    container._vnode = vnode;
    if (!isFlushing) {
      isFlushing = true;
      flushPreFlushCbs();
      flushPostFlushCbs();
      isFlushing = false;
    }
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function resolveChildrenNamespace({ type, props }, currentNamespace) {
  return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect: effect2, job }, allowed) {
  if (allowed) {
    effect2.flags |= 32;
    job.flags |= 4;
  } else {
    effect2.flags &= ~32;
    job.flags &= ~4;
  }
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n12, n22, shallow = false) {
  const ch1 = n12.children;
  const ch2 = n22.children;
  if (isArray(ch1) && isArray(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c12 = ch1[i];
      let c22 = ch2[i];
      if (c22.shapeFlag & 1 && !c22.dynamicChildren) {
        if (c22.patchFlag <= 0 || c22.patchFlag === 32) {
          c22 = ch2[i] = cloneIfMounted(ch2[i]);
          c22.el = c12.el;
        }
        if (!shallow && c22.patchFlag !== -2)
          traverseStaticChildren(c12, c22);
      }
      if (c22.type === Text) {
        c22.el = c12.el;
      }
      if (c22.type === Comment && !c22.el) {
        c22.el = c12.el;
      }
    }
  }
}
function getSequence(arr) {
  const p5 = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p5[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p5[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p5[v];
  }
  return result;
}
function locateNonHydratedAsyncRoot(instance) {
  const subComponent = instance.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
function invalidateMount(hooks) {
  if (hooks) {
    for (let i = 0; i < hooks.length; i++)
      hooks[i].flags |= 8;
  }
}
var ssrContextKey = Symbol.for("v-scx");
var useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    if (!ctx) {
      warn$1(
        `Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`
      );
    }
    return ctx;
  }
};
function watch2(source, cb2, options) {
  if (!isFunction(cb2)) {
    warn$1(
      `\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`
    );
  }
  return doWatch(source, cb2, options);
}
function doWatch(source, cb2, options = EMPTY_OBJ) {
  const { immediate, deep, flush, once } = options;
  if (!cb2) {
    if (immediate !== void 0) {
      warn$1(
        `watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
    if (deep !== void 0) {
      warn$1(
        `watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
    if (once !== void 0) {
      warn$1(
        `watch() "once" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
  }
  const baseWatchOptions = extend({}, options);
  if (true)
    baseWatchOptions.onWarn = warn$1;
  const runsImmediately = cb2 && immediate || !cb2 && flush !== "post";
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else if (!runsImmediately) {
      const watchStopHandle = () => {
      };
      watchStopHandle.stop = NOOP;
      watchStopHandle.resume = NOOP;
      watchStopHandle.pause = NOOP;
      return watchStopHandle;
    }
  }
  const instance = currentInstance;
  baseWatchOptions.call = (fn2, type, args) => callWithAsyncErrorHandling(fn2, instance, type, args);
  let isPre = false;
  if (flush === "post") {
    baseWatchOptions.scheduler = (job) => {
      queuePostRenderEffect(job, instance && instance.suspense);
    };
  } else if (flush !== "sync") {
    isPre = true;
    baseWatchOptions.scheduler = (job, isFirstRun) => {
      if (isFirstRun) {
        job();
      } else {
        queueJob(job);
      }
    };
  }
  baseWatchOptions.augmentJob = (job) => {
    if (cb2) {
      job.flags |= 4;
    }
    if (isPre) {
      job.flags |= 2;
      if (instance) {
        job.id = instance.uid;
        job.i = instance;
      }
    }
  };
  const watchHandle = watch(source, cb2, baseWatchOptions);
  if (isInSSRComponentSetup) {
    if (ssrCleanup) {
      ssrCleanup.push(watchHandle);
    } else if (runsImmediately) {
      watchHandle();
    }
  }
  return watchHandle;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb2;
  if (isFunction(value)) {
    cb2 = value;
  } else {
    cb2 = value.handler;
    options = value;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb2.bind(publicThis), options);
  reset();
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
var getModelModifiers = (props, modelName) => {
  return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
};
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  if (true) {
    const {
      emitsOptions,
      propsOptions: [propsOptions]
    } = instance;
    if (emitsOptions) {
      if (!(event in emitsOptions) && true) {
        if (!propsOptions || !(toHandlerKey(camelize(event)) in propsOptions)) {
          warn$1(
            `Component emitted event "${event}" but it is neither declared in the emits option nor as an "${toHandlerKey(camelize(event))}" prop.`
          );
        }
      } else {
        const validator = emitsOptions[event];
        if (isFunction(validator)) {
          const isValid = validator(...rawArgs);
          if (!isValid) {
            warn$1(
              `Invalid event arguments: event validation failed for event "${event}".`
            );
          }
        }
      }
    }
  }
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
  if (modifiers) {
    if (modifiers.trim) {
      args = rawArgs.map((a) => isString(a) ? a.trim() : a);
    }
    if (modifiers.number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  if (true) {
    devtoolsComponentEmit(instance, event, args);
  }
  if (true) {
    const lowerCaseEvent = event.toLowerCase();
    if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
      warn$1(
        `Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(
          instance,
          instance.type
        )} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(
          event
        )}" instead of "${event}".`
      );
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (__VUE_OPTIONS_API__ && !isFunction(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
var accessedAttrs = false;
function markAttrsAccessed() {
  accessedAttrs = true;
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render,
    renderCache,
    props,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  const prev = setCurrentRenderingInstance(instance);
  let result;
  let fallthroughAttrs;
  if (true) {
    accessedAttrs = false;
  }
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy = setupState.__isScriptSetup ? new Proxy(proxyToUse, {
        get(target, key, receiver) {
          warn$1(
            `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          );
          return Reflect.get(target, key, receiver);
        }
      }) : proxyToUse;
      result = normalizeVNode(
        render.call(
          thisProxy,
          proxyToUse,
          renderCache,
          true ? shallowReadonly(props) : props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (attrs === props) {
        markAttrsAccessed();
      }
      result = normalizeVNode(
        render2.length > 1 ? render2(
          true ? shallowReadonly(props) : props,
          true ? {
            get attrs() {
              markAttrsAccessed();
              return shallowReadonly(attrs);
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }
        ) : render2(
          true ? shallowReadonly(props) : props,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  let setRoot = void 0;
  if (result.patchFlag > 0 && result.patchFlag & 2048) {
    [root, setRoot] = getChildRoot(result);
  }
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs, false, true);
      } else if (!accessedAttrs && root.type !== Comment) {
        const allAttrs = Object.keys(attrs);
        const eventAttrs = [];
        const extraAttrs = [];
        for (let i = 0, l = allAttrs.length; i < l; i++) {
          const key = allAttrs[i];
          if (isOn(key)) {
            if (!isModelListener(key)) {
              eventAttrs.push(key[2].toLowerCase() + key.slice(3));
            }
          } else {
            extraAttrs.push(key);
          }
        }
        if (extraAttrs.length) {
          warn$1(
            `Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`
          );
        }
        if (eventAttrs.length) {
          warn$1(
            `Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
          );
        }
      }
    }
  }
  if (vnode.dirs) {
    if (!isElementRoot(root)) {
      warn$1(
        `Runtime directive used on component with non-element root node. The directives will not function as intended.`
      );
    }
    root = cloneVNode(root, null, false, true);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    if (!isElementRoot(root)) {
      warn$1(
        `Component inside <Transition> renders non-element root node that cannot be animated.`
      );
    }
    setTransitionHooks(root, vnode.transition);
  }
  if (setRoot) {
    setRoot(root);
  } else {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
var getChildRoot = (vnode) => {
  const rawChildren = vnode.children;
  const dynamicChildren = vnode.dynamicChildren;
  const childRoot = filterSingleRoot(rawChildren, false);
  if (!childRoot) {
    return [vnode, void 0];
  } else if (childRoot.patchFlag > 0 && childRoot.patchFlag & 2048) {
    return getChildRoot(childRoot);
  }
  const index = rawChildren.indexOf(childRoot);
  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
  const setRoot = (updatedRoot) => {
    rawChildren[index] = updatedRoot;
    if (dynamicChildren) {
      if (dynamicIndex > -1) {
        dynamicChildren[dynamicIndex] = updatedRoot;
      } else if (updatedRoot.patchFlag > 0) {
        vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
      }
    }
  };
  return [normalizeVNode(childRoot), setRoot];
};
function filterSingleRoot(children, recurse = true) {
  let singleRoot;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (isVNode(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
          if (recurse && singleRoot.patchFlag > 0 && singleRoot.patchFlag & 2048) {
            return filterSingleRoot(singleRoot.children);
          }
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
var getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
var filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
var isElementRoot = (vnode) => {
  return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if ((prevChildren || nextChildren) && isHmrUpdating) {
    return true;
  }
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el2) {
  while (parent) {
    const root = parent.subTree;
    if (root.suspense && root.suspense.activeBranch === vnode) {
      root.el = vnode.el;
    }
    if (root === vnode) {
      (vnode = parent.vnode).el = el2;
      parent = parent.parent;
    } else {
      break;
    }
  }
}
var isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn2, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray(fn2)) {
      suspense.effects.push(...fn2);
    } else {
      suspense.effects.push(fn2);
    }
  } else {
    queuePostFlushCb(fn2);
  }
}
var Fragment = Symbol.for("v-fgt");
var Text = Symbol.for("v-txt");
var Comment = Symbol.for("v-cmt");
var Static = Symbol.for("v-stc");
var blockStack = [];
var currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
var isBlockTreeEnabled = 1;
function setBlockTracking(value, inVOnce = false) {
  isBlockTreeEnabled += value;
  if (value < 0 && currentBlock && inVOnce) {
    currentBlock.hasOnce = true;
  }
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n12, n22) {
  if (n22.shapeFlag & 6 && n12.component) {
    const dirtyInstances = hmrDirtyComponents.get(n22.type);
    if (dirtyInstances && dirtyInstances.has(n12.component)) {
      n12.shapeFlag &= ~256;
      n22.shapeFlag &= ~512;
      return false;
    }
  }
  return n12.type === n22.type && n12.key === n22.key;
}
var vnodeArgsTransformer;
var createVNodeWithArgsTransform = (...args) => {
  return _createVNode(
    ...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args
  );
};
var normalizeKey = ({ key }) => key != null ? key : null;
var normalizeRef = ({
  ref: ref2,
  ref_key,
  ref_for
}) => {
  if (typeof ref2 === "number") {
    ref2 = "" + ref2;
  }
  return ref2 != null ? isString(ref2) || isRef2(ref2) || isFunction(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString(children) ? 8 : 16;
  }
  if (vnode.key !== vnode.key) {
    warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
var createVNode = true ? createVNodeWithArgsTransform : _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    if (!type) {
      warn$1(`Invalid vnode type when creating vnode: ${type}.`);
    }
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject(style)) {
      if (isProxy(style) && !isArray(style)) {
        style = extend({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction(type) ? 2 : 0;
  if (shapeFlag & 4 && isProxy(type)) {
    type = toRaw(type);
    warn$1(
      `Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`,
      `
Component that was made reactive: `,
      type
    );
  }
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props, ref: ref2, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref2 ? isArray(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children: patchFlag === -1 && isArray(children) ? children.map(deepCloneVNode) : children,
    target: vnode.target,
    targetStart: vnode.targetStart,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
function deepCloneVNode(vnode) {
  const cloned = cloneVNode(vnode);
  if (isArray(vnode.children)) {
    cloned.children = vnode.children.map(deepCloneVNode);
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (isVNode(child)) {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !isInternalObject(children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
var emptyAppContext = createAppContext();
var uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    ids: parent ? parent.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  if (true) {
    instance.ctx = createDevRenderContext(instance);
  } else {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
var currentInstance = null;
var getCurrentInstance = () => currentInstance || currentRenderingInstance;
var internalSetCurrentInstance;
var setInSSRSetupState;
{
  const g = getGlobalThis();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g[key]))
      setters = g[key] = [];
    setters.push(setter);
    return (v) => {
      if (setters.length > 1)
        setters.forEach((set) => set(v));
      else
        setters[0](v);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v) => currentInstance = v
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v) => isInSSRComponentSetup = v
  );
}
var setCurrentInstance = (instance) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev);
  };
};
var unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
var isBuiltInTag = makeMap("slot,component");
function validateComponentName(name, { isNativeTag }) {
  if (isBuiltInTag(name) || isNativeTag(name)) {
    warn$1(
      "Do not use built-in or reserved HTML elements as component id: " + name
    );
  }
}
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
var isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false, optimized = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children, optimized);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  var _a2;
  const Component = instance.type;
  if (true) {
    if (Component.name) {
      validateComponentName(Component.name, instance.appContext.config);
    }
    if (Component.components) {
      const names = Object.keys(Component.components);
      for (let i = 0; i < names.length; i++) {
        validateComponentName(names[i], instance.appContext.config);
      }
    }
    if (Component.directives) {
      const names = Object.keys(Component.directives);
      for (let i = 0; i < names.length; i++) {
        validateDirectiveName(names[i]);
      }
    }
    if (Component.compilerOptions && isRuntimeOnly()) {
      warn$1(
        `"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`
      );
    }
  }
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
  if (true) {
    exposePropsOnRenderContext(instance);
  }
  const { setup } = Component;
  if (setup) {
    pauseTracking();
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [
        true ? shallowReadonly(instance.props) : instance.props,
        setupContext
      ]
    );
    const isAsyncSetup = isPromise(setupResult);
    resetTracking();
    reset();
    if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
      markAsyncBoundary(instance);
    }
    if (isAsyncSetup) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
        if (!instance.suspense) {
          const name = (_a2 = Component.name) != null ? _a2 : "Anonymous";
          warn$1(
            `Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
          );
        }
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject(setupResult)) {
    if (isVNode(setupResult)) {
      warn$1(
        `setup() should not return VNodes directly - return a render function instead.`
      );
    }
    if (true) {
      instance.devtoolsRawSetupState = setupResult;
    }
    instance.setupState = proxyRefs(setupResult);
    if (true) {
      exposeSetupStateOnRenderContext(instance);
    }
  } else if (setupResult !== void 0) {
    warn$1(
      `setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`
    );
  }
  finishComponentSetup(instance, isSSR);
}
var compile;
var installWithProxy;
var isRuntimeOnly = () => !compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template || __VUE_OPTIONS_API__ && resolveMergedOptions(instance).template;
      if (template) {
        if (true) {
          startMeasure(instance, `compile`);
        }
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend(
          extend(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile(template, finalCompilerOptions);
        if (true) {
          endMeasure(instance, `compile`);
        }
      }
    }
    instance.render = Component.render || NOOP;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  if (__VUE_OPTIONS_API__ && true) {
    const reset = setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions(instance);
    } finally {
      resetTracking();
      reset();
    }
  }
  if (!Component.render && instance.render === NOOP && !isSSR) {
    if (!compile && Component.template) {
      warn$1(
        `Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
      );
    } else {
      warn$1(`Component is missing template or render function: `, Component);
    }
  }
}
var attrsProxyHandlers = true ? {
  get(target, key) {
    markAttrsAccessed();
    track(target, "get", "");
    return target[key];
  },
  set() {
    warn$1(`setupContext.attrs is readonly.`);
    return false;
  },
  deleteProperty() {
    warn$1(`setupContext.attrs is readonly.`);
    return false;
  }
} : {
  get(target, key) {
    track(target, "get", "");
    return target[key];
  }
};
function getSlotsProxy(instance) {
  return new Proxy(instance.slots, {
    get(target, key) {
      track(instance, "get", "$slots");
      return target[key];
    }
  });
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    if (true) {
      if (instance.exposed) {
        warn$1(`expose() should be called only once per setup().`);
      }
      if (exposed != null) {
        let exposedType = typeof exposed;
        if (exposedType === "object") {
          if (isArray(exposed)) {
            exposedType = "array";
          } else if (isRef2(exposed)) {
            exposedType = "ref";
          }
        }
        if (exposedType !== "object") {
          warn$1(
            `expose() should be passed a plain object, received ${exposedType}.`
          );
        }
      }
    }
    instance.exposed = exposed || {};
  };
  if (true) {
    let attrsProxy;
    let slotsProxy;
    return Object.freeze({
      get attrs() {
        return attrsProxy || (attrsProxy = new Proxy(instance.attrs, attrsProxyHandlers));
      },
      get slots() {
        return slotsProxy || (slotsProxy = getSlotsProxy(instance));
      },
      get emit() {
        return (event, ...args) => instance.emit(event, ...args);
      },
      expose
    });
  } else {
    return {
      attrs: new Proxy(instance.attrs, attrsProxyHandlers),
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getComponentPublicInstance(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  } else {
    return instance.proxy;
  }
}
var classifyRE = /(?:^|[-_])(\w)/g;
var classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction(value) && "__vccOpts" in value;
}
var computed2 = (getterOrOptions, debugOptions) => {
  const c = computed(getterOrOptions, debugOptions, isInSSRComponentSetup);
  if (true) {
    const i = getCurrentInstance();
    if (i && i.appContext.config.warnRecursiveComputed) {
      c._warnRecursive = true;
    }
  }
  return c;
};
function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
function initCustomFormatter() {
  if (typeof window === "undefined") {
    return;
  }
  const vueStyle = { style: "color:#3ba776" };
  const numberStyle = { style: "color:#1677ff" };
  const stringStyle = { style: "color:#f5222d" };
  const keywordStyle = { style: "color:#eb2f96" };
  const formatter = {
    __vue_custom_formatter: true,
    header(obj) {
      if (!isObject(obj)) {
        return null;
      }
      if (obj.__isVue) {
        return ["div", vueStyle, `VueInstance`];
      } else if (isRef2(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, genRefFlag(obj)],
          "<",
          // avoid debugger accessing value affecting behavior
          formatValue("_value" in obj ? obj._value : obj),
          `>`
        ];
      } else if (isReactive(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"],
          "<",
          formatValue(obj),
          `>${isReadonly(obj) ? ` (readonly)` : ``}`
        ];
      } else if (isReadonly(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"],
          "<",
          formatValue(obj),
          ">"
        ];
      }
      return null;
    },
    hasBody(obj) {
      return obj && obj.__isVue;
    },
    body(obj) {
      if (obj && obj.__isVue) {
        return [
          "div",
          {},
          ...formatInstance(obj.$)
        ];
      }
    }
  };
  function formatInstance(instance) {
    const blocks = [];
    if (instance.type.props && instance.props) {
      blocks.push(createInstanceBlock("props", toRaw(instance.props)));
    }
    if (instance.setupState !== EMPTY_OBJ) {
      blocks.push(createInstanceBlock("setup", instance.setupState));
    }
    if (instance.data !== EMPTY_OBJ) {
      blocks.push(createInstanceBlock("data", toRaw(instance.data)));
    }
    const computed3 = extractKeys(instance, "computed");
    if (computed3) {
      blocks.push(createInstanceBlock("computed", computed3));
    }
    const injected = extractKeys(instance, "inject");
    if (injected) {
      blocks.push(createInstanceBlock("injected", injected));
    }
    blocks.push([
      "div",
      {},
      [
        "span",
        {
          style: keywordStyle.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: instance }]
    ]);
    return blocks;
  }
  function createInstanceBlock(type, target) {
    target = extend({}, target);
    if (!Object.keys(target).length) {
      return ["span", {}];
    }
    return [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        type
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(target).map((key) => {
          return [
            "div",
            {},
            ["span", keywordStyle, key + ": "],
            formatValue(target[key], false)
          ];
        })
      ]
    ];
  }
  function formatValue(v, asRaw = true) {
    if (typeof v === "number") {
      return ["span", numberStyle, v];
    } else if (typeof v === "string") {
      return ["span", stringStyle, JSON.stringify(v)];
    } else if (typeof v === "boolean") {
      return ["span", keywordStyle, v];
    } else if (isObject(v)) {
      return ["object", { object: asRaw ? toRaw(v) : v }];
    } else {
      return ["span", stringStyle, String(v)];
    }
  }
  function extractKeys(instance, type) {
    const Comp = instance.type;
    if (isFunction(Comp)) {
      return;
    }
    const extracted = {};
    for (const key in instance.ctx) {
      if (isKeyOfType(Comp, key, type)) {
        extracted[key] = instance.ctx[key];
      }
    }
    return extracted;
  }
  function isKeyOfType(Comp, key, type) {
    const opts = Comp[type];
    if (isArray(opts) && opts.includes(key) || isObject(opts) && key in opts) {
      return true;
    }
    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
      return true;
    }
    if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type))) {
      return true;
    }
  }
  function genRefFlag(v) {
    if (isShallow(v)) {
      return `ShallowRef`;
    }
    if (v.effect) {
      return `ComputedRef`;
    }
    return `Ref`;
  }
  if (window.devtoolsFormatters) {
    window.devtoolsFormatters.push(formatter);
  } else {
    window.devtoolsFormatters = [formatter];
  }
}
var version = "3.5.13";
var warn2 = true ? warn$1 : NOOP;

// node_modules/.pnpm/@vue+runtime-dom@3.5.13/node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js
var policy = void 0;
var tt = typeof window !== "undefined" && window.trustedTypes;
if (tt) {
  try {
    policy = tt.createPolicy("vue", {
      createHTML: (val) => val
    });
  } catch (e) {
    warn2(`Error creating trusted types policy: ${e}`);
  }
}
var unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
var svgNS = "http://www.w3.org/2000/svg";
var mathmlNS = "http://www.w3.org/1998/Math/MathML";
var doc = typeof document !== "undefined" ? document : null;
var templateContainer = doc && doc.createElement("template");
var nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, namespace, is2, props) => {
    const el2 = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is2 ? doc.createElement(tag, { is: is2 }) : doc.createElement(tag);
    if (tag === "select" && props && props.multiple != null) {
      el2.setAttribute("multiple", props.multiple);
    }
    return el2;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el2, text) => {
    el2.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el2, id2) {
    el2.setAttribute(id2, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, namespace, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = unsafeToTrustedHTML(
        namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
      );
      const template = templateContainer.content;
      if (namespace === "svg" || namespace === "mathml") {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
var TRANSITION = "transition";
var ANIMATION = "animation";
var vtcKey = Symbol("_vtc");
var DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
var TransitionPropsValidators = extend(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
var decorate$1 = (t) => {
  t.displayName = "Transition";
  t.props = TransitionPropsValidators;
  return t;
};
var Transition = decorate$1(
  (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots)
);
var callHook2 = (hook, args = []) => {
  if (isArray(hook)) {
    hook.forEach((h22) => h22(...args));
  } else if (hook) {
    hook(...args);
  }
};
var hasExplicitCallback = (hook) => {
  return hook ? isArray(hook) ? hook.some((h22) => h22.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el2, isAppear, done, isCancelled) => {
    el2._enterCancelled = isCancelled;
    removeTransitionClass(el2, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el2, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el2, done) => {
    el2._isLeaving = false;
    removeTransitionClass(el2, leaveFromClass);
    removeTransitionClass(el2, leaveToClass);
    removeTransitionClass(el2, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el2, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el2, isAppear, done);
      callHook2(hook, [el2, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el2, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el2, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el2, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend(baseProps, {
    onBeforeEnter(el2) {
      callHook2(onBeforeEnter, [el2]);
      addTransitionClass(el2, enterFromClass);
      addTransitionClass(el2, enterActiveClass);
    },
    onBeforeAppear(el2) {
      callHook2(onBeforeAppear, [el2]);
      addTransitionClass(el2, appearFromClass);
      addTransitionClass(el2, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el2, done) {
      el2._isLeaving = true;
      const resolve2 = () => finishLeave(el2, done);
      addTransitionClass(el2, leaveFromClass);
      if (!el2._enterCancelled) {
        forceReflow();
        addTransitionClass(el2, leaveActiveClass);
      } else {
        addTransitionClass(el2, leaveActiveClass);
        forceReflow();
      }
      nextFrame(() => {
        if (!el2._isLeaving) {
          return;
        }
        removeTransitionClass(el2, leaveFromClass);
        addTransitionClass(el2, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el2, type, leaveDuration, resolve2);
        }
      });
      callHook2(onLeave, [el2, resolve2]);
    },
    onEnterCancelled(el2) {
      finishEnter(el2, false, void 0, true);
      callHook2(onEnterCancelled, [el2]);
    },
    onAppearCancelled(el2) {
      finishEnter(el2, true, void 0, true);
      callHook2(onAppearCancelled, [el2]);
    },
    onLeaveCancelled(el2) {
      finishLeave(el2);
      callHook2(onLeaveCancelled, [el2]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  if (true) {
    assertNumber(res, "<transition> explicit duration");
  }
  return res;
}
function addTransitionClass(el2, cls) {
  cls.split(/\s+/).forEach((c) => c && el2.classList.add(c));
  (el2[vtcKey] || (el2[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el2, cls) {
  cls.split(/\s+/).forEach((c) => c && el2.classList.remove(c));
  const _vtc = el2[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el2[vtcKey] = void 0;
    }
  }
}
function nextFrame(cb2) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb2);
  });
}
var endId = 0;
function whenTransitionEnds(el2, expectedType, explicitTimeout, resolve2) {
  const id2 = el2._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id2 === el2._endId) {
      resolve2();
    }
  };
  if (explicitTimeout != null) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el2, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el2.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el2 && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el2.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el2, expectedType) {
  const styles = window.getComputedStyle(el2);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  if (s === "auto")
    return 0;
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
function patchClass(el2, value, isSVG) {
  const transitionClasses = el2[vtcKey];
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el2.removeAttribute("class");
  } else if (isSVG) {
    el2.setAttribute("class", value);
  } else {
    el2.className = value;
  }
}
var vShowOriginalDisplay = Symbol("_vod");
var vShowHidden = Symbol("_vsh");
var vShow = {
  beforeMount(el2, { value }, { transition }) {
    el2[vShowOriginalDisplay] = el2.style.display === "none" ? "" : el2.style.display;
    if (transition && value) {
      transition.beforeEnter(el2);
    } else {
      setDisplay(el2, value);
    }
  },
  mounted(el2, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el2);
    }
  },
  updated(el2, { value, oldValue }, { transition }) {
    if (!value === !oldValue)
      return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el2);
        setDisplay(el2, true);
        transition.enter(el2);
      } else {
        transition.leave(el2, () => {
          setDisplay(el2, false);
        });
      }
    } else {
      setDisplay(el2, value);
    }
  },
  beforeUnmount(el2, { value }) {
    setDisplay(el2, value);
  }
};
if (true) {
  vShow.name = "show";
}
function setDisplay(el2, value) {
  el2.style.display = value ? el2[vShowOriginalDisplay] : "none";
  el2[vShowHidden] = !value;
}
var CSS_VAR_TEXT = Symbol(true ? "CSS_VAR_TEXT" : "");
var displayRE = /(^|;)\s*display\s*:/;
function patchStyle(el2, prev, next) {
  const style = el2.style;
  const isCssString = isString(next);
  let hasControlledDisplay = false;
  if (next && !isCssString) {
    if (prev) {
      if (!isString(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      } else {
        for (const prevStyle of prev.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
    }
    for (const key in next) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style, key, next[key]);
    }
  } else {
    if (isCssString) {
      if (prev !== next) {
        const cssVarText = style[CSS_VAR_TEXT];
        if (cssVarText) {
          next += ";" + cssVarText;
        }
        style.cssText = next;
        hasControlledDisplay = displayRE.test(next);
      }
    } else if (prev) {
      el2.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el2) {
    el2[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
    if (el2[vShowHidden]) {
      style.display = "none";
    }
  }
}
var semicolonRE = /[^\\];\s*$/;
var importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray(val)) {
    val.forEach((v) => setStyle(style, name, v));
  } else {
    if (val == null)
      val = "";
    if (true) {
      if (semicolonRE.test(val)) {
        warn2(
          `Unexpected semicolon at the end of '${name}' style value: '${val}'`
        );
      }
    }
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
var prefixes = ["Webkit", "Moz", "ms"];
var prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
var xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el2, key, value, isSVG, instance, isBoolean2 = isSpecialBooleanAttr(key)) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el2.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el2.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
      el2.removeAttribute(key);
    } else {
      el2.setAttribute(
        key,
        isBoolean2 ? "" : isSymbol(value) ? String(value) : value
      );
    }
  }
}
function patchDOMProp(el2, key, value, parentComponent, attrName) {
  if (key === "innerHTML" || key === "textContent") {
    if (value != null) {
      el2[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
    }
    return;
  }
  const tag = el2.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    const oldValue = tag === "OPTION" ? el2.getAttribute("value") || "" : el2.value;
    const newValue = value == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      el2.type === "checkbox" ? "on" : ""
    ) : String(value);
    if (oldValue !== newValue || !("_value" in el2)) {
      el2.value = newValue;
    }
    if (value == null) {
      el2.removeAttribute(key);
    }
    el2._value = value;
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el2[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el2[key] = value;
  } catch (e) {
    if (!needRemove) {
      warn2(
        `Failed setting prop "${key}" on <${tag.toLowerCase()}>: value ${value} is invalid.`,
        e
      );
    }
  }
  needRemove && el2.removeAttribute(attrName || key);
}
function addEventListener(el2, event, handler, options) {
  el2.addEventListener(event, handler, options);
}
function removeEventListener(el2, event, handler, options) {
  el2.removeEventListener(event, handler, options);
}
var veiKey = Symbol("_vei");
function patchEvent(el2, rawName, prevValue, nextValue, instance = null) {
  const invokers = el2[veiKey] || (el2[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = true ? sanitizeEventValue(nextValue, rawName) : nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(
        true ? sanitizeEventValue(nextValue, rawName) : nextValue,
        instance
      );
      addEventListener(el2, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el2, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
var optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
var cachedNow = 0;
var p = Promise.resolve();
var getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function sanitizeEventValue(value, propName) {
  if (isFunction(value) || isArray(value)) {
    return value;
  }
  warn2(
    `Wrong type passed as event handler to ${propName} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof value}.`
  );
  return NOOP;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map(
      (fn2) => (e22) => !e22._stopped && fn2 && fn2(e22)
    );
  } else {
    return value;
  }
}
var isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
var patchProp = (el2, key, prevValue, nextValue, namespace, parentComponent) => {
  const isSVG = namespace === "svg";
  if (key === "class") {
    patchClass(el2, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el2, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el2, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el2, key, nextValue, isSVG)) {
    patchDOMProp(el2, key, nextValue);
    if (!el2.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
      patchAttr(el2, key, nextValue, isSVG, parentComponent, key !== "value");
    }
  } else if (
    // #11081 force set props for possible async custom element
    el2._isVueCE && (/[A-Z]/.test(key) || !isString(nextValue))
  ) {
    patchDOMProp(el2, camelize(key), nextValue, parentComponent, key);
  } else {
    if (key === "true-value") {
      el2._trueValue = nextValue;
    } else if (key === "false-value") {
      el2._falseValue = nextValue;
    }
    patchAttr(el2, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el2, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el2 && isNativeOn(key) && isFunction(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el2.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el2.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag = el2.tagName;
    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && isString(value)) {
    return false;
  }
  return key in el2;
}
var positionMap = /* @__PURE__ */ new WeakMap();
var newPositionMap = /* @__PURE__ */ new WeakMap();
var moveCbKey = Symbol("_moveCb");
var enterCbKey2 = Symbol("_enterCb");
var decorate = (t) => {
  delete t.props.mode;
  return t;
};
var TransitionGroupImpl = decorate({
  name: "TransitionGroup",
  props: extend({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(
        prevChildren[0].el,
        instance.vnode.el,
        moveClass
      )) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c) => {
        const el2 = c.el;
        const style = el2.style;
        addTransitionClass(el2, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb2 = el2[moveCbKey] = (e) => {
          if (e && e.target !== el2) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el2.removeEventListener("transitionend", cb2);
            el2[moveCbKey] = null;
            removeTransitionClass(el2, moveClass);
          }
        };
        el2.addEventListener("transitionend", cb2);
      });
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = [];
      if (children) {
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child.el && child.el instanceof Element) {
            prevChildren.push(child);
            setTransitionHooks(
              child,
              resolveTransitionHooks(
                child,
                cssTransitionProps,
                state,
                instance
              )
            );
            positionMap.set(
              child,
              child.el.getBoundingClientRect()
            );
          }
        }
      }
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
        } else if (child.type !== Text) {
          warn2(`<TransitionGroup> children must be keyed.`);
        }
      }
      return createVNode(tag, null, children);
    };
  }
});
function callPendingCbs(c) {
  const el2 = c.el;
  if (el2[moveCbKey]) {
    el2[moveCbKey]();
  }
  if (el2[enterCbKey2]) {
    el2[enterCbKey2]();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx2 = oldPos.left - newPos.left;
  const dy2 = oldPos.top - newPos.top;
  if (dx2 || dy2) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx2}px,${dy2}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el2, root, moveClass) {
  const clone = el2.cloneNode();
  const _vtc = el2[vtcKey];
  if (_vtc) {
    _vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c));
  clone.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);
  const { hasTransform } = getTransitionInfo(clone);
  container.removeChild(clone);
  return hasTransform;
}
var getModelAssigner = (vnode) => {
  const fn2 = vnode.props["onUpdate:modelValue"] || false;
  return isArray(fn2) ? (value) => invokeArrayFns(fn2, value) : fn2;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
var assignKey = Symbol("_assign");
var vModelText = {
  created(el2, { modifiers: { lazy, trim, number } }, vnode) {
    el2[assignKey] = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener(el2, lazy ? "change" : "input", (e) => {
      if (e.target.composing)
        return;
      let domValue = el2.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = looseToNumber(domValue);
      }
      el2[assignKey](domValue);
    });
    if (trim) {
      addEventListener(el2, "change", () => {
        el2.value = el2.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el2, "compositionstart", onCompositionStart);
      addEventListener(el2, "compositionend", onCompositionEnd);
      addEventListener(el2, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el2, { value }) {
    el2.value = value == null ? "" : value;
  },
  beforeUpdate(el2, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
    el2[assignKey] = getModelAssigner(vnode);
    if (el2.composing)
      return;
    const elValue = (number || el2.type === "number") && !/^0\d/.test(el2.value) ? looseToNumber(el2.value) : el2.value;
    const newValue = value == null ? "" : value;
    if (elValue === newValue) {
      return;
    }
    if (document.activeElement === el2 && el2.type !== "range") {
      if (lazy && value === oldValue) {
        return;
      }
      if (trim && el2.value.trim() === newValue) {
        return;
      }
    }
    el2.value = newValue;
  }
};
var systemModifiers = ["ctrl", "shift", "alt", "meta"];
var modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
};
var withModifiers = (fn2, modifiers) => {
  const cache = fn2._withMods || (fn2._withMods = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers))
        return;
    }
    return fn2(event, ...args);
  });
};
var keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
var withKeys = (fn2, modifiers) => {
  const cache = fn2._withKeys || (fn2._withKeys = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some(
      (k) => k === eventKey || keyNames[k] === eventKey
    )) {
      return fn2(event);
    }
  });
};
var rendererOptions = extend({ patchProp }, nodeOps);
var renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
var createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  if (true) {
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
  }
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app._component;
    if (!isFunction(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    if (container.nodeType === 1) {
      container.textContent = "";
    }
    const proxy = mount(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
function injectNativeTagCheck(app) {
  Object.defineProperty(app.config, "isNativeTag", {
    value: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
    writable: false
  });
}
function injectCompilerOptionsCheck(app) {
  if (isRuntimeOnly()) {
    const isCustomElement = app.config.isCustomElement;
    Object.defineProperty(app.config, "isCustomElement", {
      get() {
        return isCustomElement;
      },
      set() {
        warn2(
          `The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`
        );
      }
    });
    const compilerOptions = app.config.compilerOptions;
    const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
    Object.defineProperty(app.config, "compilerOptions", {
      get() {
        warn2(msg);
        return compilerOptions;
      },
      set() {
        warn2(msg);
      }
    });
  }
}
function normalizeContainer(container) {
  if (isString(container)) {
    const res = document.querySelector(container);
    if (!res) {
      warn2(
        `Failed to mount app: mount target selector "${container}" returned null.`
      );
    }
    return res;
  }
  if (window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
    warn2(
      `mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`
    );
  }
  return container;
}

// node_modules/.pnpm/vue@3.5.13/node_modules/vue/dist/vue.runtime.esm-bundler.js
function initDev() {
  {
    initCustomFormatter();
  }
}
if (true) {
  initDev();
}

// node_modules/.pnpm/@n8n+chat@0.27.1/node_modules/@n8n/chat/dist/chat.es.js
var Fe = {
  webhookUrl: "http://localhost:5678",
  webhookConfig: {
    method: "POST",
    headers: {}
  },
  target: "#n8n-chat",
  mode: "window",
  loadPreviousSession: true,
  chatInputKey: "chatInput",
  chatSessionKey: "sessionId",
  defaultLanguage: "en",
  showWelcomeScreen: false,
  initialMessages: ["Hi there! 👋", "My name is Nathan. How can I assist you today?"],
  i18n: {
    en: {
      title: "Hi there! 👋",
      subtitle: "Start a chat. We're here to help you 24/7.",
      footer: "",
      getStarted: "New Conversation",
      inputPlaceholder: "Type your question..",
      closeButtonTooltip: "Close chat"
    }
  },
  theme: {}
};
var Mo = "#n8n-chat";
var Io = "n8n-chat";
var ht = `${Io}/sessionId`;
var fr = "Chat";
var pr = "ChatOptions";
var X = [];
for (wn = 0; wn < 256; ++wn)
  X.push((wn + 256).toString(16).slice(1));
var wn;
function Oo(n, e = 0) {
  return (X[n[e + 0]] + X[n[e + 1]] + X[n[e + 2]] + X[n[e + 3]] + "-" + X[n[e + 4]] + X[n[e + 5]] + "-" + X[n[e + 6]] + X[n[e + 7]] + "-" + X[n[e + 8]] + X[n[e + 9]] + "-" + X[n[e + 10]] + X[n[e + 11]] + X[n[e + 12]] + X[n[e + 13]] + X[n[e + 14]] + X[n[e + 15]]).toLowerCase();
}
var Je;
var Fo = new Uint8Array(16);
function Bo() {
  if (!Je && (Je = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Je))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Je(Fo);
}
var Po = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var dt = {
  randomUUID: Po
};
function Be(n, e, t) {
  if (dt.randomUUID && !e && !n)
    return dt.randomUUID();
  n = n || {};
  var r = n.random || (n.rng || Bo)();
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, Oo(r);
}
async function $o() {
  return "";
}
async function Vn(...n) {
  var s, i;
  const e = await $o(), t = (s = n[1]) == null ? void 0 : s.body, r = {
    ...e ? { authorization: `Bearer ${e}` } : {},
    ...(i = n[1]) == null ? void 0 : i.headers
  };
  return t instanceof FormData ? delete r["Content-Type"] : r["Content-Type"] = "application/json", await (await fetch(n[0], {
    ...n[1],
    mode: "cors",
    cache: "no-cache",
    headers: r
  })).json();
}
async function hr(n, e = {}, t = {}) {
  let r = n;
  return Object.keys(e).length > 0 && (r = `${r}?${new URLSearchParams(
    e
  ).toString()}`), await Vn(r, { ...t, method: "GET" });
}
async function dr(n, e = {}, t = {}) {
  return await Vn(n, {
    ...t,
    method: "POST",
    body: JSON.stringify(e)
  });
}
async function zo(n, e = {}, t = [], r = {}) {
  const o = new FormData();
  for (const s in e)
    o.append(s, e[s]);
  for (const s of t)
    o.append("files", s);
  return await Vn(n, {
    ...r,
    method: "POST",
    body: o
  });
}
async function Uo(n, e) {
  var r, o;
  return await (((r = e.webhookConfig) == null ? void 0 : r.method) === "POST" ? dr : hr)(
    `${e.webhookUrl}`,
    {
      action: "loadPreviousSession",
      [e.chatSessionKey]: n,
      ...e.metadata ? { metadata: e.metadata } : {}
    },
    {
      headers: (o = e.webhookConfig) == null ? void 0 : o.headers
    }
  );
}
async function Ho(n, e, t, r) {
  var s, i, c;
  return e.length > 0 ? await zo(
    `${r.webhookUrl}`,
    {
      action: "sendMessage",
      [r.chatSessionKey]: t,
      [r.chatInputKey]: n,
      ...r.metadata ? { metadata: r.metadata } : {}
    },
    e,
    {
      headers: (s = r.webhookConfig) == null ? void 0 : s.headers
    }
  ) : await (((i = r.webhookConfig) == null ? void 0 : i.method) === "POST" ? dr : hr)(
    `${r.webhookUrl}`,
    {
      action: "sendMessage",
      [r.chatSessionKey]: t,
      [r.chatInputKey]: n,
      ...r.metadata ? { metadata: r.metadata } : {}
    },
    {
      headers: (c = r.webhookConfig) == null ? void 0 : c.headers
    }
  );
}
function Vo() {
  const n = /* @__PURE__ */ new Map();
  function e(o, s) {
    const i = n.get(o);
    i && i.splice(i.indexOf(s) >>> 0, 1);
  }
  function t(o, s) {
    let i = n.get(o);
    return i ? i.push(s) : i = [s], n.set(o, i), () => e(o, s);
  }
  function r(o, s) {
    const i = n.get(o);
    i && i.slice().forEach(async (c) => {
      await c(s);
    });
  }
  return {
    on: t,
    off: e,
    emit: r
  };
}
function Go(n) {
  if (!document.querySelector(n)) {
    const t = document.createElement("div");
    n.startsWith("#") && (t.id = n.replace("#", "")), n.startsWith(".") && t.classList.add(n.replace(".", "")), document.body.appendChild(t);
  }
}
var re = Vo();
var jo = {
  install(n, e) {
    n.provide(pr, e);
    const t = ref([]), r = ref(null), o = ref(false), s = computed2(
      () => (e.initialMessages ?? []).map((u) => ({
        id: Be(),
        text: u,
        sender: "bot",
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
      }))
    );
    async function i(u, p5 = []) {
      const f = {
        id: Be(),
        text: u,
        sender: "user",
        files: p5,
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      t.value.push(f), o.value = true, nextTick(() => {
        re.emit("scrollToBottom");
      });
      const h5 = await Ho(
        u,
        p5,
        r.value,
        e
      );
      let d = h5.output ?? h5.text ?? "";
      if (d === "" && Object.keys(h5).length > 0)
        try {
          d = JSON.stringify(h5, null, 2);
        } catch {
        }
      const g = {
        id: Be(),
        text: d,
        sender: "bot",
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      t.value.push(g), o.value = false, nextTick(() => {
        re.emit("scrollToBottom");
      });
    }
    async function c() {
      if (!e.loadPreviousSession)
        return;
      const u = localStorage.getItem(ht) ?? Be(), p5 = await Uo(u, e), f = (/* @__PURE__ */ new Date()).toISOString();
      return t.value = ((p5 == null ? void 0 : p5.data) || []).map((h5, d) => ({
        id: `${d}`,
        text: h5.kwargs.content,
        sender: h5.id.includes("HumanMessage") ? "user" : "bot",
        createdAt: f
      })), t.value.length && (r.value = u), u;
    }
    async function a() {
      r.value = Be(), localStorage.setItem(ht, r.value);
    }
    const l = {
      initialMessages: s,
      messages: t,
      currentSessionId: r,
      waitingForResponse: o,
      loadPreviousSession: c,
      startNewSession: a,
      sendMessage: i
    };
    n.provide(fr, l), n.config.globalProperties.$chat = l;
  }
};
function Gn(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function Zo(n) {
  if (n.__esModule)
    return n;
  var e = n.default;
  if (typeof e == "function") {
    var t = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: true }), Object.keys(n).forEach(function(r) {
    var o = Object.getOwnPropertyDescriptor(n, r);
    Object.defineProperty(t, r, o.get ? o : {
      enumerable: true,
      get: function() {
        return n[r];
      }
    });
  }), t;
}
function gr(n) {
  return n instanceof Map ? n.clear = n.delete = n.set = function() {
    throw new Error("map is read-only");
  } : n instanceof Set && (n.add = n.clear = n.delete = function() {
    throw new Error("set is read-only");
  }), Object.freeze(n), Object.getOwnPropertyNames(n).forEach((e) => {
    const t = n[e], r = typeof t;
    (r === "object" || r === "function") && !Object.isFrozen(t) && gr(t);
  }), n;
}
var gt = class {
  /**
   * @param {CompiledMode} mode
   */
  constructor(e) {
    e.data === void 0 && (e.data = {}), this.data = e.data, this.isMatchIgnored = false;
  }
  ignoreMatch() {
    this.isMatchIgnored = true;
  }
};
function mr(n) {
  return n.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function ke(n, ...e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const r in n)
    t[r] = n[r];
  return e.forEach(function(r) {
    for (const o in r)
      t[o] = r[o];
  }), /** @type {T} */
  t;
}
var Ko = "</span>";
var mt = (n) => !!n.scope;
var Wo = (n, { prefix: e }) => {
  if (n.startsWith("language:"))
    return n.replace("language:", "language-");
  if (n.includes(".")) {
    const t = n.split(".");
    return [
      `${e}${t.shift()}`,
      ...t.map((r, o) => `${r}${"_".repeat(o + 1)}`)
    ].join(" ");
  }
  return `${e}${n}`;
};
var Yo = class {
  /**
   * Creates a new HTMLRenderer
   *
   * @param {Tree} parseTree - the parse tree (must support `walk` API)
   * @param {{classPrefix: string}} options
   */
  constructor(e, t) {
    this.buffer = "", this.classPrefix = t.classPrefix, e.walk(this);
  }
  /**
   * Adds texts to the output stream
   *
   * @param {string} text */
  addText(e) {
    this.buffer += mr(e);
  }
  /**
   * Adds a node open to the output stream (if needed)
   *
   * @param {Node} node */
  openNode(e) {
    if (!mt(e))
      return;
    const t = Wo(
      e.scope,
      { prefix: this.classPrefix }
    );
    this.span(t);
  }
  /**
   * Adds a node close to the output stream (if needed)
   *
   * @param {Node} node */
  closeNode(e) {
    mt(e) && (this.buffer += Ko);
  }
  /**
   * returns the accumulated buffer
  */
  value() {
    return this.buffer;
  }
  // helpers
  /**
   * Builds a span element
   *
   * @param {string} className */
  span(e) {
    this.buffer += `<span class="${e}">`;
  }
};
var _t = (n = {}) => {
  const e = { children: [] };
  return Object.assign(e, n), e;
};
var jn = class _jn {
  constructor() {
    this.rootNode = _t(), this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  /** @param {Node} node */
  add(e) {
    this.top.children.push(e);
  }
  /** @param {string} scope */
  openNode(e) {
    const t = _t({ scope: e });
    this.add(t), this.stack.push(t);
  }
  closeNode() {
    if (this.stack.length > 1)
      return this.stack.pop();
  }
  closeAllNodes() {
    for (; this.closeNode(); )
      ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  /**
   * @typedef { import("./html_renderer").Renderer } Renderer
   * @param {Renderer} builder
   */
  walk(e) {
    return this.constructor._walk(e, this.rootNode);
  }
  /**
   * @param {Renderer} builder
   * @param {Node} node
   */
  static _walk(e, t) {
    return typeof t == "string" ? e.addText(t) : t.children && (e.openNode(t), t.children.forEach((r) => this._walk(e, r)), e.closeNode(t)), e;
  }
  /**
   * @param {Node} node
   */
  static _collapse(e) {
    typeof e != "string" && e.children && (e.children.every((t) => typeof t == "string") ? e.children = [e.children.join("")] : e.children.forEach((t) => {
      _jn._collapse(t);
    }));
  }
};
var Jo = class extends jn {
  /**
   * @param {*} options
   */
  constructor(e) {
    super(), this.options = e;
  }
  /**
   * @param {string} text
   */
  addText(e) {
    e !== "" && this.add(e);
  }
  /** @param {string} scope */
  startScope(e) {
    this.openNode(e);
  }
  endScope() {
    this.closeNode();
  }
  /**
   * @param {Emitter & {root: DataNode}} emitter
   * @param {string} name
   */
  __addSublanguage(e, t) {
    const r = e.root;
    t && (r.scope = `language:${t}`), this.add(r);
  }
  toHTML() {
    return new Yo(this, this.options).value();
  }
  finalize() {
    return this.closeAllNodes(), true;
  }
};
function Ue(n) {
  return n ? typeof n == "string" ? n : n.source : null;
}
function _r(n) {
  return De("(?=", n, ")");
}
function Xo(n) {
  return De("(?:", n, ")*");
}
function Qo(n) {
  return De("(?:", n, ")?");
}
function De(...n) {
  return n.map((t) => Ue(t)).join("");
}
function es(n) {
  const e = n[n.length - 1];
  return typeof e == "object" && e.constructor === Object ? (n.splice(n.length - 1, 1), e) : {};
}
function Zn(...n) {
  return "(" + (es(n).capture ? "" : "?:") + n.map((r) => Ue(r)).join("|") + ")";
}
function br(n) {
  return new RegExp(n.toString() + "|").exec("").length - 1;
}
function ns(n, e) {
  const t = n && n.exec(e);
  return t && t.index === 0;
}
var ts = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function Kn(n, { joinWith: e }) {
  let t = 0;
  return n.map((r) => {
    t += 1;
    const o = t;
    let s = Ue(r), i = "";
    for (; s.length > 0; ) {
      const c = ts.exec(s);
      if (!c) {
        i += s;
        break;
      }
      i += s.substring(0, c.index), s = s.substring(c.index + c[0].length), c[0][0] === "\\" && c[1] ? i += "\\" + String(Number(c[1]) + o) : (i += c[0], c[0] === "(" && t++);
    }
    return i;
  }).map((r) => `(${r})`).join(e);
}
var rs = /\b\B/;
var vr = "[a-zA-Z]\\w*";
var Wn = "[a-zA-Z_]\\w*";
var kr = "\\b\\d+(\\.\\d+)?";
var xr = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
var yr = "\\b(0b[01]+)";
var os = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
var ss = (n = {}) => {
  const e = /^#![ ]*\//;
  return n.binary && (n.begin = De(
    e,
    /.*\b/,
    n.binary,
    /\b.*/
  )), ke({
    scope: "meta",
    begin: e,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": (t, r) => {
      t.index !== 0 && r.ignoreMatch();
    }
  }, n);
};
var He = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
};
var cs = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [He]
};
var is = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [He]
};
var as = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
};
var ln = function(n, e, t = {}) {
  const r = ke(
    {
      scope: "comment",
      begin: n,
      end: e,
      contains: []
    },
    t
  );
  r.contains.push({
    scope: "doctag",
    // hack to avoid the space from being included. the space is necessary to
    // match here to prevent the plain text rule below from gobbling up doctags
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: true,
    relevance: 0
  });
  const o = Zn(
    // list of common 1 and 2 letter words in English
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    // note: this is not an exhaustive list of contractions, just popular ones
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    // contractions - can't we'd they're let's, etc
    /[A-Za-z]+[-][a-z]+/,
    // `no-way`, etc.
    /[A-Za-z][a-z]{2,}/
    // allow capitalized words at beginning of sentences
  );
  return r.contains.push(
    {
      // TODO: how to include ", (, ) without breaking grammars that use these for
      // comment delimiters?
      // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
      // ---
      // this tries to find sequences of 3 english words in a row (without any
      // "programming" type syntax) this gives us a strong signal that we've
      // TRULY found a comment - vs perhaps scanning with the wrong language.
      // It's possible to find something that LOOKS like the start of the
      // comment - but then if there is no readable text - good chance it is a
      // false match and not a comment.
      //
      // for a visual example please see:
      // https://github.com/highlightjs/highlight.js/issues/2827
      begin: De(
        /[ ]+/,
        // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
        "(",
        o,
        /[.]?[:]?([.][ ]|[ ])/,
        "){3}"
      )
      // look for 3 words in a row
    }
  ), r;
};
var ls = ln("//", "$");
var us = ln("/\\*", "\\*/");
var fs = ln("#", "$");
var ps = {
  scope: "number",
  begin: kr,
  relevance: 0
};
var hs = {
  scope: "number",
  begin: xr,
  relevance: 0
};
var ds = {
  scope: "number",
  begin: yr,
  relevance: 0
};
var gs = {
  scope: "regexp",
  begin: /\/(?=[^/\n]*\/)/,
  end: /\/[gimuy]*/,
  contains: [
    He,
    {
      begin: /\[/,
      end: /\]/,
      relevance: 0,
      contains: [He]
    }
  ]
};
var ms = {
  scope: "title",
  begin: vr,
  relevance: 0
};
var _s = {
  scope: "title",
  begin: Wn,
  relevance: 0
};
var bs = {
  // excludes method names from keyword processing
  begin: "\\.\\s*" + Wn,
  relevance: 0
};
var vs = function(n) {
  return Object.assign(
    n,
    {
      /** @type {ModeCallback} */
      "on:begin": (e, t) => {
        t.data._beginMatch = e[1];
      },
      /** @type {ModeCallback} */
      "on:end": (e, t) => {
        t.data._beginMatch !== e[1] && t.ignoreMatch();
      }
    }
  );
};
var Xe = Object.freeze({
  __proto__: null,
  APOS_STRING_MODE: cs,
  BACKSLASH_ESCAPE: He,
  BINARY_NUMBER_MODE: ds,
  BINARY_NUMBER_RE: yr,
  COMMENT: ln,
  C_BLOCK_COMMENT_MODE: us,
  C_LINE_COMMENT_MODE: ls,
  C_NUMBER_MODE: hs,
  C_NUMBER_RE: xr,
  END_SAME_AS_BEGIN: vs,
  HASH_COMMENT_MODE: fs,
  IDENT_RE: vr,
  MATCH_NOTHING_RE: rs,
  METHOD_GUARD: bs,
  NUMBER_MODE: ps,
  NUMBER_RE: kr,
  PHRASAL_WORDS_MODE: as,
  QUOTE_STRING_MODE: is,
  REGEXP_MODE: gs,
  RE_STARTERS_RE: os,
  SHEBANG: ss,
  TITLE_MODE: ms,
  UNDERSCORE_IDENT_RE: Wn,
  UNDERSCORE_TITLE_MODE: _s
});
function ks(n, e) {
  n.input[n.index - 1] === "." && e.ignoreMatch();
}
function xs(n, e) {
  n.className !== void 0 && (n.scope = n.className, delete n.className);
}
function ys(n, e) {
  e && n.beginKeywords && (n.begin = "\\b(" + n.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", n.__beforeBegin = ks, n.keywords = n.keywords || n.beginKeywords, delete n.beginKeywords, n.relevance === void 0 && (n.relevance = 0));
}
function Es(n, e) {
  Array.isArray(n.illegal) && (n.illegal = Zn(...n.illegal));
}
function ws(n, e) {
  if (n.match) {
    if (n.begin || n.end)
      throw new Error("begin & end are not supported with match");
    n.begin = n.match, delete n.match;
  }
}
function As(n, e) {
  n.relevance === void 0 && (n.relevance = 1);
}
var Cs = (n, e) => {
  if (!n.beforeMatch)
    return;
  if (n.starts)
    throw new Error("beforeMatch cannot be used with starts");
  const t = Object.assign({}, n);
  Object.keys(n).forEach((r) => {
    delete n[r];
  }), n.keywords = t.keywords, n.begin = De(t.beforeMatch, _r(t.begin)), n.starts = {
    relevance: 0,
    contains: [
      Object.assign(t, { endsParent: true })
    ]
  }, n.relevance = 0, delete t.beforeMatch;
};
var Ss = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  // common variable name
  "list",
  // common variable name
  "value"
  // common variable name
];
var Ds = "keyword";
function Er(n, e, t = Ds) {
  const r = /* @__PURE__ */ Object.create(null);
  return typeof n == "string" ? o(t, n.split(" ")) : Array.isArray(n) ? o(t, n) : Object.keys(n).forEach(function(s) {
    Object.assign(
      r,
      Er(n[s], e, s)
    );
  }), r;
  function o(s, i) {
    e && (i = i.map((c) => c.toLowerCase())), i.forEach(function(c) {
      const a = c.split("|");
      r[a[0]] = [s, Ts(a[0], a[1])];
    });
  }
}
function Ts(n, e) {
  return e ? Number(e) : Rs(n) ? 0 : 1;
}
function Rs(n) {
  return Ss.includes(n.toLowerCase());
}
var bt = {};
var Ce = (n) => {
  console.error(n);
};
var vt = (n, ...e) => {
  console.log(`WARN: ${n}`, ...e);
};
var Te = (n, e) => {
  bt[`${n}/${e}`] || (console.log(`Deprecated as of ${n}. ${e}`), bt[`${n}/${e}`] = true);
};
var on = new Error();
function wr(n, e, { key: t }) {
  let r = 0;
  const o = n[t], s = {}, i = {};
  for (let c = 1; c <= e.length; c++)
    i[c + r] = o[c], s[c + r] = true, r += br(e[c - 1]);
  n[t] = i, n[t]._emit = s, n[t]._multi = true;
}
function Ls(n) {
  if (Array.isArray(n.begin)) {
    if (n.skip || n.excludeBegin || n.returnBegin)
      throw Ce("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), on;
    if (typeof n.beginScope != "object" || n.beginScope === null)
      throw Ce("beginScope must be object"), on;
    wr(n, n.begin, { key: "beginScope" }), n.begin = Kn(n.begin, { joinWith: "" });
  }
}
function Ns(n) {
  if (Array.isArray(n.end)) {
    if (n.skip || n.excludeEnd || n.returnEnd)
      throw Ce("skip, excludeEnd, returnEnd not compatible with endScope: {}"), on;
    if (typeof n.endScope != "object" || n.endScope === null)
      throw Ce("endScope must be object"), on;
    wr(n, n.end, { key: "endScope" }), n.end = Kn(n.end, { joinWith: "" });
  }
}
function qs(n) {
  n.scope && typeof n.scope == "object" && n.scope !== null && (n.beginScope = n.scope, delete n.scope);
}
function Ms(n) {
  qs(n), typeof n.beginScope == "string" && (n.beginScope = { _wrap: n.beginScope }), typeof n.endScope == "string" && (n.endScope = { _wrap: n.endScope }), Ls(n), Ns(n);
}
function Is(n) {
  function e(i, c) {
    return new RegExp(
      Ue(i),
      "m" + (n.case_insensitive ? "i" : "") + (n.unicodeRegex ? "u" : "") + (c ? "g" : "")
    );
  }
  class t {
    constructor() {
      this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
    }
    // @ts-ignore
    addRule(c, a) {
      a.position = this.position++, this.matchIndexes[this.matchAt] = a, this.regexes.push([a, c]), this.matchAt += br(c) + 1;
    }
    compile() {
      this.regexes.length === 0 && (this.exec = () => null);
      const c = this.regexes.map((a) => a[1]);
      this.matcherRe = e(Kn(c, { joinWith: "|" }), true), this.lastIndex = 0;
    }
    /** @param {string} s */
    exec(c) {
      this.matcherRe.lastIndex = this.lastIndex;
      const a = this.matcherRe.exec(c);
      if (!a)
        return null;
      const l = a.findIndex((p5, f) => f > 0 && p5 !== void 0), u = this.matchIndexes[l];
      return a.splice(0, l), Object.assign(a, u);
    }
  }
  class r {
    constructor() {
      this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
    }
    // @ts-ignore
    getMatcher(c) {
      if (this.multiRegexes[c])
        return this.multiRegexes[c];
      const a = new t();
      return this.rules.slice(c).forEach(([l, u]) => a.addRule(l, u)), a.compile(), this.multiRegexes[c] = a, a;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    // @ts-ignore
    addRule(c, a) {
      this.rules.push([c, a]), a.type === "begin" && this.count++;
    }
    /** @param {string} s */
    exec(c) {
      const a = this.getMatcher(this.regexIndex);
      a.lastIndex = this.lastIndex;
      let l = a.exec(c);
      if (this.resumingScanAtSamePosition() && !(l && l.index === this.lastIndex)) {
        const u = this.getMatcher(0);
        u.lastIndex = this.lastIndex + 1, l = u.exec(c);
      }
      return l && (this.regexIndex += l.position + 1, this.regexIndex === this.count && this.considerAll()), l;
    }
  }
  function o(i) {
    const c = new r();
    return i.contains.forEach((a) => c.addRule(a.begin, { rule: a, type: "begin" })), i.terminatorEnd && c.addRule(i.terminatorEnd, { type: "end" }), i.illegal && c.addRule(i.illegal, { type: "illegal" }), c;
  }
  function s(i, c) {
    const a = (
      /** @type CompiledMode */
      i
    );
    if (i.isCompiled)
      return a;
    [
      xs,
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      ws,
      Ms,
      Cs
    ].forEach((u) => u(i, c)), n.compilerExtensions.forEach((u) => u(i, c)), i.__beforeBegin = null, [
      ys,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      Es,
      // default to 1 relevance if not specified
      As
    ].forEach((u) => u(i, c)), i.isCompiled = true;
    let l = null;
    return typeof i.keywords == "object" && i.keywords.$pattern && (i.keywords = Object.assign({}, i.keywords), l = i.keywords.$pattern, delete i.keywords.$pattern), l = l || /\w+/, i.keywords && (i.keywords = Er(i.keywords, n.case_insensitive)), a.keywordPatternRe = e(l, true), c && (i.begin || (i.begin = /\B|\b/), a.beginRe = e(a.begin), !i.end && !i.endsWithParent && (i.end = /\B|\b/), i.end && (a.endRe = e(a.end)), a.terminatorEnd = Ue(a.end) || "", i.endsWithParent && c.terminatorEnd && (a.terminatorEnd += (i.end ? "|" : "") + c.terminatorEnd)), i.illegal && (a.illegalRe = e(
      /** @type {RegExp | string} */
      i.illegal
    )), i.contains || (i.contains = []), i.contains = [].concat(...i.contains.map(function(u) {
      return Os(u === "self" ? i : u);
    })), i.contains.forEach(function(u) {
      s(
        /** @type Mode */
        u,
        a
      );
    }), i.starts && s(i.starts, c), a.matcher = o(a), a;
  }
  if (n.compilerExtensions || (n.compilerExtensions = []), n.contains && n.contains.includes("self"))
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  return n.classNameAliases = ke(n.classNameAliases || {}), s(
    /** @type Mode */
    n
  );
}
function Ar(n) {
  return n ? n.endsWithParent || Ar(n.starts) : false;
}
function Os(n) {
  return n.variants && !n.cachedVariants && (n.cachedVariants = n.variants.map(function(e) {
    return ke(n, { variants: null }, e);
  })), n.cachedVariants ? n.cachedVariants : Ar(n) ? ke(n, { starts: n.starts ? ke(n.starts) : null }) : Object.isFrozen(n) ? ke(n) : n;
}
var Fs = "11.9.0";
var Bs = class extends Error {
  constructor(e, t) {
    super(e), this.name = "HTMLInjectionError", this.html = t;
  }
};
var An = mr;
var kt = ke;
var xt = Symbol("nomatch");
var Ps = 7;
var Cr = function(n) {
  const e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null), r = [];
  let o = true;
  const s = "Could not find the language '{}', did you forget to load/include a language module?", i = { disableAutodetect: true, name: "Plain text", contains: [] };
  let c = {
    ignoreUnescapedHTML: false,
    throwUnescapedHTML: false,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: Jo
  };
  function a(m) {
    return c.noHighlightRe.test(m);
  }
  function l(m) {
    let k = m.className + " ";
    k += m.parentNode ? m.parentNode.className : "";
    const R = c.languageDetectRe.exec(k);
    if (R) {
      const F = j(R[1]);
      return F || (vt(s.replace("{}", R[1])), vt("Falling back to no-highlight mode for this block.", m)), F ? R[1] : "no-highlight";
    }
    return k.split(/\s+/).find((F) => a(F) || j(F));
  }
  function u(m, k, R) {
    let F = "", U = "";
    typeof k == "object" ? (F = m, R = k.ignoreIllegals, U = k.language) : (Te("10.7.0", "highlight(lang, code, ...args) has been deprecated."), Te("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), U = m, F = k), R === void 0 && (R = true);
    const W = {
      code: F,
      language: U
    };
    T("before:highlight", W);
    const ne = W.result ? W.result : p5(W.language, W.code, R);
    return ne.code = W.code, T("after:highlight", ne), ne;
  }
  function p5(m, k, R, F) {
    const U = /* @__PURE__ */ Object.create(null);
    function W(y, C) {
      return y.keywords[C];
    }
    function ne() {
      if (!N.keywords) {
        J.addText(V);
        return;
      }
      let y = 0;
      N.keywordPatternRe.lastIndex = 0;
      let C = N.keywordPatternRe.exec(V), I = "";
      for (; C; ) {
        I += V.substring(y, C.index);
        const H = fe.case_insensitive ? C[0].toLowerCase() : C[0], Q = W(N, H);
        if (Q) {
          const [_e, go] = Q;
          if (J.addText(I), I = "", U[H] = (U[H] || 0) + 1, U[H] <= Ps && (Ye += go), _e.startsWith("_"))
            I += C[0];
          else {
            const mo = fe.classNameAliases[_e] || _e;
            ue(C[0], mo);
          }
        } else
          I += C[0];
        y = N.keywordPatternRe.lastIndex, C = N.keywordPatternRe.exec(V);
      }
      I += V.substring(y), J.addText(I);
    }
    function Ke() {
      if (V === "")
        return;
      let y = null;
      if (typeof N.subLanguage == "string") {
        if (!e[N.subLanguage]) {
          J.addText(V);
          return;
        }
        y = p5(N.subLanguage, V, true, ft[N.subLanguage]), ft[N.subLanguage] = /** @type {CompiledMode} */
        y._top;
      } else
        y = h5(V, N.subLanguage.length ? N.subLanguage : null);
      N.relevance > 0 && (Ye += y.relevance), J.__addSublanguage(y._emitter, y.language);
    }
    function oe() {
      N.subLanguage != null ? Ke() : ne(), V = "";
    }
    function ue(y, C) {
      y !== "" && (J.startScope(C), J.addText(y), J.endScope());
    }
    function it(y, C) {
      let I = 1;
      const H = C.length - 1;
      for (; I <= H; ) {
        if (!y._emit[I]) {
          I++;
          continue;
        }
        const Q = fe.classNameAliases[y[I]] || y[I], _e = C[I];
        Q ? ue(_e, Q) : (V = _e, ne(), V = ""), I++;
      }
    }
    function at(y, C) {
      return y.scope && typeof y.scope == "string" && J.openNode(fe.classNameAliases[y.scope] || y.scope), y.beginScope && (y.beginScope._wrap ? (ue(V, fe.classNameAliases[y.beginScope._wrap] || y.beginScope._wrap), V = "") : y.beginScope._multi && (it(y.beginScope, C), V = "")), N = Object.create(y, { parent: { value: N } }), N;
    }
    function lt(y, C, I) {
      let H = ns(y.endRe, I);
      if (H) {
        if (y["on:end"]) {
          const Q = new gt(y);
          y["on:end"](C, Q), Q.isMatchIgnored && (H = false);
        }
        if (H) {
          for (; y.endsParent && y.parent; )
            y = y.parent;
          return y;
        }
      }
      if (y.endsWithParent)
        return lt(y.parent, C, I);
    }
    function lo(y) {
      return N.matcher.regexIndex === 0 ? (V += y[0], 1) : (En = true, 0);
    }
    function uo(y) {
      const C = y[0], I = y.rule, H = new gt(I), Q = [I.__beforeBegin, I["on:begin"]];
      for (const _e of Q)
        if (_e && (_e(y, H), H.isMatchIgnored))
          return lo(C);
      return I.skip ? V += C : (I.excludeBegin && (V += C), oe(), !I.returnBegin && !I.excludeBegin && (V = C)), at(I, y), I.returnBegin ? 0 : C.length;
    }
    function fo(y) {
      const C = y[0], I = k.substring(y.index), H = lt(N, y, I);
      if (!H)
        return xt;
      const Q = N;
      N.endScope && N.endScope._wrap ? (oe(), ue(C, N.endScope._wrap)) : N.endScope && N.endScope._multi ? (oe(), it(N.endScope, y)) : Q.skip ? V += C : (Q.returnEnd || Q.excludeEnd || (V += C), oe(), Q.excludeEnd && (V = C));
      do
        N.scope && J.closeNode(), !N.skip && !N.subLanguage && (Ye += N.relevance), N = N.parent;
      while (N !== H.parent);
      return H.starts && at(H.starts, y), Q.returnEnd ? 0 : C.length;
    }
    function po() {
      const y = [];
      for (let C = N; C !== fe; C = C.parent)
        C.scope && y.unshift(C.scope);
      y.forEach((C) => J.openNode(C));
    }
    let We = {};
    function ut(y, C) {
      const I = C && C[0];
      if (V += y, I == null)
        return oe(), 0;
      if (We.type === "begin" && C.type === "end" && We.index === C.index && I === "") {
        if (V += k.slice(C.index, C.index + 1), !o) {
          const H = new Error(`0 width match regex (${m})`);
          throw H.languageName = m, H.badRule = We.rule, H;
        }
        return 1;
      }
      if (We = C, C.type === "begin")
        return uo(C);
      if (C.type === "illegal" && !R) {
        const H = new Error('Illegal lexeme "' + I + '" for mode "' + (N.scope || "<unnamed>") + '"');
        throw H.mode = N, H;
      } else if (C.type === "end") {
        const H = fo(C);
        if (H !== xt)
          return H;
      }
      if (C.type === "illegal" && I === "")
        return 1;
      if (yn > 1e5 && yn > C.index * 3)
        throw new Error("potential infinite loop, way more iterations than matches");
      return V += I, I.length;
    }
    const fe = j(m);
    if (!fe)
      throw Ce(s.replace("{}", m)), new Error('Unknown language: "' + m + '"');
    const ho = Is(fe);
    let xn = "", N = F || ho;
    const ft = {}, J = new c.__emitter(c);
    po();
    let V = "", Ye = 0, ye = 0, yn = 0, En = false;
    try {
      if (fe.__emitTokens)
        fe.__emitTokens(k, J);
      else {
        for (N.matcher.considerAll(); ; ) {
          yn++, En ? En = false : N.matcher.considerAll(), N.matcher.lastIndex = ye;
          const y = N.matcher.exec(k);
          if (!y)
            break;
          const C = k.substring(ye, y.index), I = ut(C, y);
          ye = y.index + I;
        }
        ut(k.substring(ye));
      }
      return J.finalize(), xn = J.toHTML(), {
        language: m,
        value: xn,
        relevance: Ye,
        illegal: false,
        _emitter: J,
        _top: N
      };
    } catch (y) {
      if (y.message && y.message.includes("Illegal"))
        return {
          language: m,
          value: An(k),
          illegal: true,
          relevance: 0,
          _illegalBy: {
            message: y.message,
            index: ye,
            context: k.slice(ye - 100, ye + 100),
            mode: y.mode,
            resultSoFar: xn
          },
          _emitter: J
        };
      if (o)
        return {
          language: m,
          value: An(k),
          illegal: false,
          relevance: 0,
          errorRaised: y,
          _emitter: J,
          _top: N
        };
      throw y;
    }
  }
  function f(m) {
    const k = {
      value: An(m),
      illegal: false,
      relevance: 0,
      _top: i,
      _emitter: new c.__emitter(c)
    };
    return k._emitter.addText(m), k;
  }
  function h5(m, k) {
    k = k || c.languages || Object.keys(e);
    const R = f(m), F = k.filter(j).filter(K).map(
      (oe) => p5(oe, m, false)
    );
    F.unshift(R);
    const U = F.sort((oe, ue) => {
      if (oe.relevance !== ue.relevance)
        return ue.relevance - oe.relevance;
      if (oe.language && ue.language) {
        if (j(oe.language).supersetOf === ue.language)
          return 1;
        if (j(ue.language).supersetOf === oe.language)
          return -1;
      }
      return 0;
    }), [W, ne] = U, Ke = W;
    return Ke.secondBest = ne, Ke;
  }
  function d(m, k, R) {
    const F = k && t[k] || R;
    m.classList.add("hljs"), m.classList.add(`language-${F}`);
  }
  function g(m) {
    let k = null;
    const R = l(m);
    if (a(R))
      return;
    if (T(
      "before:highlightElement",
      { el: m, language: R }
    ), m.dataset.highlighted) {
      console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", m);
      return;
    }
    if (m.children.length > 0 && (c.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(m)), c.throwUnescapedHTML))
      throw new Bs(
        "One of your code blocks includes unescaped HTML.",
        m.innerHTML
      );
    k = m;
    const F = k.textContent, U = R ? u(F, { language: R, ignoreIllegals: true }) : h5(F);
    m.innerHTML = U.value, m.dataset.highlighted = "yes", d(m, R, U.language), m.result = {
      language: U.language,
      // TODO: remove with version 11.0
      re: U.relevance,
      relevance: U.relevance
    }, U.secondBest && (m.secondBest = {
      language: U.secondBest.language,
      relevance: U.secondBest.relevance
    }), T("after:highlightElement", { el: m, result: U, text: F });
  }
  function E(m) {
    c = kt(c, m);
  }
  const x = () => {
    D(), Te("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function b() {
    D(), Te("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let A = false;
  function D() {
    if (document.readyState === "loading") {
      A = true;
      return;
    }
    document.querySelectorAll(c.cssSelector).forEach(g);
  }
  function L() {
    A && D();
  }
  typeof window < "u" && window.addEventListener && window.addEventListener("DOMContentLoaded", L, false);
  function v(m, k) {
    let R = null;
    try {
      R = k(n);
    } catch (F) {
      if (Ce("Language definition for '{}' could not be registered.".replace("{}", m)), o)
        Ce(F);
      else
        throw F;
      R = i;
    }
    R.name || (R.name = m), e[m] = R, R.rawDefinition = k.bind(null, n), R.aliases && M(R.aliases, { languageName: m });
  }
  function O(m) {
    delete e[m];
    for (const k of Object.keys(t))
      t[k] === m && delete t[k];
  }
  function z() {
    return Object.keys(e);
  }
  function j(m) {
    return m = (m || "").toLowerCase(), e[m] || e[t[m]];
  }
  function M(m, { languageName: k }) {
    typeof m == "string" && (m = [m]), m.forEach((R) => {
      t[R.toLowerCase()] = k;
    });
  }
  function K(m) {
    const k = j(m);
    return k && !k.disableAutodetect;
  }
  function q(m) {
    m["before:highlightBlock"] && !m["before:highlightElement"] && (m["before:highlightElement"] = (k) => {
      m["before:highlightBlock"](
        Object.assign({ block: k.el }, k)
      );
    }), m["after:highlightBlock"] && !m["after:highlightElement"] && (m["after:highlightElement"] = (k) => {
      m["after:highlightBlock"](
        Object.assign({ block: k.el }, k)
      );
    });
  }
  function Z(m) {
    q(m), r.push(m);
  }
  function _(m) {
    const k = r.indexOf(m);
    k !== -1 && r.splice(k, 1);
  }
  function T(m, k) {
    const R = m;
    r.forEach(function(F) {
      F[R] && F[R](k);
    });
  }
  function w(m) {
    return Te("10.7.0", "highlightBlock will be removed entirely in v12.0"), Te("10.7.0", "Please use highlightElement now."), g(m);
  }
  Object.assign(n, {
    highlight: u,
    highlightAuto: h5,
    highlightAll: D,
    highlightElement: g,
    // TODO: Remove with v12 API
    highlightBlock: w,
    configure: E,
    initHighlighting: x,
    initHighlightingOnLoad: b,
    registerLanguage: v,
    unregisterLanguage: O,
    listLanguages: z,
    getLanguage: j,
    registerAliases: M,
    autoDetection: K,
    inherit: kt,
    addPlugin: Z,
    removePlugin: _
  }), n.debugMode = function() {
    o = false;
  }, n.safeMode = function() {
    o = true;
  }, n.versionString = Fs, n.regex = {
    concat: De,
    lookahead: _r,
    either: Zn,
    optional: Qo,
    anyNumberOfTimes: Xo
  };
  for (const m in Xe)
    typeof Xe[m] == "object" && gr(Xe[m]);
  return Object.assign(n, Xe), n;
};
var Ne = Cr({});
Ne.newInstance = () => Cr({});
var $s = Ne;
Ne.HighlightJS = Ne;
Ne.default = Ne;
var be = Gn($s);
var yt = "[A-Za-z$_][0-9A-Za-z$_]*";
var zs = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
];
var Us = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
];
var Sr = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
];
var Dr = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
];
var Tr = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
];
var Hs = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
];
var Vs = [].concat(
  Tr,
  Sr,
  Dr
);
function Rr(n) {
  const e = n.regex, t = (k, { after: R }) => {
    const F = "</" + k[0].slice(1);
    return k.input.indexOf(F, R) !== -1;
  }, r = yt, o = {
    begin: "<>",
    end: "</>"
  }, s = /<[A-Za-z0-9\\._:-]+\s*\/>/, i = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (k, R) => {
      const F = k[0].length + k.index, U = k.input[F];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        U === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        U === ","
      ) {
        R.ignoreMatch();
        return;
      }
      U === ">" && (t(k, { after: F }) || R.ignoreMatch());
      let W;
      const ne = k.input.substring(F);
      if (W = ne.match(/^\s*=/)) {
        R.ignoreMatch();
        return;
      }
      if ((W = ne.match(/^\s+extends\s+/)) && W.index === 0) {
        R.ignoreMatch();
        return;
      }
    }
  }, c = {
    $pattern: yt,
    keyword: zs,
    literal: Us,
    built_in: Vs,
    "variable.language": Hs
  }, a = "[0-9](_?[0-9])*", l = `\\.(${a})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", p5 = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${u})((${l})|\\.)?|(${l}))[eE][+-]?(${a})\\b` },
      { begin: `\\b(${u})\\b((${l})\\b|\\.)?|(${l})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, f = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: c,
    contains: []
    // defined later
  }, h5 = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "xml"
    }
  }, d = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "css"
    }
  }, g = {
    begin: "gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "graphql"
    }
  }, E = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      n.BACKSLASH_ESCAPE,
      f
    ]
  }, b = {
    className: "comment",
    variants: [
      n.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: true,
                  excludeBegin: true,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: r + "(?=\\s*(-)|$)",
                  endsParent: true,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      n.C_BLOCK_COMMENT_MODE,
      n.C_LINE_COMMENT_MODE
    ]
  }, A = [
    n.APOS_STRING_MODE,
    n.QUOTE_STRING_MODE,
    h5,
    d,
    g,
    E,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    p5
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  f.contains = A.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: c,
    contains: [
      "self"
    ].concat(A)
  });
  const D = [].concat(b, f.contains), L = D.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: c,
      contains: ["self"].concat(D)
    }
  ]), v = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: true,
    excludeEnd: true,
    keywords: c,
    contains: L
  }, O = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          r,
          /\s+/,
          /extends/,
          /\s+/,
          e.concat(r, "(", e.concat(/\./, r), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          r
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, z = {
    relevance: 0,
    match: e.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...Sr,
        ...Dr
      ]
    }
  }, j = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, M = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          r,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [v],
    illegal: /%/
  }, K = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function q(k) {
    return e.concat("(?!", k.join("|"), ")");
  }
  const Z = {
    match: e.concat(
      /\b/,
      q([
        ...Tr,
        "super",
        "import"
      ]),
      r,
      e.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  }, _ = {
    begin: e.concat(/\./, e.lookahead(
      e.concat(r, /(?![0-9A-Za-z$_(])/)
    )),
    end: r,
    excludeBegin: true,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, T = {
    match: [
      /get|set/,
      /\s+/,
      r,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      v
    ]
  }, w = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + n.UNDERSCORE_IDENT_RE + ")\\s*=>", m = {
    match: [
      /const|var|let/,
      /\s+/,
      r,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      e.lookahead(w)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      v
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: c,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: L, CLASS_REFERENCE: z },
    illegal: /#(?![$_A-z])/,
    contains: [
      n.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      j,
      n.APOS_STRING_MODE,
      n.QUOTE_STRING_MODE,
      h5,
      d,
      g,
      E,
      b,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      p5,
      z,
      {
        className: "attr",
        begin: r + e.lookahead(":"),
        relevance: 0
      },
      m,
      {
        // "value" container
        begin: "(" + n.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          b,
          n.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: w,
            returnBegin: true,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: n.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: true
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: true,
                    excludeEnd: true,
                    keywords: c,
                    contains: L
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: o.begin, end: o.end },
              { match: s },
              {
                begin: i.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": i.isTrulyOpeningTag,
                end: i.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: i.begin,
                end: i.end,
                skip: true,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      M,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + n.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: true,
        label: "func.def",
        contains: [
          v,
          n.inherit(n.TITLE_MODE, { begin: r, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      _,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + r,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [v]
      },
      Z,
      K,
      O,
      T,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function Lr(n) {
  const e = n.regex, t = e.concat(/[\p{L}_]/u, e.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u), r = /[\p{L}0-9._:-]+/u, o = {
    className: "symbol",
    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
  }, s = {
    begin: /\s/,
    contains: [
      {
        className: "keyword",
        begin: /#?[a-z_][a-z1-9_-]+/,
        illegal: /\n/
      }
    ]
  }, i = n.inherit(s, {
    begin: /\(/,
    end: /\)/
  }), c = n.inherit(n.APOS_STRING_MODE, { className: "string" }), a = n.inherit(n.QUOTE_STRING_MODE, { className: "string" }), l = {
    endsWithParent: true,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: "attr",
        begin: r,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: "string",
            endsParent: true,
            variants: [
              {
                begin: /"/,
                end: /"/,
                contains: [o]
              },
              {
                begin: /'/,
                end: /'/,
                contains: [o]
              },
              { begin: /[^\s"'=<>`]+/ }
            ]
          }
        ]
      }
    ]
  };
  return {
    name: "HTML, XML",
    aliases: [
      "html",
      "xhtml",
      "rss",
      "atom",
      "xjb",
      "xsd",
      "xsl",
      "plist",
      "wsf",
      "svg"
    ],
    case_insensitive: true,
    unicodeRegex: true,
    contains: [
      {
        className: "meta",
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          s,
          a,
          c,
          i,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                contains: [
                  s,
                  i,
                  a,
                  c
                ]
              }
            ]
          }
        ]
      },
      n.COMMENT(
        /<!--/,
        /-->/,
        { relevance: 10 }
      ),
      {
        begin: /<!\[CDATA\[/,
        end: /\]\]>/,
        relevance: 10
      },
      o,
      // xml processing instructions
      {
        className: "meta",
        end: /\?>/,
        variants: [
          {
            begin: /<\?xml/,
            relevance: 10,
            contains: [
              a
            ]
          },
          {
            begin: /<\?[a-z][a-z0-9]+/
          }
        ]
      },
      {
        className: "tag",
        /*
        The lookahead pattern (?=...) ensures that 'begin' only matches
        '<style' as a single word, followed by a whitespace or an
        ending bracket.
        */
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: { name: "style" },
        contains: [l],
        starts: {
          end: /<\/style>/,
          returnEnd: true,
          subLanguage: [
            "css",
            "xml"
          ]
        }
      },
      {
        className: "tag",
        // See the comment in the <style tag about the lookahead pattern
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: { name: "script" },
        contains: [l],
        starts: {
          end: /<\/script>/,
          returnEnd: true,
          subLanguage: [
            "javascript",
            "handlebars",
            "xml"
          ]
        }
      },
      // we need this for now for jSX
      {
        className: "tag",
        begin: /<>|<\/>/
      },
      // open tag
      {
        className: "tag",
        begin: e.concat(
          /</,
          e.lookahead(e.concat(
            t,
            // <tag/>
            // <tag>
            // <tag ...
            e.either(/\/>/, />/, /\s/)
          ))
        ),
        end: /\/?>/,
        contains: [
          {
            className: "name",
            begin: t,
            relevance: 0,
            starts: l
          }
        ]
      },
      // close tag
      {
        className: "tag",
        begin: e.concat(
          /<\//,
          e.lookahead(e.concat(
            t,
            />/
          ))
        ),
        contains: [
          {
            className: "name",
            begin: t,
            relevance: 0
          },
          {
            begin: />/,
            relevance: 0,
            endsParent: true
          }
        ]
      }
    ]
  };
}
var un = (n, e) => {
  const t = n.__vccOpts || n;
  for (const [r, o] of e)
    t[r] = o;
  return t;
};
var Gs = {};
var js = { class: "chat-button" };
function Zs(n, e) {
  return openBlock(), createElementBlock("button", js, [
    renderSlot(n.$slots, "default")
  ]);
}
var Ks = un(Gs, [["render", Zs]]);
var Ws = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
var Ys = createBaseVNode("path", {
  fill: "currentColor",
  d: "M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12z"
}, null, -1);
var Js = [
  Ys
];
function Xs(n, e) {
  return openBlock(), createElementBlock("svg", Ws, [...Js]);
}
var Qs = { name: "mdi-close", render: Xs };
function Yn() {
  return inject(fr);
}
function Ge() {
  return {
    options: inject(pr)
  };
}
function fn() {
  const { options: n } = Ge(), e = (n == null ? void 0 : n.defaultLanguage) ?? "en";
  function t(o) {
    var i, c;
    const s = (c = (i = n == null ? void 0 : n.i18n) == null ? void 0 : i[e]) == null ? void 0 : c[o];
    return isRef2(s) ? s.value : s ?? o;
  }
  function r(o) {
    var s, i;
    return !!((i = (s = n == null ? void 0 : n.i18n) == null ? void 0 : s[e]) != null && i[o]);
  }
  return { t, te: r };
}
var ec = { class: "chat-get-started" };
var nc = defineComponent({
  __name: "GetStarted",
  setup(n) {
    const { t: e } = fn();
    return (t, r) => (openBlock(), createElementBlock("div", ec, [
      createVNode(Ks, {
        onClick: r[0] || (r[0] = (o) => t.$emit("click:button"))
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(unref(e)("getStarted")), 1)
        ]),
        _: 1
      })
    ]));
  }
});
var tc = {};
var rc = { class: "chat-powered-by" };
var oc = createBaseVNode("a", { href: "https://n8n.io?utm_source=n8n-external&utm_medium=widget-powered-by" }, "n8n", -1);
function sc(n, e) {
  return openBlock(), createElementBlock("div", rc, [
    createTextVNode(" Powered by "),
    oc
  ]);
}
var cc = un(tc, [["render", sc]]);
var ic = { class: "chat-get-started-footer" };
var ac = { key: 0 };
var lc = defineComponent({
  __name: "GetStartedFooter",
  setup(n) {
    const { t: e, te: t } = fn();
    return (r, o) => (openBlock(), createElementBlock("div", ic, [
      unref(t)("footer") ? (openBlock(), createElementBlock("div", ac, toDisplayString(unref(e)("footer")), 1)) : createCommentVNode("", true),
      createVNode(cc)
    ]));
  }
});
function uc(n) {
  return getCurrentScope() ? (onScopeDispose(n), true) : false;
}
function fc() {
  const n = /* @__PURE__ */ new Set(), e = (o) => {
    n.delete(o);
  };
  return {
    on: (o) => {
      n.add(o);
      const s = () => e(o);
      return uc(s), {
        off: s
      };
    },
    off: e,
    trigger: (...o) => Promise.all(Array.from(n).map((s) => s(...o)))
  };
}
var pc = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
var hc = (n, e) => Object.prototype.hasOwnProperty.call(n, e);
var dc = pc ? window.document : void 0;
var gc = {
  multiple: true,
  accept: "*",
  reset: false,
  directory: false
};
function mc(n = {}) {
  const {
    document: e = dc
  } = n, t = ref(null), { on: r, trigger: o } = fc();
  let s;
  e && (s = e.createElement("input"), s.type = "file", s.onchange = (a) => {
    const l = a.target;
    t.value = l.files, o(t.value);
  });
  const i = () => {
    t.value = null, s && s.value && (s.value = "", o(null));
  }, c = (a) => {
    if (!s)
      return;
    const l = {
      ...gc,
      ...n,
      ...a
    };
    s.multiple = l.multiple, s.accept = l.accept, s.webkitdirectory = l.directory, hc(l, "capture") && (s.capture = l.capture), l.reset && i(), s.click();
  };
  return {
    files: readonly(t),
    open: c,
    reset: i,
    onChange: r
  };
}
var _c = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
var bc = createBaseVNode("path", {
  fill: "currentColor",
  d: "M14 2H6c-1.11 0-2 .89-2 2v16c0 1.11.89 2 2 2h7.81c-.53-.91-.81-1.95-.81-3c0-3.31 2.69-6 6-6c.34 0 .67.03 1 .08V8zm-1 7V3.5L18.5 9zm10 11h-3v3h-2v-3h-3v-2h3v-3h2v3h3z"
}, null, -1);
var vc = [
  bc
];
function kc(n, e) {
  return openBlock(), createElementBlock("svg", _c, [...vc]);
}
var xc = { name: "mdi-filePlus", render: kc };
var yc = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
var Ec = createBaseVNode("path", {
  fill: "currentColor",
  d: "m2 21l21-9L2 3v7l15 2l-15 2z"
}, null, -1);
var wc = [
  Ec
];
function Ac(n, e) {
  return openBlock(), createElementBlock("svg", yc, [...wc]);
}
var Cc = { name: "mdi-send", render: Ac };
var Sc = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
var Dc = createBaseVNode("path", {
  fill: "currentColor",
  d: "M20 6.91L17.09 4L12 9.09L6.91 4L4 6.91L9.09 12L4 17.09L6.91 20L12 14.91L17.09 20L20 17.09L14.91 12z"
}, null, -1);
var Tc = [
  Dc
];
function Rc(n, e) {
  return openBlock(), createElementBlock("svg", Sc, [...Tc]);
}
var Lc = { name: "mdi-closeThick", render: Rc };
var Nc = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
var qc = createBaseVNode("path", {
  fill: "currentColor",
  d: "M13 9h5.5L13 3.5zM6 2h8l6 6v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V4c0-1.11.89-2 2-2m0 18h12v-8l-4 4l-2-2zM8 9a2 2 0 0 0-2 2a2 2 0 0 0 2 2a2 2 0 0 0 2-2a2 2 0 0 0-2-2"
}, null, -1);
var Mc = [
  qc
];
function Ic(n, e) {
  return openBlock(), createElementBlock("svg", Nc, [...Mc]);
}
var Oc = { name: "mdi-fileImage", render: Ic };
var Fc = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
var Bc = createBaseVNode("path", {
  fill: "currentColor",
  d: "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8zm-1 11h-2v5a2 2 0 0 1-2 2a2 2 0 0 1-2-2a2 2 0 0 1 2-2c.4 0 .7.1 1 .3V11h3zm0-4V3.5L18.5 9z"
}, null, -1);
var Pc = [
  Bc
];
function $c(n, e) {
  return openBlock(), createElementBlock("svg", Fc, [...Pc]);
}
var zc = { name: "mdi-fileMusic", render: $c };
var Uc = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
var Hc = createBaseVNode("path", {
  fill: "currentColor",
  d: "M13 9h5.5L13 3.5zM6 2h8l6 6v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V4c0-1.11.89-2 2-2m9 16v-2H6v2zm3-4v-2H6v2z"
}, null, -1);
var Vc = [
  Hc
];
function Gc(n, e) {
  return openBlock(), createElementBlock("svg", Uc, [...Vc]);
}
var Et = { name: "mdi-fileText", render: Gc };
var jc = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
var Zc = createBaseVNode("path", {
  fill: "currentColor",
  d: "M13 9h5.5L13 3.5zM6 2h8l6 6v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V4c0-1.11.89-2 2-2m11 17v-6l-3 2.2V13H7v6h7v-2.2z"
}, null, -1);
var Kc = [
  Zc
];
function Wc(n, e) {
  return openBlock(), createElementBlock("svg", jc, [...Kc]);
}
var Yc = { name: "mdi-fileVideo", render: Wc };
var Jc = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
var Xc = createBaseVNode("path", {
  fill: "currentColor",
  d: "M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"
}, null, -1);
var Qc = [
  Xc
];
function ei(n, e) {
  return openBlock(), createElementBlock("svg", Jc, [...Qc]);
}
var ni = { name: "mdi-openInNew", render: ei };
var ti = { class: "chat-file-name" };
var ri = defineComponent({
  __name: "ChatFile",
  props: {
    file: {},
    isRemovable: { type: Boolean },
    isPreviewable: { type: Boolean }
  },
  emits: ["remove"],
  setup(n, { emit: e }) {
    const t = n, r = e, o = {
      document: Et,
      audio: zc,
      image: Oc,
      video: Yc
    }, s = computed2(() => {
      var a;
      const c = (a = t.file) == null ? void 0 : a.type.split("/")[0];
      return o[c] || Et;
    });
    function i() {
      t.isRemovable && r("remove", t.file), t.isPreviewable && window.open(URL.createObjectURL(t.file));
    }
    return (c, a) => (openBlock(), createElementBlock("div", {
      class: "chat-file",
      onClick: i
    }, [
      createVNode(unref(s)),
      createBaseVNode("p", ti, toDisplayString(c.file.name), 1),
      c.isRemovable ? (openBlock(), createBlock(unref(Lc), {
        key: 0,
        class: "chat-file-delete"
      })) : createCommentVNode("", true),
      c.isPreviewable ? (openBlock(), createBlock(unref(ni), {
        key: 1,
        class: "chat-file-preview"
      })) : createCommentVNode("", true)
    ]));
  }
});
var Nr = un(ri, [["__scopeId", "data-v-c15a8ecf"]]);
var oi = { class: "chat-inputs" };
var si = ["disabled", "placeholder"];
var ci = { class: "chat-inputs-controls" };
var ii = ["disabled"];
var ai = ["disabled"];
var li = {
  key: 0,
  class: "chat-files"
};
var ui = defineComponent({
  __name: "Input",
  emits: ["arrowKeyDown"],
  setup(n, { emit: e }) {
    const t = e, { options: r } = Ge(), o = Yn(), { waitingForResponse: s } = o, { t: i } = fn(), c = ref(null), a = ref(null), l = ref(""), u = ref(false), p5 = computed2(() => {
      var q;
      return l.value === "" || s.value || ((q = r.disabled) == null ? void 0 : q.value) === true;
    }), f = computed2(() => {
      var q;
      return ((q = r.disabled) == null ? void 0 : q.value) === true;
    }), h5 = computed2(
      () => {
        var q;
        return d.value && s.value && !((q = r.disabled) != null && q.value);
      }
    ), d = computed2(() => unref(r.allowFileUploads) === true), g = computed2(() => unref(r.allowedFilesMimeTypes)), E = computed2(() => ({
      "--controls-count": d.value ? 2 : 1
    })), {
      open: x,
      reset: b,
      onChange: A
    } = mc({
      multiple: true,
      reset: false
    });
    A((q) => {
      if (!q)
        return;
      const Z = new DataTransfer();
      if (c.value)
        for (let _ = 0; _ < c.value.length; _++)
          Z.items.add(c.value[_]);
      for (let _ = 0; _ < q.length; _++)
        Z.items.add(q[_]);
      c.value = Z.files;
    }), onMounted(() => {
      re.on("focusInput", L), re.on("blurInput", D), re.on("setInputValue", v);
    }), onUnmounted(() => {
      re.off("focusInput", L), re.off("blurInput", D), re.off("setInputValue", v);
    });
    function D() {
      a.value && a.value.blur();
    }
    function L() {
      a.value && a.value.focus();
    }
    function v(q) {
      l.value = q, L();
    }
    async function O(q) {
      if (q.preventDefault(), p5.value)
        return;
      const Z = l.value;
      l.value = "", u.value = true, await o.sendMessage(Z, Array.from(c.value ?? [])), u.value = false, b(), c.value = null;
    }
    async function z(q) {
      q.shiftKey || await O(q);
    }
    function j(q) {
      if (!c.value)
        return;
      const Z = new DataTransfer();
      for (let _ = 0; _ < c.value.length; _++) {
        const T = c.value[_];
        q.name !== T.name && Z.items.add(T);
      }
      b(), c.value = Z.files;
    }
    function M(q) {
      (q.key === "ArrowUp" || q.key === "ArrowDown") && (q.preventDefault(), t("arrowKeyDown", {
        key: q.key,
        currentInputValue: l.value
      }));
    }
    function K() {
      h5.value || x({ accept: unref(g) });
    }
    return (q, Z) => {
      var _;
      return openBlock(), createElementBlock("div", {
        class: "chat-input",
        style: normalizeStyle(E.value),
        onKeydown: withModifiers(M, ["stop"])
      }, [
        createBaseVNode("div", oi, [
          withDirectives(createBaseVNode("textarea", {
            ref_key: "chatTextArea",
            ref: a,
            "onUpdate:modelValue": Z[0] || (Z[0] = (T) => l.value = T),
            disabled: f.value,
            placeholder: unref(i)("inputPlaceholder"),
            onKeydown: withKeys(z, ["enter"])
          }, null, 40, si), [
            [vModelText, l.value]
          ]),
          createBaseVNode("div", ci, [
            d.value ? (openBlock(), createElementBlock("button", {
              key: 0,
              disabled: h5.value,
              class: "chat-input-send-button",
              onClick: K
            }, [
              createVNode(unref(xc), {
                height: "24",
                width: "24"
              })
            ], 8, ii)) : createCommentVNode("", true),
            createBaseVNode("button", {
              disabled: p5.value,
              class: "chat-input-send-button",
              onClick: O
            }, [
              createVNode(unref(Cc), {
                height: "24",
                width: "24"
              })
            ], 8, ai)
          ])
        ]),
        (_ = c.value) != null && _.length && !u.value ? (openBlock(), createElementBlock("div", li, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(c.value, (T) => (openBlock(), createBlock(Nr, {
            key: T.name,
            file: T,
            "is-removable": true,
            onRemove: j
          }, null, 8, ["file"]))), 128))
        ])) : createCommentVNode("", true)
      ], 36);
    };
  }
});
var fi = un(ui, [["__scopeId", "data-v-2a7fb1c3"]]);
var pi = { class: "chat-layout" };
var hi = {
  key: 0,
  class: "chat-header"
};
var di = {
  key: 2,
  class: "chat-footer"
};
var gi = defineComponent({
  __name: "Layout",
  setup(n) {
    const e = ref(null);
    function t() {
      const r = e.value;
      r && (r.scrollTop = r.scrollHeight);
    }
    return onMounted(() => {
      re.on("scrollToBottom", t), window.addEventListener("resize", t);
    }), onBeforeUnmount(() => {
      re.off("scrollToBottom", t), window.removeEventListener("resize", t);
    }), (r, o) => (openBlock(), createElementBlock("main", pi, [
      r.$slots.header ? (openBlock(), createElementBlock("div", hi, [
        renderSlot(r.$slots, "header")
      ])) : createCommentVNode("", true),
      r.$slots.default ? (openBlock(), createElementBlock("div", {
        key: 1,
        ref_key: "chatBodyRef",
        ref: e,
        class: "chat-body"
      }, [
        renderSlot(r.$slots, "default")
      ], 512)) : createCommentVNode("", true),
      r.$slots.footer ? (openBlock(), createElementBlock("div", di, [
        renderSlot(r.$slots, "footer")
      ])) : createCommentVNode("", true)
    ]));
  }
});
function mi(n) {
  const e = n.regex, t = {}, r = {
    begin: /\$\{/,
    end: /\}/,
    contains: [
      "self",
      {
        begin: /:-/,
        contains: [t]
      }
      // default values
    ]
  };
  Object.assign(t, {
    className: "variable",
    variants: [
      { begin: e.concat(
        /\$[\w\d#@][\w\d_]*/,
        // negative look-ahead tries to avoid matching patterns that are not
        // Perl at all like $ident$, @ident@, etc.
        "(?![\\w\\d])(?![$])"
      ) },
      r
    ]
  });
  const o = {
    className: "subst",
    begin: /\$\(/,
    end: /\)/,
    contains: [n.BACKSLASH_ESCAPE]
  }, s = {
    begin: /<<-?\s*(?=\w+)/,
    starts: { contains: [
      n.END_SAME_AS_BEGIN({
        begin: /(\w+)/,
        end: /(\w+)/,
        className: "string"
      })
    ] }
  }, i = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      n.BACKSLASH_ESCAPE,
      t,
      o
    ]
  };
  o.contains.push(i);
  const c = {
    match: /\\"/
  }, a = {
    className: "string",
    begin: /'/,
    end: /'/
  }, l = {
    match: /\\'/
  }, u = {
    begin: /\$?\(\(/,
    end: /\)\)/,
    contains: [
      {
        begin: /\d+#[0-9a-f]+/,
        className: "number"
      },
      n.NUMBER_MODE,
      t
    ]
  }, p5 = [
    "fish",
    "bash",
    "zsh",
    "sh",
    "csh",
    "ksh",
    "tcsh",
    "dash",
    "scsh"
  ], f = n.SHEBANG({
    binary: `(${p5.join("|")})`,
    relevance: 10
  }), h5 = {
    className: "function",
    begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
    returnBegin: true,
    contains: [n.inherit(n.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
    relevance: 0
  }, d = [
    "if",
    "then",
    "else",
    "elif",
    "fi",
    "for",
    "while",
    "until",
    "in",
    "do",
    "done",
    "case",
    "esac",
    "function",
    "select"
  ], g = [
    "true",
    "false"
  ], E = { match: /(\/[a-z._-]+)+/ }, x = [
    "break",
    "cd",
    "continue",
    "eval",
    "exec",
    "exit",
    "export",
    "getopts",
    "hash",
    "pwd",
    "readonly",
    "return",
    "shift",
    "test",
    "times",
    "trap",
    "umask",
    "unset"
  ], b = [
    "alias",
    "bind",
    "builtin",
    "caller",
    "command",
    "declare",
    "echo",
    "enable",
    "help",
    "let",
    "local",
    "logout",
    "mapfile",
    "printf",
    "read",
    "readarray",
    "source",
    "type",
    "typeset",
    "ulimit",
    "unalias"
  ], A = [
    "autoload",
    "bg",
    "bindkey",
    "bye",
    "cap",
    "chdir",
    "clone",
    "comparguments",
    "compcall",
    "compctl",
    "compdescribe",
    "compfiles",
    "compgroups",
    "compquote",
    "comptags",
    "comptry",
    "compvalues",
    "dirs",
    "disable",
    "disown",
    "echotc",
    "echoti",
    "emulate",
    "fc",
    "fg",
    "float",
    "functions",
    "getcap",
    "getln",
    "history",
    "integer",
    "jobs",
    "kill",
    "limit",
    "log",
    "noglob",
    "popd",
    "print",
    "pushd",
    "pushln",
    "rehash",
    "sched",
    "setcap",
    "setopt",
    "stat",
    "suspend",
    "ttyctl",
    "unfunction",
    "unhash",
    "unlimit",
    "unsetopt",
    "vared",
    "wait",
    "whence",
    "where",
    "which",
    "zcompile",
    "zformat",
    "zftp",
    "zle",
    "zmodload",
    "zparseopts",
    "zprof",
    "zpty",
    "zregexparse",
    "zsocket",
    "zstyle",
    "ztcp"
  ], D = [
    "chcon",
    "chgrp",
    "chown",
    "chmod",
    "cp",
    "dd",
    "df",
    "dir",
    "dircolors",
    "ln",
    "ls",
    "mkdir",
    "mkfifo",
    "mknod",
    "mktemp",
    "mv",
    "realpath",
    "rm",
    "rmdir",
    "shred",
    "sync",
    "touch",
    "truncate",
    "vdir",
    "b2sum",
    "base32",
    "base64",
    "cat",
    "cksum",
    "comm",
    "csplit",
    "cut",
    "expand",
    "fmt",
    "fold",
    "head",
    "join",
    "md5sum",
    "nl",
    "numfmt",
    "od",
    "paste",
    "ptx",
    "pr",
    "sha1sum",
    "sha224sum",
    "sha256sum",
    "sha384sum",
    "sha512sum",
    "shuf",
    "sort",
    "split",
    "sum",
    "tac",
    "tail",
    "tr",
    "tsort",
    "unexpand",
    "uniq",
    "wc",
    "arch",
    "basename",
    "chroot",
    "date",
    "dirname",
    "du",
    "echo",
    "env",
    "expr",
    "factor",
    // "false", // keyword literal already
    "groups",
    "hostid",
    "id",
    "link",
    "logname",
    "nice",
    "nohup",
    "nproc",
    "pathchk",
    "pinky",
    "printenv",
    "printf",
    "pwd",
    "readlink",
    "runcon",
    "seq",
    "sleep",
    "stat",
    "stdbuf",
    "stty",
    "tee",
    "test",
    "timeout",
    // "true", // keyword literal already
    "tty",
    "uname",
    "unlink",
    "uptime",
    "users",
    "who",
    "whoami",
    "yes"
  ];
  return {
    name: "Bash",
    aliases: ["sh"],
    keywords: {
      $pattern: /\b[a-z][a-z0-9._-]+\b/,
      keyword: d,
      literal: g,
      built_in: [
        ...x,
        ...b,
        // Shell modifiers
        "set",
        "shopt",
        ...A,
        ...D
      ]
    },
    contains: [
      f,
      // to catch known shells and boost relevancy
      n.SHEBANG(),
      // to catch unknown shells but still highlight the shebang
      h5,
      u,
      n.HASH_COMMENT_MODE,
      s,
      E,
      i,
      c,
      a,
      l,
      t
    ]
  };
}
function _i(n) {
  const e = n.regex, t = new RegExp("[\\p{XID_Start}_]\\p{XID_Continue}*", "u"), r = [
    "and",
    "as",
    "assert",
    "async",
    "await",
    "break",
    "case",
    "class",
    "continue",
    "def",
    "del",
    "elif",
    "else",
    "except",
    "finally",
    "for",
    "from",
    "global",
    "if",
    "import",
    "in",
    "is",
    "lambda",
    "match",
    "nonlocal|10",
    "not",
    "or",
    "pass",
    "raise",
    "return",
    "try",
    "while",
    "with",
    "yield"
  ], c = {
    $pattern: /[A-Za-z]\w+|__\w+__/,
    keyword: r,
    built_in: [
      "__import__",
      "abs",
      "all",
      "any",
      "ascii",
      "bin",
      "bool",
      "breakpoint",
      "bytearray",
      "bytes",
      "callable",
      "chr",
      "classmethod",
      "compile",
      "complex",
      "delattr",
      "dict",
      "dir",
      "divmod",
      "enumerate",
      "eval",
      "exec",
      "filter",
      "float",
      "format",
      "frozenset",
      "getattr",
      "globals",
      "hasattr",
      "hash",
      "help",
      "hex",
      "id",
      "input",
      "int",
      "isinstance",
      "issubclass",
      "iter",
      "len",
      "list",
      "locals",
      "map",
      "max",
      "memoryview",
      "min",
      "next",
      "object",
      "oct",
      "open",
      "ord",
      "pow",
      "print",
      "property",
      "range",
      "repr",
      "reversed",
      "round",
      "set",
      "setattr",
      "slice",
      "sorted",
      "staticmethod",
      "str",
      "sum",
      "super",
      "tuple",
      "type",
      "vars",
      "zip"
    ],
    literal: [
      "__debug__",
      "Ellipsis",
      "False",
      "None",
      "NotImplemented",
      "True"
    ],
    type: [
      "Any",
      "Callable",
      "Coroutine",
      "Dict",
      "List",
      "Literal",
      "Generic",
      "Optional",
      "Sequence",
      "Set",
      "Tuple",
      "Type",
      "Union"
    ]
  }, a = {
    className: "meta",
    begin: /^(>>>|\.\.\.) /
  }, l = {
    className: "subst",
    begin: /\{/,
    end: /\}/,
    keywords: c,
    illegal: /#/
  }, u = {
    begin: /\{\{/,
    relevance: 0
  }, p5 = {
    className: "string",
    contains: [n.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
        end: /'''/,
        contains: [
          n.BACKSLASH_ESCAPE,
          a
        ],
        relevance: 10
      },
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
        end: /"""/,
        contains: [
          n.BACKSLASH_ESCAPE,
          a
        ],
        relevance: 10
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'''/,
        end: /'''/,
        contains: [
          n.BACKSLASH_ESCAPE,
          a,
          u,
          l
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"""/,
        end: /"""/,
        contains: [
          n.BACKSLASH_ESCAPE,
          a,
          u,
          l
        ]
      },
      {
        begin: /([uU]|[rR])'/,
        end: /'/,
        relevance: 10
      },
      {
        begin: /([uU]|[rR])"/,
        end: /"/,
        relevance: 10
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])'/,
        end: /'/
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])"/,
        end: /"/
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'/,
        end: /'/,
        contains: [
          n.BACKSLASH_ESCAPE,
          u,
          l
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"/,
        end: /"/,
        contains: [
          n.BACKSLASH_ESCAPE,
          u,
          l
        ]
      },
      n.APOS_STRING_MODE,
      n.QUOTE_STRING_MODE
    ]
  }, f = "[0-9](_?[0-9])*", h5 = `(\\b(${f}))?\\.(${f})|\\b(${f})\\.`, d = `\\b|${r.join("|")}`, g = {
    className: "number",
    relevance: 0,
    variants: [
      // exponentfloat, pointfloat
      // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals
      // optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      // Note: no leading \b because floats can start with a decimal point
      // and we don't want to mishandle e.g. `fn(.5)`,
      // no trailing \b for pointfloat because it can end with a decimal point
      // and we don't want to mishandle e.g. `0..hex()`; this should be safe
      // because both MUST contain a decimal point and so cannot be confused with
      // the interior part of an identifier
      {
        begin: `(\\b(${f})|(${h5}))[eE][+-]?(${f})[jJ]?(?=${d})`
      },
      {
        begin: `(${h5})[jJ]?`
      },
      // decinteger, bininteger, octinteger, hexinteger
      // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals
      // optionally "long" in Python 2
      // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals
      // decinteger is optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${d})`
      },
      {
        begin: `\\b0[bB](_?[01])+[lL]?(?=${d})`
      },
      {
        begin: `\\b0[oO](_?[0-7])+[lL]?(?=${d})`
      },
      {
        begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${d})`
      },
      // imagnumber (digitpart-based)
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b(${f})[jJ](?=${d})`
      }
    ]
  }, E = {
    className: "comment",
    begin: e.lookahead(/# type:/),
    end: /$/,
    keywords: c,
    contains: [
      {
        // prevent keywords from coloring `type`
        begin: /# type:/
      },
      // comment within a datatype comment includes no keywords
      {
        begin: /#/,
        end: /\b\B/,
        endsWithParent: true
      }
    ]
  }, x = {
    className: "params",
    variants: [
      // Exclude params in functions without params
      {
        className: "",
        begin: /\(\s*\)/,
        skip: true
      },
      {
        begin: /\(/,
        end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        keywords: c,
        contains: [
          "self",
          a,
          g,
          p5,
          n.HASH_COMMENT_MODE
        ]
      }
    ]
  };
  return l.contains = [
    p5,
    g,
    a
  ], {
    name: "Python",
    aliases: [
      "py",
      "gyp",
      "ipython"
    ],
    unicodeRegex: true,
    keywords: c,
    illegal: /(<\/|\?)|=>/,
    contains: [
      a,
      g,
      {
        // very common convention
        begin: /\bself\b/
      },
      {
        // eat "if" prior to string so that it won't accidentally be
        // labeled as an f-string
        beginKeywords: "if",
        relevance: 0
      },
      p5,
      E,
      n.HASH_COMMENT_MODE,
      {
        match: [
          /\bdef/,
          /\s+/,
          t
        ],
        scope: {
          1: "keyword",
          3: "title.function"
        },
        contains: [x]
      },
      {
        variants: [
          {
            match: [
              /\bclass/,
              /\s+/,
              t,
              /\s*/,
              /\(\s*/,
              t,
              /\s*\)/
            ]
          },
          {
            match: [
              /\bclass/,
              /\s+/,
              t
            ]
          }
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          6: "title.class.inherited"
        }
      },
      {
        className: "meta",
        begin: /^[\t ]*@/,
        end: /(?=#)|$/,
        contains: [
          g,
          x,
          p5
        ]
      }
    ]
  };
}
var sn = "[A-Za-z$_][0-9A-Za-z$_]*";
var qr = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
];
var Mr = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
];
var Ir = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
];
var Or = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
];
var Fr = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
];
var Br = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
];
var Pr = [].concat(
  Fr,
  Ir,
  Or
);
function bi(n) {
  const e = n.regex, t = (k, { after: R }) => {
    const F = "</" + k[0].slice(1);
    return k.input.indexOf(F, R) !== -1;
  }, r = sn, o = {
    begin: "<>",
    end: "</>"
  }, s = /<[A-Za-z0-9\\._:-]+\s*\/>/, i = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (k, R) => {
      const F = k[0].length + k.index, U = k.input[F];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        U === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        U === ","
      ) {
        R.ignoreMatch();
        return;
      }
      U === ">" && (t(k, { after: F }) || R.ignoreMatch());
      let W;
      const ne = k.input.substring(F);
      if (W = ne.match(/^\s*=/)) {
        R.ignoreMatch();
        return;
      }
      if ((W = ne.match(/^\s+extends\s+/)) && W.index === 0) {
        R.ignoreMatch();
        return;
      }
    }
  }, c = {
    $pattern: sn,
    keyword: qr,
    literal: Mr,
    built_in: Pr,
    "variable.language": Br
  }, a = "[0-9](_?[0-9])*", l = `\\.(${a})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", p5 = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${u})((${l})|\\.)?|(${l}))[eE][+-]?(${a})\\b` },
      { begin: `\\b(${u})\\b((${l})\\b|\\.)?|(${l})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, f = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: c,
    contains: []
    // defined later
  }, h5 = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "xml"
    }
  }, d = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "css"
    }
  }, g = {
    begin: "gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "graphql"
    }
  }, E = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      n.BACKSLASH_ESCAPE,
      f
    ]
  }, b = {
    className: "comment",
    variants: [
      n.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: true,
                  excludeBegin: true,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: r + "(?=\\s*(-)|$)",
                  endsParent: true,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      n.C_BLOCK_COMMENT_MODE,
      n.C_LINE_COMMENT_MODE
    ]
  }, A = [
    n.APOS_STRING_MODE,
    n.QUOTE_STRING_MODE,
    h5,
    d,
    g,
    E,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    p5
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  f.contains = A.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: c,
    contains: [
      "self"
    ].concat(A)
  });
  const D = [].concat(b, f.contains), L = D.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: c,
      contains: ["self"].concat(D)
    }
  ]), v = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: true,
    excludeEnd: true,
    keywords: c,
    contains: L
  }, O = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          r,
          /\s+/,
          /extends/,
          /\s+/,
          e.concat(r, "(", e.concat(/\./, r), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          r
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, z = {
    relevance: 0,
    match: e.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...Ir,
        ...Or
      ]
    }
  }, j = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, M = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          r,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [v],
    illegal: /%/
  }, K = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function q(k) {
    return e.concat("(?!", k.join("|"), ")");
  }
  const Z = {
    match: e.concat(
      /\b/,
      q([
        ...Fr,
        "super",
        "import"
      ]),
      r,
      e.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  }, _ = {
    begin: e.concat(/\./, e.lookahead(
      e.concat(r, /(?![0-9A-Za-z$_(])/)
    )),
    end: r,
    excludeBegin: true,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, T = {
    match: [
      /get|set/,
      /\s+/,
      r,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      v
    ]
  }, w = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + n.UNDERSCORE_IDENT_RE + ")\\s*=>", m = {
    match: [
      /const|var|let/,
      /\s+/,
      r,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      e.lookahead(w)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      v
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: c,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: L, CLASS_REFERENCE: z },
    illegal: /#(?![$_A-z])/,
    contains: [
      n.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      j,
      n.APOS_STRING_MODE,
      n.QUOTE_STRING_MODE,
      h5,
      d,
      g,
      E,
      b,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      p5,
      z,
      {
        className: "attr",
        begin: r + e.lookahead(":"),
        relevance: 0
      },
      m,
      {
        // "value" container
        begin: "(" + n.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          b,
          n.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: w,
            returnBegin: true,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: n.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: true
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: true,
                    excludeEnd: true,
                    keywords: c,
                    contains: L
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: o.begin, end: o.end },
              { match: s },
              {
                begin: i.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": i.isTrulyOpeningTag,
                end: i.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: i.begin,
                end: i.end,
                skip: true,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      M,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + n.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: true,
        label: "func.def",
        contains: [
          v,
          n.inherit(n.TITLE_MODE, { begin: r, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      _,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + r,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [v]
      },
      Z,
      K,
      O,
      T,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function vi(n) {
  const e = bi(n), t = sn, r = [
    "any",
    "void",
    "number",
    "boolean",
    "string",
    "object",
    "never",
    "symbol",
    "bigint",
    "unknown"
  ], o = {
    beginKeywords: "namespace",
    end: /\{/,
    excludeEnd: true,
    contains: [e.exports.CLASS_REFERENCE]
  }, s = {
    beginKeywords: "interface",
    end: /\{/,
    excludeEnd: true,
    keywords: {
      keyword: "interface extends",
      built_in: r
    },
    contains: [e.exports.CLASS_REFERENCE]
  }, i = {
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use strict['"]/
  }, c = [
    "type",
    "namespace",
    "interface",
    "public",
    "private",
    "protected",
    "implements",
    "declare",
    "abstract",
    "readonly",
    "enum",
    "override"
  ], a = {
    $pattern: sn,
    keyword: qr.concat(c),
    literal: Mr,
    built_in: Pr.concat(r),
    "variable.language": Br
  }, l = {
    className: "meta",
    begin: "@" + t
  }, u = (f, h5, d) => {
    const g = f.contains.findIndex((E) => E.label === h5);
    if (g === -1)
      throw new Error("can not find mode to replace");
    f.contains.splice(g, 1, d);
  };
  Object.assign(e.keywords, a), e.exports.PARAMS_CONTAINS.push(l), e.contains = e.contains.concat([
    l,
    o,
    s
  ]), u(e, "shebang", n.SHEBANG()), u(e, "use_strict", i);
  const p5 = e.contains.find((f) => f.label === "func.def");
  return p5.relevance = 0, Object.assign(e, {
    name: "TypeScript",
    aliases: [
      "ts",
      "tsx",
      "mts",
      "cts"
    ]
  }), e;
}
function ki(n, e) {
  var t, r, o = n.attrs[n.attrIndex("href")][1];
  for (t = 0; t < e.length; ++t) {
    if (r = e[t], typeof r.matcher == "function") {
      if (r.matcher(o, r))
        return r;
      continue;
    }
    return r;
  }
}
function xi(n, e, t) {
  Object.keys(t).forEach(function(r) {
    var o, s = t[r];
    r === "className" && (r = "class"), o = e[n].attrIndex(r), o < 0 ? e[n].attrPush([r, s]) : e[n].attrs[o][1] = s;
  });
}
function $r(n, e) {
  e ? e = Array.isArray(e) ? e : [e] : e = [], Object.freeze(e);
  var t = n.renderer.rules.link_open || this.defaultRender;
  n.renderer.rules.link_open = function(r, o, s, i, c) {
    var a = ki(r[o], e), l = a && a.attrs;
    return l && xi(o, r, l), t(r, o, s, i, c);
  };
}
$r.defaultRender = function(n, e, t, r, o) {
  return o.renderToken(n, e, t);
};
var yi = $r;
var Ei = Gn(yi);
var $ = {};
var wi = "Á";
var Ai = "á";
var Ci = "Ă";
var Si = "ă";
var Di = "∾";
var Ti = "∿";
var Ri = "∾̳";
var Li = "Â";
var Ni = "â";
var qi = "´";
var Mi = "А";
var Ii = "а";
var Oi = "Æ";
var Fi = "æ";
var Bi = "⁡";
var Pi = "𝔄";
var $i = "𝔞";
var zi = "À";
var Ui = "à";
var Hi = "ℵ";
var Vi = "ℵ";
var Gi = "Α";
var ji = "α";
var Zi = "Ā";
var Ki = "ā";
var Wi = "⨿";
var Yi = "&";
var Ji = "&";
var Xi = "⩕";
var Qi = "⩓";
var ea = "∧";
var na = "⩜";
var ta = "⩘";
var ra = "⩚";
var oa = "∠";
var sa = "⦤";
var ca = "∠";
var ia = "⦨";
var aa = "⦩";
var la = "⦪";
var ua = "⦫";
var fa = "⦬";
var pa = "⦭";
var ha = "⦮";
var da = "⦯";
var ga = "∡";
var ma = "∟";
var _a = "⊾";
var ba = "⦝";
var va = "∢";
var ka = "Å";
var xa = "⍼";
var ya = "Ą";
var Ea = "ą";
var wa = "𝔸";
var Aa = "𝕒";
var Ca = "⩯";
var Sa = "≈";
var Da = "⩰";
var Ta = "≊";
var Ra = "≋";
var La = "'";
var Na = "⁡";
var qa = "≈";
var Ma = "≊";
var Ia = "Å";
var Oa = "å";
var Fa = "𝒜";
var Ba = "𝒶";
var Pa = "≔";
var $a = "*";
var za = "≈";
var Ua = "≍";
var Ha = "Ã";
var Va = "ã";
var Ga = "Ä";
var ja = "ä";
var Za = "∳";
var Ka = "⨑";
var Wa = "≌";
var Ya = "϶";
var Ja = "‵";
var Xa = "∽";
var Qa = "⋍";
var el = "∖";
var nl = "⫧";
var tl = "⊽";
var rl = "⌅";
var ol = "⌆";
var sl = "⌅";
var cl = "⎵";
var il = "⎶";
var al = "≌";
var ll = "Б";
var ul = "б";
var fl = "„";
var pl = "∵";
var hl = "∵";
var dl = "∵";
var gl = "⦰";
var ml = "϶";
var _l = "ℬ";
var bl = "ℬ";
var vl = "Β";
var kl = "β";
var xl = "ℶ";
var yl = "≬";
var El = "𝔅";
var wl = "𝔟";
var Al = "⋂";
var Cl = "◯";
var Sl = "⋃";
var Dl = "⨀";
var Tl = "⨁";
var Rl = "⨂";
var Ll = "⨆";
var Nl = "★";
var ql = "▽";
var Ml = "△";
var Il = "⨄";
var Ol = "⋁";
var Fl = "⋀";
var Bl = "⤍";
var Pl = "⧫";
var $l = "▪";
var zl = "▴";
var Ul = "▾";
var Hl = "◂";
var Vl = "▸";
var Gl = "␣";
var jl = "▒";
var Zl = "░";
var Kl = "▓";
var Wl = "█";
var Yl = "=⃥";
var Jl = "≡⃥";
var Xl = "⫭";
var Ql = "⌐";
var eu = "𝔹";
var nu = "𝕓";
var tu = "⊥";
var ru = "⊥";
var ou = "⋈";
var su = "⧉";
var cu = "┐";
var iu = "╕";
var au = "╖";
var lu = "╗";
var uu = "┌";
var fu = "╒";
var pu = "╓";
var hu = "╔";
var du = "─";
var gu = "═";
var mu = "┬";
var _u = "╤";
var bu = "╥";
var vu = "╦";
var ku = "┴";
var xu = "╧";
var yu = "╨";
var Eu = "╩";
var wu = "⊟";
var Au = "⊞";
var Cu = "⊠";
var Su = "┘";
var Du = "╛";
var Tu = "╜";
var Ru = "╝";
var Lu = "└";
var Nu = "╘";
var qu = "╙";
var Mu = "╚";
var Iu = "│";
var Ou = "║";
var Fu = "┼";
var Bu = "╪";
var Pu = "╫";
var $u = "╬";
var zu = "┤";
var Uu = "╡";
var Hu = "╢";
var Vu = "╣";
var Gu = "├";
var ju = "╞";
var Zu = "╟";
var Ku = "╠";
var Wu = "‵";
var Yu = "˘";
var Ju = "˘";
var Xu = "¦";
var Qu = "𝒷";
var ef = "ℬ";
var nf = "⁏";
var tf = "∽";
var rf = "⋍";
var of = "⧅";
var sf = "\\";
var cf = "⟈";
var af = "•";
var lf = "•";
var uf = "≎";
var ff = "⪮";
var pf = "≏";
var hf = "≎";
var df = "≏";
var gf = "Ć";
var mf = "ć";
var _f = "⩄";
var bf = "⩉";
var vf = "⩋";
var kf = "∩";
var xf = "⋒";
var yf = "⩇";
var Ef = "⩀";
var wf = "ⅅ";
var Af = "∩︀";
var Cf = "⁁";
var Sf = "ˇ";
var Df = "ℭ";
var Tf = "⩍";
var Rf = "Č";
var Lf = "č";
var Nf = "Ç";
var qf = "ç";
var Mf = "Ĉ";
var If = "ĉ";
var Of = "∰";
var Ff = "⩌";
var Bf = "⩐";
var Pf = "Ċ";
var $f = "ċ";
var zf = "¸";
var Uf = "¸";
var Hf = "⦲";
var Vf = "¢";
var Gf = "·";
var jf = "·";
var Zf = "𝔠";
var Kf = "ℭ";
var Wf = "Ч";
var Yf = "ч";
var Jf = "✓";
var Xf = "✓";
var Qf = "Χ";
var ep = "χ";
var np = "ˆ";
var tp = "≗";
var rp = "↺";
var op = "↻";
var sp = "⊛";
var cp = "⊚";
var ip = "⊝";
var ap = "⊙";
var lp = "®";
var up = "Ⓢ";
var fp = "⊖";
var pp = "⊕";
var hp = "⊗";
var dp = "○";
var gp = "⧃";
var mp = "≗";
var _p = "⨐";
var bp = "⫯";
var vp = "⧂";
var kp = "∲";
var xp = "”";
var yp = "’";
var Ep = "♣";
var wp = "♣";
var Ap = ":";
var Cp = "∷";
var Sp = "⩴";
var Dp = "≔";
var Tp = "≔";
var Rp = ",";
var Lp = "@";
var Np = "∁";
var qp = "∘";
var Mp = "∁";
var Ip = "ℂ";
var Op = "≅";
var Fp = "⩭";
var Bp = "≡";
var Pp = "∮";
var $p = "∯";
var zp = "∮";
var Up = "𝕔";
var Hp = "ℂ";
var Vp = "∐";
var Gp = "∐";
var jp = "©";
var Zp = "©";
var Kp = "℗";
var Wp = "∳";
var Yp = "↵";
var Jp = "✗";
var Xp = "⨯";
var Qp = "𝒞";
var eh = "𝒸";
var nh = "⫏";
var th = "⫑";
var rh = "⫐";
var oh = "⫒";
var sh = "⋯";
var ch = "⤸";
var ih = "⤵";
var ah = "⋞";
var lh = "⋟";
var uh = "↶";
var fh = "⤽";
var ph = "⩈";
var hh = "⩆";
var dh = "≍";
var gh = "∪";
var mh = "⋓";
var _h = "⩊";
var bh = "⊍";
var vh = "⩅";
var kh = "∪︀";
var xh = "↷";
var yh = "⤼";
var Eh = "⋞";
var wh = "⋟";
var Ah = "⋎";
var Ch = "⋏";
var Sh = "¤";
var Dh = "↶";
var Th = "↷";
var Rh = "⋎";
var Lh = "⋏";
var Nh = "∲";
var qh = "∱";
var Mh = "⌭";
var Ih = "†";
var Oh = "‡";
var Fh = "ℸ";
var Bh = "↓";
var Ph = "↡";
var $h = "⇓";
var zh = "‐";
var Uh = "⫤";
var Hh = "⊣";
var Vh = "⤏";
var Gh = "˝";
var jh = "Ď";
var Zh = "ď";
var Kh = "Д";
var Wh = "д";
var Yh = "‡";
var Jh = "⇊";
var Xh = "ⅅ";
var Qh = "ⅆ";
var ed = "⤑";
var nd = "⩷";
var td = "°";
var rd = "∇";
var od = "Δ";
var sd = "δ";
var cd = "⦱";
var id = "⥿";
var ad = "𝔇";
var ld = "𝔡";
var ud = "⥥";
var fd = "⇃";
var pd = "⇂";
var hd = "´";
var dd = "˙";
var gd = "˝";
var md = "`";
var _d = "˜";
var bd = "⋄";
var vd = "⋄";
var kd = "⋄";
var xd = "♦";
var yd = "♦";
var Ed = "¨";
var wd = "ⅆ";
var Ad = "ϝ";
var Cd = "⋲";
var Sd = "÷";
var Dd = "÷";
var Td = "⋇";
var Rd = "⋇";
var Ld = "Ђ";
var Nd = "ђ";
var qd = "⌞";
var Md = "⌍";
var Id = "$";
var Od = "𝔻";
var Fd = "𝕕";
var Bd = "¨";
var Pd = "˙";
var $d = "⃜";
var zd = "≐";
var Ud = "≑";
var Hd = "≐";
var Vd = "∸";
var Gd = "∔";
var jd = "⊡";
var Zd = "⌆";
var Kd = "∯";
var Wd = "¨";
var Yd = "⇓";
var Jd = "⇐";
var Xd = "⇔";
var Qd = "⫤";
var eg = "⟸";
var ng = "⟺";
var tg = "⟹";
var rg = "⇒";
var og = "⊨";
var sg = "⇑";
var cg = "⇕";
var ig = "∥";
var ag = "⤓";
var lg = "↓";
var ug = "↓";
var fg = "⇓";
var pg = "⇵";
var hg = "̑";
var dg = "⇊";
var gg = "⇃";
var mg = "⇂";
var _g = "⥐";
var bg = "⥞";
var vg = "⥖";
var kg = "↽";
var xg = "⥟";
var yg = "⥗";
var Eg = "⇁";
var wg = "↧";
var Ag = "⊤";
var Cg = "⤐";
var Sg = "⌟";
var Dg = "⌌";
var Tg = "𝒟";
var Rg = "𝒹";
var Lg = "Ѕ";
var Ng = "ѕ";
var qg = "⧶";
var Mg = "Đ";
var Ig = "đ";
var Og = "⋱";
var Fg = "▿";
var Bg = "▾";
var Pg = "⇵";
var $g = "⥯";
var zg = "⦦";
var Ug = "Џ";
var Hg = "џ";
var Vg = "⟿";
var Gg = "É";
var jg = "é";
var Zg = "⩮";
var Kg = "Ě";
var Wg = "ě";
var Yg = "Ê";
var Jg = "ê";
var Xg = "≖";
var Qg = "≕";
var em = "Э";
var nm = "э";
var tm = "⩷";
var rm = "Ė";
var om = "ė";
var sm = "≑";
var cm = "ⅇ";
var im = "≒";
var am = "𝔈";
var lm = "𝔢";
var um = "⪚";
var fm = "È";
var pm = "è";
var hm = "⪖";
var dm = "⪘";
var gm = "⪙";
var mm = "∈";
var _m = "⏧";
var bm = "ℓ";
var vm = "⪕";
var km = "⪗";
var xm = "Ē";
var ym = "ē";
var Em = "∅";
var wm = "∅";
var Am = "◻";
var Cm = "∅";
var Sm = "▫";
var Dm = " ";
var Tm = " ";
var Rm = " ";
var Lm = "Ŋ";
var Nm = "ŋ";
var qm = " ";
var Mm = "Ę";
var Im = "ę";
var Om = "𝔼";
var Fm = "𝕖";
var Bm = "⋕";
var Pm = "⧣";
var $m = "⩱";
var zm = "ε";
var Um = "Ε";
var Hm = "ε";
var Vm = "ϵ";
var Gm = "≖";
var jm = "≕";
var Zm = "≂";
var Km = "⪖";
var Wm = "⪕";
var Ym = "⩵";
var Jm = "=";
var Xm = "≂";
var Qm = "≟";
var e_ = "⇌";
var n_ = "≡";
var t_ = "⩸";
var r_ = "⧥";
var o_ = "⥱";
var s_ = "≓";
var c_ = "ℯ";
var i_ = "ℰ";
var a_ = "≐";
var l_ = "⩳";
var u_ = "≂";
var f_ = "Η";
var p_ = "η";
var h_ = "Ð";
var d_ = "ð";
var g_ = "Ë";
var m_ = "ë";
var __ = "€";
var b_ = "!";
var v_ = "∃";
var k_ = "∃";
var x_ = "ℰ";
var y_ = "ⅇ";
var E_ = "ⅇ";
var w_ = "≒";
var A_ = "Ф";
var C_ = "ф";
var S_ = "♀";
var D_ = "ﬃ";
var T_ = "ﬀ";
var R_ = "ﬄ";
var L_ = "𝔉";
var N_ = "𝔣";
var q_ = "ﬁ";
var M_ = "◼";
var I_ = "▪";
var O_ = "fj";
var F_ = "♭";
var B_ = "ﬂ";
var P_ = "▱";
var $_ = "ƒ";
var z_ = "𝔽";
var U_ = "𝕗";
var H_ = "∀";
var V_ = "∀";
var G_ = "⋔";
var j_ = "⫙";
var Z_ = "ℱ";
var K_ = "⨍";
var W_ = "½";
var Y_ = "⅓";
var J_ = "¼";
var X_ = "⅕";
var Q_ = "⅙";
var eb = "⅛";
var nb = "⅔";
var tb = "⅖";
var rb = "¾";
var ob = "⅗";
var sb = "⅜";
var cb = "⅘";
var ib = "⅚";
var ab = "⅝";
var lb = "⅞";
var ub = "⁄";
var fb = "⌢";
var pb = "𝒻";
var hb = "ℱ";
var db = "ǵ";
var gb = "Γ";
var mb = "γ";
var _b = "Ϝ";
var bb = "ϝ";
var vb = "⪆";
var kb = "Ğ";
var xb = "ğ";
var yb = "Ģ";
var Eb = "Ĝ";
var wb = "ĝ";
var Ab = "Г";
var Cb = "г";
var Sb = "Ġ";
var Db = "ġ";
var Tb = "≥";
var Rb = "≧";
var Lb = "⪌";
var Nb = "⋛";
var qb = "≥";
var Mb = "≧";
var Ib = "⩾";
var Ob = "⪩";
var Fb = "⩾";
var Bb = "⪀";
var Pb = "⪂";
var $b = "⪄";
var zb = "⋛︀";
var Ub = "⪔";
var Hb = "𝔊";
var Vb = "𝔤";
var Gb = "≫";
var jb = "⋙";
var Zb = "⋙";
var Kb = "ℷ";
var Wb = "Ѓ";
var Yb = "ѓ";
var Jb = "⪥";
var Xb = "≷";
var Qb = "⪒";
var e0 = "⪤";
var n0 = "⪊";
var t0 = "⪊";
var r0 = "⪈";
var o0 = "≩";
var s0 = "⪈";
var c0 = "≩";
var i0 = "⋧";
var a0 = "𝔾";
var l0 = "𝕘";
var u0 = "`";
var f0 = "≥";
var p0 = "⋛";
var h0 = "≧";
var d0 = "⪢";
var g0 = "≷";
var m0 = "⩾";
var _0 = "≳";
var b0 = "𝒢";
var v0 = "ℊ";
var k0 = "≳";
var x0 = "⪎";
var y0 = "⪐";
var E0 = "⪧";
var w0 = "⩺";
var A0 = ">";
var C0 = ">";
var S0 = "≫";
var D0 = "⋗";
var T0 = "⦕";
var R0 = "⩼";
var L0 = "⪆";
var N0 = "⥸";
var q0 = "⋗";
var M0 = "⋛";
var I0 = "⪌";
var O0 = "≷";
var F0 = "≳";
var B0 = "≩︀";
var P0 = "≩︀";
var $0 = "ˇ";
var z0 = " ";
var U0 = "½";
var H0 = "ℋ";
var V0 = "Ъ";
var G0 = "ъ";
var j0 = "⥈";
var Z0 = "↔";
var K0 = "⇔";
var W0 = "↭";
var Y0 = "^";
var J0 = "ℏ";
var X0 = "Ĥ";
var Q0 = "ĥ";
var ev = "♥";
var nv = "♥";
var tv = "…";
var rv = "⊹";
var ov = "𝔥";
var sv = "ℌ";
var cv = "ℋ";
var iv = "⤥";
var av = "⤦";
var lv = "⇿";
var uv = "∻";
var fv = "↩";
var pv = "↪";
var hv = "𝕙";
var dv = "ℍ";
var gv = "―";
var mv = "─";
var _v = "𝒽";
var bv = "ℋ";
var vv = "ℏ";
var kv = "Ħ";
var xv = "ħ";
var yv = "≎";
var Ev = "≏";
var wv = "⁃";
var Av = "‐";
var Cv = "Í";
var Sv = "í";
var Dv = "⁣";
var Tv = "Î";
var Rv = "î";
var Lv = "И";
var Nv = "и";
var qv = "İ";
var Mv = "Е";
var Iv = "е";
var Ov = "¡";
var Fv = "⇔";
var Bv = "𝔦";
var Pv = "ℑ";
var $v = "Ì";
var zv = "ì";
var Uv = "ⅈ";
var Hv = "⨌";
var Vv = "∭";
var Gv = "⧜";
var jv = "℩";
var Zv = "Ĳ";
var Kv = "ĳ";
var Wv = "Ī";
var Yv = "ī";
var Jv = "ℑ";
var Xv = "ⅈ";
var Qv = "ℐ";
var ek = "ℑ";
var nk = "ı";
var tk = "ℑ";
var rk = "⊷";
var ok = "Ƶ";
var sk = "⇒";
var ck = "℅";
var ik = "∞";
var ak = "⧝";
var lk = "ı";
var uk = "⊺";
var fk = "∫";
var pk = "∬";
var hk = "ℤ";
var dk = "∫";
var gk = "⊺";
var mk = "⋂";
var _k = "⨗";
var bk = "⨼";
var vk = "⁣";
var kk = "⁢";
var xk = "Ё";
var yk = "ё";
var Ek = "Į";
var wk = "į";
var Ak = "𝕀";
var Ck = "𝕚";
var Sk = "Ι";
var Dk = "ι";
var Tk = "⨼";
var Rk = "¿";
var Lk = "𝒾";
var Nk = "ℐ";
var qk = "∈";
var Mk = "⋵";
var Ik = "⋹";
var Ok = "⋴";
var Fk = "⋳";
var Bk = "∈";
var Pk = "⁢";
var $k = "Ĩ";
var zk = "ĩ";
var Uk = "І";
var Hk = "і";
var Vk = "Ï";
var Gk = "ï";
var jk = "Ĵ";
var Zk = "ĵ";
var Kk = "Й";
var Wk = "й";
var Yk = "𝔍";
var Jk = "𝔧";
var Xk = "ȷ";
var Qk = "𝕁";
var ex = "𝕛";
var nx = "𝒥";
var tx = "𝒿";
var rx = "Ј";
var ox = "ј";
var sx = "Є";
var cx = "є";
var ix = "Κ";
var ax = "κ";
var lx = "ϰ";
var ux = "Ķ";
var fx = "ķ";
var px = "К";
var hx = "к";
var dx = "𝔎";
var gx = "𝔨";
var mx = "ĸ";
var _x = "Х";
var bx = "х";
var vx = "Ќ";
var kx = "ќ";
var xx = "𝕂";
var yx = "𝕜";
var Ex = "𝒦";
var wx = "𝓀";
var Ax = "⇚";
var Cx = "Ĺ";
var Sx = "ĺ";
var Dx = "⦴";
var Tx = "ℒ";
var Rx = "Λ";
var Lx = "λ";
var Nx = "⟨";
var qx = "⟪";
var Mx = "⦑";
var Ix = "⟨";
var Ox = "⪅";
var Fx = "ℒ";
var Bx = "«";
var Px = "⇤";
var $x = "⤟";
var zx = "←";
var Ux = "↞";
var Hx = "⇐";
var Vx = "⤝";
var Gx = "↩";
var jx = "↫";
var Zx = "⤹";
var Kx = "⥳";
var Wx = "↢";
var Yx = "⤙";
var Jx = "⤛";
var Xx = "⪫";
var Qx = "⪭";
var ey = "⪭︀";
var ny = "⤌";
var ty = "⤎";
var ry = "❲";
var oy = "{";
var sy = "[";
var cy = "⦋";
var iy = "⦏";
var ay = "⦍";
var ly = "Ľ";
var uy = "ľ";
var fy = "Ļ";
var py = "ļ";
var hy = "⌈";
var dy = "{";
var gy = "Л";
var my = "л";
var _y = "⤶";
var by = "“";
var vy = "„";
var ky = "⥧";
var xy = "⥋";
var yy = "↲";
var Ey = "≤";
var wy = "≦";
var Ay = "⟨";
var Cy = "⇤";
var Sy = "←";
var Dy = "←";
var Ty = "⇐";
var Ry = "⇆";
var Ly = "↢";
var Ny = "⌈";
var qy = "⟦";
var My = "⥡";
var Iy = "⥙";
var Oy = "⇃";
var Fy = "⌊";
var By = "↽";
var Py = "↼";
var $y = "⇇";
var zy = "↔";
var Uy = "↔";
var Hy = "⇔";
var Vy = "⇆";
var Gy = "⇋";
var jy = "↭";
var Zy = "⥎";
var Ky = "↤";
var Wy = "⊣";
var Yy = "⥚";
var Jy = "⋋";
var Xy = "⧏";
var Qy = "⊲";
var eE = "⊴";
var nE = "⥑";
var tE = "⥠";
var rE = "⥘";
var oE = "↿";
var sE = "⥒";
var cE = "↼";
var iE = "⪋";
var aE = "⋚";
var lE = "≤";
var uE = "≦";
var fE = "⩽";
var pE = "⪨";
var hE = "⩽";
var dE = "⩿";
var gE = "⪁";
var mE = "⪃";
var _E = "⋚︀";
var bE = "⪓";
var vE = "⪅";
var kE = "⋖";
var xE = "⋚";
var yE = "⪋";
var EE = "⋚";
var wE = "≦";
var AE = "≶";
var CE = "≶";
var SE = "⪡";
var DE = "≲";
var TE = "⩽";
var RE = "≲";
var LE = "⥼";
var NE = "⌊";
var qE = "𝔏";
var ME = "𝔩";
var IE = "≶";
var OE = "⪑";
var FE = "⥢";
var BE = "↽";
var PE = "↼";
var $E = "⥪";
var zE = "▄";
var UE = "Љ";
var HE = "љ";
var VE = "⇇";
var GE = "≪";
var jE = "⋘";
var ZE = "⌞";
var KE = "⇚";
var WE = "⥫";
var YE = "◺";
var JE = "Ŀ";
var XE = "ŀ";
var QE = "⎰";
var ew = "⎰";
var nw = "⪉";
var tw = "⪉";
var rw = "⪇";
var ow = "≨";
var sw = "⪇";
var cw = "≨";
var iw = "⋦";
var aw = "⟬";
var lw = "⇽";
var uw = "⟦";
var fw = "⟵";
var pw = "⟵";
var hw = "⟸";
var dw = "⟷";
var gw = "⟷";
var mw = "⟺";
var _w = "⟼";
var bw = "⟶";
var vw = "⟶";
var kw = "⟹";
var xw = "↫";
var yw = "↬";
var Ew = "⦅";
var ww = "𝕃";
var Aw = "𝕝";
var Cw = "⨭";
var Sw = "⨴";
var Dw = "∗";
var Tw = "_";
var Rw = "↙";
var Lw = "↘";
var Nw = "◊";
var qw = "◊";
var Mw = "⧫";
var Iw = "(";
var Ow = "⦓";
var Fw = "⇆";
var Bw = "⌟";
var Pw = "⇋";
var $w = "⥭";
var zw = "‎";
var Uw = "⊿";
var Hw = "‹";
var Vw = "𝓁";
var Gw = "ℒ";
var jw = "↰";
var Zw = "↰";
var Kw = "≲";
var Ww = "⪍";
var Yw = "⪏";
var Jw = "[";
var Xw = "‘";
var Qw = "‚";
var e1 = "Ł";
var n1 = "ł";
var t1 = "⪦";
var r1 = "⩹";
var o1 = "<";
var s1 = "<";
var c1 = "≪";
var i1 = "⋖";
var a1 = "⋋";
var l1 = "⋉";
var u1 = "⥶";
var f1 = "⩻";
var p1 = "◃";
var h1 = "⊴";
var d1 = "◂";
var g1 = "⦖";
var m1 = "⥊";
var _1 = "⥦";
var b1 = "≨︀";
var v1 = "≨︀";
var k1 = "¯";
var x1 = "♂";
var y1 = "✠";
var E1 = "✠";
var w1 = "↦";
var A1 = "↦";
var C1 = "↧";
var S1 = "↤";
var D1 = "↥";
var T1 = "▮";
var R1 = "⨩";
var L1 = "М";
var N1 = "м";
var q1 = "—";
var M1 = "∺";
var I1 = "∡";
var O1 = " ";
var F1 = "ℳ";
var B1 = "𝔐";
var P1 = "𝔪";
var $1 = "℧";
var z1 = "µ";
var U1 = "*";
var H1 = "⫰";
var V1 = "∣";
var G1 = "·";
var j1 = "⊟";
var Z1 = "−";
var K1 = "∸";
var W1 = "⨪";
var Y1 = "∓";
var J1 = "⫛";
var X1 = "…";
var Q1 = "∓";
var eA = "⊧";
var nA = "𝕄";
var tA = "𝕞";
var rA = "∓";
var oA = "𝓂";
var sA = "ℳ";
var cA = "∾";
var iA = "Μ";
var aA = "μ";
var lA = "⊸";
var uA = "⊸";
var fA = "∇";
var pA = "Ń";
var hA = "ń";
var dA = "∠⃒";
var gA = "≉";
var mA = "⩰̸";
var _A = "≋̸";
var bA = "ŉ";
var vA = "≉";
var kA = "♮";
var xA = "ℕ";
var yA = "♮";
var EA = " ";
var wA = "≎̸";
var AA = "≏̸";
var CA = "⩃";
var SA = "Ň";
var DA = "ň";
var TA = "Ņ";
var RA = "ņ";
var LA = "≇";
var NA = "⩭̸";
var qA = "⩂";
var MA = "Н";
var IA = "н";
var OA = "–";
var FA = "⤤";
var BA = "↗";
var PA = "⇗";
var $A = "↗";
var zA = "≠";
var UA = "≐̸";
var HA = "​";
var VA = "​";
var GA = "​";
var jA = "​";
var ZA = "≢";
var KA = "⤨";
var WA = "≂̸";
var YA = "≫";
var JA = "≪";
var XA = `
`;
var QA = "∄";
var eC = "∄";
var nC = "𝔑";
var tC = "𝔫";
var rC = "≧̸";
var oC = "≱";
var sC = "≱";
var cC = "≧̸";
var iC = "⩾̸";
var aC = "⩾̸";
var lC = "⋙̸";
var uC = "≵";
var fC = "≫⃒";
var pC = "≯";
var hC = "≯";
var dC = "≫̸";
var gC = "↮";
var mC = "⇎";
var _C = "⫲";
var bC = "∋";
var vC = "⋼";
var kC = "⋺";
var xC = "∋";
var yC = "Њ";
var EC = "њ";
var wC = "↚";
var AC = "⇍";
var CC = "‥";
var SC = "≦̸";
var DC = "≰";
var TC = "↚";
var RC = "⇍";
var LC = "↮";
var NC = "⇎";
var qC = "≰";
var MC = "≦̸";
var IC = "⩽̸";
var OC = "⩽̸";
var FC = "≮";
var BC = "⋘̸";
var PC = "≴";
var $C = "≪⃒";
var zC = "≮";
var UC = "⋪";
var HC = "⋬";
var VC = "≪̸";
var GC = "∤";
var jC = "⁠";
var ZC = " ";
var KC = "𝕟";
var WC = "ℕ";
var YC = "⫬";
var JC = "¬";
var XC = "≢";
var QC = "≭";
var eS = "∦";
var nS = "∉";
var tS = "≠";
var rS = "≂̸";
var oS = "∄";
var sS = "≯";
var cS = "≱";
var iS = "≧̸";
var aS = "≫̸";
var lS = "≹";
var uS = "⩾̸";
var fS = "≵";
var pS = "≎̸";
var hS = "≏̸";
var dS = "∉";
var gS = "⋵̸";
var mS = "⋹̸";
var _S = "∉";
var bS = "⋷";
var vS = "⋶";
var kS = "⧏̸";
var xS = "⋪";
var yS = "⋬";
var ES = "≮";
var wS = "≰";
var AS = "≸";
var CS = "≪̸";
var SS = "⩽̸";
var DS = "≴";
var TS = "⪢̸";
var RS = "⪡̸";
var LS = "∌";
var NS = "∌";
var qS = "⋾";
var MS = "⋽";
var IS = "⊀";
var OS = "⪯̸";
var FS = "⋠";
var BS = "∌";
var PS = "⧐̸";
var $S = "⋫";
var zS = "⋭";
var US = "⊏̸";
var HS = "⋢";
var VS = "⊐̸";
var GS = "⋣";
var jS = "⊂⃒";
var ZS = "⊈";
var KS = "⊁";
var WS = "⪰̸";
var YS = "⋡";
var JS = "≿̸";
var XS = "⊃⃒";
var QS = "⊉";
var eD = "≁";
var nD = "≄";
var tD = "≇";
var rD = "≉";
var oD = "∤";
var sD = "∦";
var cD = "∦";
var iD = "⫽⃥";
var aD = "∂̸";
var lD = "⨔";
var uD = "⊀";
var fD = "⋠";
var pD = "⊀";
var hD = "⪯̸";
var dD = "⪯̸";
var gD = "⤳̸";
var mD = "↛";
var _D = "⇏";
var bD = "↝̸";
var vD = "↛";
var kD = "⇏";
var xD = "⋫";
var yD = "⋭";
var ED = "⊁";
var wD = "⋡";
var AD = "⪰̸";
var CD = "𝒩";
var SD = "𝓃";
var DD = "∤";
var TD = "∦";
var RD = "≁";
var LD = "≄";
var ND = "≄";
var qD = "∤";
var MD = "∦";
var ID = "⋢";
var OD = "⋣";
var FD = "⊄";
var BD = "⫅̸";
var PD = "⊈";
var $D = "⊂⃒";
var zD = "⊈";
var UD = "⫅̸";
var HD = "⊁";
var VD = "⪰̸";
var GD = "⊅";
var jD = "⫆̸";
var ZD = "⊉";
var KD = "⊃⃒";
var WD = "⊉";
var YD = "⫆̸";
var JD = "≹";
var XD = "Ñ";
var QD = "ñ";
var eT = "≸";
var nT = "⋪";
var tT = "⋬";
var rT = "⋫";
var oT = "⋭";
var sT = "Ν";
var cT = "ν";
var iT = "#";
var aT = "№";
var lT = " ";
var uT = "≍⃒";
var fT = "⊬";
var pT = "⊭";
var hT = "⊮";
var dT = "⊯";
var gT = "≥⃒";
var mT = ">⃒";
var _T = "⤄";
var bT = "⧞";
var vT = "⤂";
var kT = "≤⃒";
var xT = "<⃒";
var yT = "⊴⃒";
var ET = "⤃";
var wT = "⊵⃒";
var AT = "∼⃒";
var CT = "⤣";
var ST = "↖";
var DT = "⇖";
var TT = "↖";
var RT = "⤧";
var LT = "Ó";
var NT = "ó";
var qT = "⊛";
var MT = "Ô";
var IT = "ô";
var OT = "⊚";
var FT = "О";
var BT = "о";
var PT = "⊝";
var $T = "Ő";
var zT = "ő";
var UT = "⨸";
var HT = "⊙";
var VT = "⦼";
var GT = "Œ";
var jT = "œ";
var ZT = "⦿";
var KT = "𝔒";
var WT = "𝔬";
var YT = "˛";
var JT = "Ò";
var XT = "ò";
var QT = "⧁";
var eR = "⦵";
var nR = "Ω";
var tR = "∮";
var rR = "↺";
var oR = "⦾";
var sR = "⦻";
var cR = "‾";
var iR = "⧀";
var aR = "Ō";
var lR = "ō";
var uR = "Ω";
var fR = "ω";
var pR = "Ο";
var hR = "ο";
var dR = "⦶";
var gR = "⊖";
var mR = "𝕆";
var _R = "𝕠";
var bR = "⦷";
var vR = "“";
var kR = "‘";
var xR = "⦹";
var yR = "⊕";
var ER = "↻";
var wR = "⩔";
var AR = "∨";
var CR = "⩝";
var SR = "ℴ";
var DR = "ℴ";
var TR = "ª";
var RR = "º";
var LR = "⊶";
var NR = "⩖";
var qR = "⩗";
var MR = "⩛";
var IR = "Ⓢ";
var OR = "𝒪";
var FR = "ℴ";
var BR = "Ø";
var PR = "ø";
var $R = "⊘";
var zR = "Õ";
var UR = "õ";
var HR = "⨶";
var VR = "⨷";
var GR = "⊗";
var jR = "Ö";
var ZR = "ö";
var KR = "⌽";
var WR = "‾";
var YR = "⏞";
var JR = "⎴";
var XR = "⏜";
var QR = "¶";
var e2 = "∥";
var n2 = "∥";
var t2 = "⫳";
var r2 = "⫽";
var o2 = "∂";
var s2 = "∂";
var c2 = "П";
var i2 = "п";
var a2 = "%";
var l2 = ".";
var u2 = "‰";
var f2 = "⊥";
var p2 = "‱";
var h2 = "𝔓";
var d2 = "𝔭";
var g2 = "Φ";
var m2 = "φ";
var _2 = "ϕ";
var b2 = "ℳ";
var v2 = "☎";
var k2 = "Π";
var x2 = "π";
var y2 = "⋔";
var E2 = "ϖ";
var w2 = "ℏ";
var A2 = "ℎ";
var C2 = "ℏ";
var S2 = "⨣";
var D2 = "⊞";
var T2 = "⨢";
var R2 = "+";
var L2 = "∔";
var N2 = "⨥";
var q2 = "⩲";
var M2 = "±";
var I2 = "±";
var O2 = "⨦";
var F2 = "⨧";
var B2 = "±";
var P2 = "ℌ";
var $2 = "⨕";
var z2 = "𝕡";
var U2 = "ℙ";
var H2 = "£";
var V2 = "⪷";
var G2 = "⪻";
var j2 = "≺";
var Z2 = "≼";
var K2 = "⪷";
var W2 = "≺";
var Y2 = "≼";
var J2 = "≺";
var X2 = "⪯";
var Q2 = "≼";
var eL = "≾";
var nL = "⪯";
var tL = "⪹";
var rL = "⪵";
var oL = "⋨";
var sL = "⪯";
var cL = "⪳";
var iL = "≾";
var aL = "′";
var lL = "″";
var uL = "ℙ";
var fL = "⪹";
var pL = "⪵";
var hL = "⋨";
var dL = "∏";
var gL = "∏";
var mL = "⌮";
var _L = "⌒";
var bL = "⌓";
var vL = "∝";
var kL = "∝";
var xL = "∷";
var yL = "∝";
var EL = "≾";
var wL = "⊰";
var AL = "𝒫";
var CL = "𝓅";
var SL = "Ψ";
var DL = "ψ";
var TL = " ";
var RL = "𝔔";
var LL = "𝔮";
var NL = "⨌";
var qL = "𝕢";
var ML = "ℚ";
var IL = "⁗";
var OL = "𝒬";
var FL = "𝓆";
var BL = "ℍ";
var PL = "⨖";
var $L = "?";
var zL = "≟";
var UL = '"';
var HL = '"';
var VL = "⇛";
var GL = "∽̱";
var jL = "Ŕ";
var ZL = "ŕ";
var KL = "√";
var WL = "⦳";
var YL = "⟩";
var JL = "⟫";
var XL = "⦒";
var QL = "⦥";
var eN = "⟩";
var nN = "»";
var tN = "⥵";
var rN = "⇥";
var oN = "⤠";
var sN = "⤳";
var cN = "→";
var iN = "↠";
var aN = "⇒";
var lN = "⤞";
var uN = "↪";
var fN = "↬";
var pN = "⥅";
var hN = "⥴";
var dN = "⤖";
var gN = "↣";
var mN = "↝";
var _N = "⤚";
var bN = "⤜";
var vN = "∶";
var kN = "ℚ";
var xN = "⤍";
var yN = "⤏";
var EN = "⤐";
var wN = "❳";
var AN = "}";
var CN = "]";
var SN = "⦌";
var DN = "⦎";
var TN = "⦐";
var RN = "Ř";
var LN = "ř";
var NN = "Ŗ";
var qN = "ŗ";
var MN = "⌉";
var IN = "}";
var ON = "Р";
var FN = "р";
var BN = "⤷";
var PN = "⥩";
var $N = "”";
var zN = "”";
var UN = "↳";
var HN = "ℜ";
var VN = "ℛ";
var GN = "ℜ";
var jN = "ℝ";
var ZN = "ℜ";
var KN = "▭";
var WN = "®";
var YN = "®";
var JN = "∋";
var XN = "⇋";
var QN = "⥯";
var eq = "⥽";
var nq = "⌋";
var tq = "𝔯";
var rq = "ℜ";
var oq = "⥤";
var sq = "⇁";
var cq = "⇀";
var iq = "⥬";
var aq = "Ρ";
var lq = "ρ";
var uq = "ϱ";
var fq = "⟩";
var pq = "⇥";
var hq = "→";
var dq = "→";
var gq = "⇒";
var mq = "⇄";
var _q = "↣";
var bq = "⌉";
var vq = "⟧";
var kq = "⥝";
var xq = "⥕";
var yq = "⇂";
var Eq = "⌋";
var wq = "⇁";
var Aq = "⇀";
var Cq = "⇄";
var Sq = "⇌";
var Dq = "⇉";
var Tq = "↝";
var Rq = "↦";
var Lq = "⊢";
var Nq = "⥛";
var qq = "⋌";
var Mq = "⧐";
var Iq = "⊳";
var Oq = "⊵";
var Fq = "⥏";
var Bq = "⥜";
var Pq = "⥔";
var $q = "↾";
var zq = "⥓";
var Uq = "⇀";
var Hq = "˚";
var Vq = "≓";
var Gq = "⇄";
var jq = "⇌";
var Zq = "‏";
var Kq = "⎱";
var Wq = "⎱";
var Yq = "⫮";
var Jq = "⟭";
var Xq = "⇾";
var Qq = "⟧";
var eM = "⦆";
var nM = "𝕣";
var tM = "ℝ";
var rM = "⨮";
var oM = "⨵";
var sM = "⥰";
var cM = ")";
var iM = "⦔";
var aM = "⨒";
var lM = "⇉";
var uM = "⇛";
var fM = "›";
var pM = "𝓇";
var hM = "ℛ";
var dM = "↱";
var gM = "↱";
var mM = "]";
var _M = "’";
var bM = "’";
var vM = "⋌";
var kM = "⋊";
var xM = "▹";
var yM = "⊵";
var EM = "▸";
var wM = "⧎";
var AM = "⧴";
var CM = "⥨";
var SM = "℞";
var DM = "Ś";
var TM = "ś";
var RM = "‚";
var LM = "⪸";
var NM = "Š";
var qM = "š";
var MM = "⪼";
var IM = "≻";
var OM = "≽";
var FM = "⪰";
var BM = "⪴";
var PM = "Ş";
var $M = "ş";
var zM = "Ŝ";
var UM = "ŝ";
var HM = "⪺";
var VM = "⪶";
var GM = "⋩";
var jM = "⨓";
var ZM = "≿";
var KM = "С";
var WM = "с";
var YM = "⊡";
var JM = "⋅";
var XM = "⩦";
var QM = "⤥";
var eI = "↘";
var nI = "⇘";
var tI = "↘";
var rI = "§";
var oI = ";";
var sI = "⤩";
var cI = "∖";
var iI = "∖";
var aI = "✶";
var lI = "𝔖";
var uI = "𝔰";
var fI = "⌢";
var pI = "♯";
var hI = "Щ";
var dI = "щ";
var gI = "Ш";
var mI = "ш";
var _I = "↓";
var bI = "←";
var vI = "∣";
var kI = "∥";
var xI = "→";
var yI = "↑";
var EI = "­";
var wI = "Σ";
var AI = "σ";
var CI = "ς";
var SI = "ς";
var DI = "∼";
var TI = "⩪";
var RI = "≃";
var LI = "≃";
var NI = "⪞";
var qI = "⪠";
var MI = "⪝";
var II = "⪟";
var OI = "≆";
var FI = "⨤";
var BI = "⥲";
var PI = "←";
var $I = "∘";
var zI = "∖";
var UI = "⨳";
var HI = "⧤";
var VI = "∣";
var GI = "⌣";
var jI = "⪪";
var ZI = "⪬";
var KI = "⪬︀";
var WI = "Ь";
var YI = "ь";
var JI = "⌿";
var XI = "⧄";
var QI = "/";
var eO = "𝕊";
var nO = "𝕤";
var tO = "♠";
var rO = "♠";
var oO = "∥";
var sO = "⊓";
var cO = "⊓︀";
var iO = "⊔";
var aO = "⊔︀";
var lO = "√";
var uO = "⊏";
var fO = "⊑";
var pO = "⊏";
var hO = "⊑";
var dO = "⊐";
var gO = "⊒";
var mO = "⊐";
var _O = "⊒";
var bO = "□";
var vO = "□";
var kO = "⊓";
var xO = "⊏";
var yO = "⊑";
var EO = "⊐";
var wO = "⊒";
var AO = "⊔";
var CO = "▪";
var SO = "□";
var DO = "▪";
var TO = "→";
var RO = "𝒮";
var LO = "𝓈";
var NO2 = "∖";
var qO = "⌣";
var MO = "⋆";
var IO = "⋆";
var OO = "☆";
var FO = "★";
var BO = "ϵ";
var PO = "ϕ";
var $O = "¯";
var zO = "⊂";
var UO = "⋐";
var HO = "⪽";
var VO = "⫅";
var GO = "⊆";
var jO = "⫃";
var ZO = "⫁";
var KO = "⫋";
var WO = "⊊";
var YO = "⪿";
var JO = "⥹";
var XO = "⊂";
var QO = "⋐";
var eF = "⊆";
var nF = "⫅";
var tF = "⊆";
var rF = "⊊";
var oF = "⫋";
var sF = "⫇";
var cF = "⫕";
var iF = "⫓";
var aF = "⪸";
var lF = "≻";
var uF = "≽";
var fF = "≻";
var pF = "⪰";
var hF = "≽";
var dF = "≿";
var gF = "⪰";
var mF = "⪺";
var _F = "⪶";
var bF = "⋩";
var vF = "≿";
var kF = "∋";
var xF = "∑";
var yF = "∑";
var EF = "♪";
var wF = "¹";
var AF = "²";
var CF = "³";
var SF = "⊃";
var DF = "⋑";
var TF = "⪾";
var RF = "⫘";
var LF = "⫆";
var NF = "⊇";
var qF = "⫄";
var MF = "⊃";
var IF = "⊇";
var OF = "⟉";
var FF = "⫗";
var BF = "⥻";
var PF = "⫂";
var $F = "⫌";
var zF = "⊋";
var UF = "⫀";
var HF = "⊃";
var VF = "⋑";
var GF = "⊇";
var jF = "⫆";
var ZF = "⊋";
var KF = "⫌";
var WF = "⫈";
var YF = "⫔";
var JF = "⫖";
var XF = "⤦";
var QF = "↙";
var eB = "⇙";
var nB = "↙";
var tB = "⤪";
var rB = "ß";
var oB = "	";
var sB = "⌖";
var cB = "Τ";
var iB = "τ";
var aB = "⎴";
var lB = "Ť";
var uB = "ť";
var fB = "Ţ";
var pB = "ţ";
var hB = "Т";
var dB = "т";
var gB = "⃛";
var mB = "⌕";
var _B = "𝔗";
var bB = "𝔱";
var vB = "∴";
var kB = "∴";
var xB = "∴";
var yB = "Θ";
var EB = "θ";
var wB = "ϑ";
var AB = "ϑ";
var CB = "≈";
var SB = "∼";
var DB = "  ";
var TB = " ";
var RB = " ";
var LB = "≈";
var NB = "∼";
var qB = "Þ";
var MB = "þ";
var IB = "˜";
var OB = "∼";
var FB = "≃";
var BB = "≅";
var PB = "≈";
var $B = "⨱";
var zB = "⊠";
var UB = "×";
var HB = "⨰";
var VB = "∭";
var GB = "⤨";
var jB = "⌶";
var ZB = "⫱";
var KB = "⊤";
var WB = "𝕋";
var YB = "𝕥";
var JB = "⫚";
var XB = "⤩";
var QB = "‴";
var eP = "™";
var nP = "™";
var tP = "▵";
var rP = "▿";
var oP = "◃";
var sP = "⊴";
var cP = "≜";
var iP = "▹";
var aP = "⊵";
var lP = "◬";
var uP = "≜";
var fP = "⨺";
var pP = "⃛";
var hP = "⨹";
var dP = "⧍";
var gP = "⨻";
var mP = "⏢";
var _P = "𝒯";
var bP = "𝓉";
var vP = "Ц";
var kP = "ц";
var xP = "Ћ";
var yP = "ћ";
var EP = "Ŧ";
var wP = "ŧ";
var AP = "≬";
var CP = "↞";
var SP = "↠";
var DP = "Ú";
var TP = "ú";
var RP = "↑";
var LP = "↟";
var NP = "⇑";
var qP = "⥉";
var MP = "Ў";
var IP = "ў";
var OP = "Ŭ";
var FP = "ŭ";
var BP = "Û";
var PP = "û";
var $P = "У";
var zP = "у";
var UP = "⇅";
var HP = "Ű";
var VP = "ű";
var GP = "⥮";
var jP = "⥾";
var ZP = "𝔘";
var KP = "𝔲";
var WP = "Ù";
var YP = "ù";
var JP = "⥣";
var XP = "↿";
var QP = "↾";
var e$ = "▀";
var n$ = "⌜";
var t$ = "⌜";
var r$ = "⌏";
var o$ = "◸";
var s$ = "Ū";
var c$ = "ū";
var i$ = "¨";
var a$ = "_";
var l$ = "⏟";
var u$ = "⎵";
var f$ = "⏝";
var p$ = "⋃";
var h$ = "⊎";
var d$ = "Ų";
var g$ = "ų";
var m$ = "𝕌";
var _$ = "𝕦";
var b$ = "⤒";
var v$ = "↑";
var k$ = "↑";
var x$ = "⇑";
var y$ = "⇅";
var E$ = "↕";
var w$ = "↕";
var A$ = "⇕";
var C$ = "⥮";
var S$ = "↿";
var D$ = "↾";
var T$ = "⊎";
var R$ = "↖";
var L$ = "↗";
var N$ = "υ";
var q$ = "ϒ";
var M$ = "ϒ";
var I$ = "Υ";
var O$ = "υ";
var F$ = "↥";
var B$ = "⊥";
var P$ = "⇈";
var $$ = "⌝";
var z$ = "⌝";
var U$ = "⌎";
var H$ = "Ů";
var V$ = "ů";
var G$ = "◹";
var j$ = "𝒰";
var Z$ = "𝓊";
var K$ = "⋰";
var W$ = "Ũ";
var Y$ = "ũ";
var J$ = "▵";
var X$ = "▴";
var Q$ = "⇈";
var ez = "Ü";
var nz = "ü";
var tz = "⦧";
var rz = "⦜";
var oz = "ϵ";
var sz = "ϰ";
var cz = "∅";
var iz = "ϕ";
var az = "ϖ";
var lz = "∝";
var uz = "↕";
var fz = "⇕";
var pz = "ϱ";
var hz = "ς";
var dz = "⊊︀";
var gz = "⫋︀";
var mz = "⊋︀";
var _z = "⫌︀";
var bz = "ϑ";
var vz = "⊲";
var kz = "⊳";
var xz = "⫨";
var yz = "⫫";
var Ez = "⫩";
var wz = "В";
var Az = "в";
var Cz = "⊢";
var Sz = "⊨";
var Dz = "⊩";
var Tz = "⊫";
var Rz = "⫦";
var Lz = "⊻";
var Nz = "∨";
var qz = "⋁";
var Mz = "≚";
var Iz = "⋮";
var Oz = "|";
var Fz = "‖";
var Bz = "|";
var Pz = "‖";
var $z = "∣";
var zz = "|";
var Uz = "❘";
var Hz = "≀";
var Vz = " ";
var Gz = "𝔙";
var jz = "𝔳";
var Zz = "⊲";
var Kz = "⊂⃒";
var Wz = "⊃⃒";
var Yz = "𝕍";
var Jz = "𝕧";
var Xz = "∝";
var Qz = "⊳";
var e3 = "𝒱";
var n3 = "𝓋";
var t3 = "⫋︀";
var r3 = "⊊︀";
var o3 = "⫌︀";
var s3 = "⊋︀";
var c3 = "⊪";
var i3 = "⦚";
var a3 = "Ŵ";
var l3 = "ŵ";
var u3 = "⩟";
var f3 = "∧";
var p3 = "⋀";
var h3 = "≙";
var d3 = "℘";
var g3 = "𝔚";
var m3 = "𝔴";
var _3 = "𝕎";
var b3 = "𝕨";
var v3 = "℘";
var k3 = "≀";
var x3 = "≀";
var y3 = "𝒲";
var E3 = "𝓌";
var w3 = "⋂";
var A3 = "◯";
var C3 = "⋃";
var S3 = "▽";
var D3 = "𝔛";
var T3 = "𝔵";
var R3 = "⟷";
var L3 = "⟺";
var N3 = "Ξ";
var q3 = "ξ";
var M3 = "⟵";
var I3 = "⟸";
var O3 = "⟼";
var F3 = "⋻";
var B3 = "⨀";
var P3 = "𝕏";
var $3 = "𝕩";
var z3 = "⨁";
var U3 = "⨂";
var H3 = "⟶";
var V3 = "⟹";
var G3 = "𝒳";
var j3 = "𝓍";
var Z3 = "⨆";
var K3 = "⨄";
var W3 = "△";
var Y3 = "⋁";
var J3 = "⋀";
var X3 = "Ý";
var Q3 = "ý";
var eU = "Я";
var nU = "я";
var tU = "Ŷ";
var rU = "ŷ";
var oU = "Ы";
var sU = "ы";
var cU = "¥";
var iU = "𝔜";
var aU = "𝔶";
var lU = "Ї";
var uU = "ї";
var fU = "𝕐";
var pU = "𝕪";
var hU = "𝒴";
var dU = "𝓎";
var gU = "Ю";
var mU = "ю";
var _U = "ÿ";
var bU = "Ÿ";
var vU = "Ź";
var kU = "ź";
var xU = "Ž";
var yU = "ž";
var EU = "З";
var wU = "з";
var AU = "Ż";
var CU = "ż";
var SU = "ℨ";
var DU = "​";
var TU = "Ζ";
var RU = "ζ";
var LU = "𝔷";
var NU = "ℨ";
var qU = "Ж";
var MU = "ж";
var IU = "⇝";
var OU = "𝕫";
var FU = "ℤ";
var BU = "𝒵";
var PU = "𝓏";
var $U = "‍";
var zU = "‌";
var UU = {
  Aacute: wi,
  aacute: Ai,
  Abreve: Ci,
  abreve: Si,
  ac: Di,
  acd: Ti,
  acE: Ri,
  Acirc: Li,
  acirc: Ni,
  acute: qi,
  Acy: Mi,
  acy: Ii,
  AElig: Oi,
  aelig: Fi,
  af: Bi,
  Afr: Pi,
  afr: $i,
  Agrave: zi,
  agrave: Ui,
  alefsym: Hi,
  aleph: Vi,
  Alpha: Gi,
  alpha: ji,
  Amacr: Zi,
  amacr: Ki,
  amalg: Wi,
  amp: Yi,
  AMP: Ji,
  andand: Xi,
  And: Qi,
  and: ea,
  andd: na,
  andslope: ta,
  andv: ra,
  ang: oa,
  ange: sa,
  angle: ca,
  angmsdaa: ia,
  angmsdab: aa,
  angmsdac: la,
  angmsdad: ua,
  angmsdae: fa,
  angmsdaf: pa,
  angmsdag: ha,
  angmsdah: da,
  angmsd: ga,
  angrt: ma,
  angrtvb: _a,
  angrtvbd: ba,
  angsph: va,
  angst: ka,
  angzarr: xa,
  Aogon: ya,
  aogon: Ea,
  Aopf: wa,
  aopf: Aa,
  apacir: Ca,
  ap: Sa,
  apE: Da,
  ape: Ta,
  apid: Ra,
  apos: La,
  ApplyFunction: Na,
  approx: qa,
  approxeq: Ma,
  Aring: Ia,
  aring: Oa,
  Ascr: Fa,
  ascr: Ba,
  Assign: Pa,
  ast: $a,
  asymp: za,
  asympeq: Ua,
  Atilde: Ha,
  atilde: Va,
  Auml: Ga,
  auml: ja,
  awconint: Za,
  awint: Ka,
  backcong: Wa,
  backepsilon: Ya,
  backprime: Ja,
  backsim: Xa,
  backsimeq: Qa,
  Backslash: el,
  Barv: nl,
  barvee: tl,
  barwed: rl,
  Barwed: ol,
  barwedge: sl,
  bbrk: cl,
  bbrktbrk: il,
  bcong: al,
  Bcy: ll,
  bcy: ul,
  bdquo: fl,
  becaus: pl,
  because: hl,
  Because: dl,
  bemptyv: gl,
  bepsi: ml,
  bernou: _l,
  Bernoullis: bl,
  Beta: vl,
  beta: kl,
  beth: xl,
  between: yl,
  Bfr: El,
  bfr: wl,
  bigcap: Al,
  bigcirc: Cl,
  bigcup: Sl,
  bigodot: Dl,
  bigoplus: Tl,
  bigotimes: Rl,
  bigsqcup: Ll,
  bigstar: Nl,
  bigtriangledown: ql,
  bigtriangleup: Ml,
  biguplus: Il,
  bigvee: Ol,
  bigwedge: Fl,
  bkarow: Bl,
  blacklozenge: Pl,
  blacksquare: $l,
  blacktriangle: zl,
  blacktriangledown: Ul,
  blacktriangleleft: Hl,
  blacktriangleright: Vl,
  blank: Gl,
  blk12: jl,
  blk14: Zl,
  blk34: Kl,
  block: Wl,
  bne: Yl,
  bnequiv: Jl,
  bNot: Xl,
  bnot: Ql,
  Bopf: eu,
  bopf: nu,
  bot: tu,
  bottom: ru,
  bowtie: ou,
  boxbox: su,
  boxdl: cu,
  boxdL: iu,
  boxDl: au,
  boxDL: lu,
  boxdr: uu,
  boxdR: fu,
  boxDr: pu,
  boxDR: hu,
  boxh: du,
  boxH: gu,
  boxhd: mu,
  boxHd: _u,
  boxhD: bu,
  boxHD: vu,
  boxhu: ku,
  boxHu: xu,
  boxhU: yu,
  boxHU: Eu,
  boxminus: wu,
  boxplus: Au,
  boxtimes: Cu,
  boxul: Su,
  boxuL: Du,
  boxUl: Tu,
  boxUL: Ru,
  boxur: Lu,
  boxuR: Nu,
  boxUr: qu,
  boxUR: Mu,
  boxv: Iu,
  boxV: Ou,
  boxvh: Fu,
  boxvH: Bu,
  boxVh: Pu,
  boxVH: $u,
  boxvl: zu,
  boxvL: Uu,
  boxVl: Hu,
  boxVL: Vu,
  boxvr: Gu,
  boxvR: ju,
  boxVr: Zu,
  boxVR: Ku,
  bprime: Wu,
  breve: Yu,
  Breve: Ju,
  brvbar: Xu,
  bscr: Qu,
  Bscr: ef,
  bsemi: nf,
  bsim: tf,
  bsime: rf,
  bsolb: of,
  bsol: sf,
  bsolhsub: cf,
  bull: af,
  bullet: lf,
  bump: uf,
  bumpE: ff,
  bumpe: pf,
  Bumpeq: hf,
  bumpeq: df,
  Cacute: gf,
  cacute: mf,
  capand: _f,
  capbrcup: bf,
  capcap: vf,
  cap: kf,
  Cap: xf,
  capcup: yf,
  capdot: Ef,
  CapitalDifferentialD: wf,
  caps: Af,
  caret: Cf,
  caron: Sf,
  Cayleys: Df,
  ccaps: Tf,
  Ccaron: Rf,
  ccaron: Lf,
  Ccedil: Nf,
  ccedil: qf,
  Ccirc: Mf,
  ccirc: If,
  Cconint: Of,
  ccups: Ff,
  ccupssm: Bf,
  Cdot: Pf,
  cdot: $f,
  cedil: zf,
  Cedilla: Uf,
  cemptyv: Hf,
  cent: Vf,
  centerdot: Gf,
  CenterDot: jf,
  cfr: Zf,
  Cfr: Kf,
  CHcy: Wf,
  chcy: Yf,
  check: Jf,
  checkmark: Xf,
  Chi: Qf,
  chi: ep,
  circ: np,
  circeq: tp,
  circlearrowleft: rp,
  circlearrowright: op,
  circledast: sp,
  circledcirc: cp,
  circleddash: ip,
  CircleDot: ap,
  circledR: lp,
  circledS: up,
  CircleMinus: fp,
  CirclePlus: pp,
  CircleTimes: hp,
  cir: dp,
  cirE: gp,
  cire: mp,
  cirfnint: _p,
  cirmid: bp,
  cirscir: vp,
  ClockwiseContourIntegral: kp,
  CloseCurlyDoubleQuote: xp,
  CloseCurlyQuote: yp,
  clubs: Ep,
  clubsuit: wp,
  colon: Ap,
  Colon: Cp,
  Colone: Sp,
  colone: Dp,
  coloneq: Tp,
  comma: Rp,
  commat: Lp,
  comp: Np,
  compfn: qp,
  complement: Mp,
  complexes: Ip,
  cong: Op,
  congdot: Fp,
  Congruent: Bp,
  conint: Pp,
  Conint: $p,
  ContourIntegral: zp,
  copf: Up,
  Copf: Hp,
  coprod: Vp,
  Coproduct: Gp,
  copy: jp,
  COPY: Zp,
  copysr: Kp,
  CounterClockwiseContourIntegral: Wp,
  crarr: Yp,
  cross: Jp,
  Cross: Xp,
  Cscr: Qp,
  cscr: eh,
  csub: nh,
  csube: th,
  csup: rh,
  csupe: oh,
  ctdot: sh,
  cudarrl: ch,
  cudarrr: ih,
  cuepr: ah,
  cuesc: lh,
  cularr: uh,
  cularrp: fh,
  cupbrcap: ph,
  cupcap: hh,
  CupCap: dh,
  cup: gh,
  Cup: mh,
  cupcup: _h,
  cupdot: bh,
  cupor: vh,
  cups: kh,
  curarr: xh,
  curarrm: yh,
  curlyeqprec: Eh,
  curlyeqsucc: wh,
  curlyvee: Ah,
  curlywedge: Ch,
  curren: Sh,
  curvearrowleft: Dh,
  curvearrowright: Th,
  cuvee: Rh,
  cuwed: Lh,
  cwconint: Nh,
  cwint: qh,
  cylcty: Mh,
  dagger: Ih,
  Dagger: Oh,
  daleth: Fh,
  darr: Bh,
  Darr: Ph,
  dArr: $h,
  dash: zh,
  Dashv: Uh,
  dashv: Hh,
  dbkarow: Vh,
  dblac: Gh,
  Dcaron: jh,
  dcaron: Zh,
  Dcy: Kh,
  dcy: Wh,
  ddagger: Yh,
  ddarr: Jh,
  DD: Xh,
  dd: Qh,
  DDotrahd: ed,
  ddotseq: nd,
  deg: td,
  Del: rd,
  Delta: od,
  delta: sd,
  demptyv: cd,
  dfisht: id,
  Dfr: ad,
  dfr: ld,
  dHar: ud,
  dharl: fd,
  dharr: pd,
  DiacriticalAcute: hd,
  DiacriticalDot: dd,
  DiacriticalDoubleAcute: gd,
  DiacriticalGrave: md,
  DiacriticalTilde: _d,
  diam: bd,
  diamond: vd,
  Diamond: kd,
  diamondsuit: xd,
  diams: yd,
  die: Ed,
  DifferentialD: wd,
  digamma: Ad,
  disin: Cd,
  div: Sd,
  divide: Dd,
  divideontimes: Td,
  divonx: Rd,
  DJcy: Ld,
  djcy: Nd,
  dlcorn: qd,
  dlcrop: Md,
  dollar: Id,
  Dopf: Od,
  dopf: Fd,
  Dot: Bd,
  dot: Pd,
  DotDot: $d,
  doteq: zd,
  doteqdot: Ud,
  DotEqual: Hd,
  dotminus: Vd,
  dotplus: Gd,
  dotsquare: jd,
  doublebarwedge: Zd,
  DoubleContourIntegral: Kd,
  DoubleDot: Wd,
  DoubleDownArrow: Yd,
  DoubleLeftArrow: Jd,
  DoubleLeftRightArrow: Xd,
  DoubleLeftTee: Qd,
  DoubleLongLeftArrow: eg,
  DoubleLongLeftRightArrow: ng,
  DoubleLongRightArrow: tg,
  DoubleRightArrow: rg,
  DoubleRightTee: og,
  DoubleUpArrow: sg,
  DoubleUpDownArrow: cg,
  DoubleVerticalBar: ig,
  DownArrowBar: ag,
  downarrow: lg,
  DownArrow: ug,
  Downarrow: fg,
  DownArrowUpArrow: pg,
  DownBreve: hg,
  downdownarrows: dg,
  downharpoonleft: gg,
  downharpoonright: mg,
  DownLeftRightVector: _g,
  DownLeftTeeVector: bg,
  DownLeftVectorBar: vg,
  DownLeftVector: kg,
  DownRightTeeVector: xg,
  DownRightVectorBar: yg,
  DownRightVector: Eg,
  DownTeeArrow: wg,
  DownTee: Ag,
  drbkarow: Cg,
  drcorn: Sg,
  drcrop: Dg,
  Dscr: Tg,
  dscr: Rg,
  DScy: Lg,
  dscy: Ng,
  dsol: qg,
  Dstrok: Mg,
  dstrok: Ig,
  dtdot: Og,
  dtri: Fg,
  dtrif: Bg,
  duarr: Pg,
  duhar: $g,
  dwangle: zg,
  DZcy: Ug,
  dzcy: Hg,
  dzigrarr: Vg,
  Eacute: Gg,
  eacute: jg,
  easter: Zg,
  Ecaron: Kg,
  ecaron: Wg,
  Ecirc: Yg,
  ecirc: Jg,
  ecir: Xg,
  ecolon: Qg,
  Ecy: em,
  ecy: nm,
  eDDot: tm,
  Edot: rm,
  edot: om,
  eDot: sm,
  ee: cm,
  efDot: im,
  Efr: am,
  efr: lm,
  eg: um,
  Egrave: fm,
  egrave: pm,
  egs: hm,
  egsdot: dm,
  el: gm,
  Element: mm,
  elinters: _m,
  ell: bm,
  els: vm,
  elsdot: km,
  Emacr: xm,
  emacr: ym,
  empty: Em,
  emptyset: wm,
  EmptySmallSquare: Am,
  emptyv: Cm,
  EmptyVerySmallSquare: Sm,
  emsp13: Dm,
  emsp14: Tm,
  emsp: Rm,
  ENG: Lm,
  eng: Nm,
  ensp: qm,
  Eogon: Mm,
  eogon: Im,
  Eopf: Om,
  eopf: Fm,
  epar: Bm,
  eparsl: Pm,
  eplus: $m,
  epsi: zm,
  Epsilon: Um,
  epsilon: Hm,
  epsiv: Vm,
  eqcirc: Gm,
  eqcolon: jm,
  eqsim: Zm,
  eqslantgtr: Km,
  eqslantless: Wm,
  Equal: Ym,
  equals: Jm,
  EqualTilde: Xm,
  equest: Qm,
  Equilibrium: e_,
  equiv: n_,
  equivDD: t_,
  eqvparsl: r_,
  erarr: o_,
  erDot: s_,
  escr: c_,
  Escr: i_,
  esdot: a_,
  Esim: l_,
  esim: u_,
  Eta: f_,
  eta: p_,
  ETH: h_,
  eth: d_,
  Euml: g_,
  euml: m_,
  euro: __,
  excl: b_,
  exist: v_,
  Exists: k_,
  expectation: x_,
  exponentiale: y_,
  ExponentialE: E_,
  fallingdotseq: w_,
  Fcy: A_,
  fcy: C_,
  female: S_,
  ffilig: D_,
  fflig: T_,
  ffllig: R_,
  Ffr: L_,
  ffr: N_,
  filig: q_,
  FilledSmallSquare: M_,
  FilledVerySmallSquare: I_,
  fjlig: O_,
  flat: F_,
  fllig: B_,
  fltns: P_,
  fnof: $_,
  Fopf: z_,
  fopf: U_,
  forall: H_,
  ForAll: V_,
  fork: G_,
  forkv: j_,
  Fouriertrf: Z_,
  fpartint: K_,
  frac12: W_,
  frac13: Y_,
  frac14: J_,
  frac15: X_,
  frac16: Q_,
  frac18: eb,
  frac23: nb,
  frac25: tb,
  frac34: rb,
  frac35: ob,
  frac38: sb,
  frac45: cb,
  frac56: ib,
  frac58: ab,
  frac78: lb,
  frasl: ub,
  frown: fb,
  fscr: pb,
  Fscr: hb,
  gacute: db,
  Gamma: gb,
  gamma: mb,
  Gammad: _b,
  gammad: bb,
  gap: vb,
  Gbreve: kb,
  gbreve: xb,
  Gcedil: yb,
  Gcirc: Eb,
  gcirc: wb,
  Gcy: Ab,
  gcy: Cb,
  Gdot: Sb,
  gdot: Db,
  ge: Tb,
  gE: Rb,
  gEl: Lb,
  gel: Nb,
  geq: qb,
  geqq: Mb,
  geqslant: Ib,
  gescc: Ob,
  ges: Fb,
  gesdot: Bb,
  gesdoto: Pb,
  gesdotol: $b,
  gesl: zb,
  gesles: Ub,
  Gfr: Hb,
  gfr: Vb,
  gg: Gb,
  Gg: jb,
  ggg: Zb,
  gimel: Kb,
  GJcy: Wb,
  gjcy: Yb,
  gla: Jb,
  gl: Xb,
  glE: Qb,
  glj: e0,
  gnap: n0,
  gnapprox: t0,
  gne: r0,
  gnE: o0,
  gneq: s0,
  gneqq: c0,
  gnsim: i0,
  Gopf: a0,
  gopf: l0,
  grave: u0,
  GreaterEqual: f0,
  GreaterEqualLess: p0,
  GreaterFullEqual: h0,
  GreaterGreater: d0,
  GreaterLess: g0,
  GreaterSlantEqual: m0,
  GreaterTilde: _0,
  Gscr: b0,
  gscr: v0,
  gsim: k0,
  gsime: x0,
  gsiml: y0,
  gtcc: E0,
  gtcir: w0,
  gt: A0,
  GT: C0,
  Gt: S0,
  gtdot: D0,
  gtlPar: T0,
  gtquest: R0,
  gtrapprox: L0,
  gtrarr: N0,
  gtrdot: q0,
  gtreqless: M0,
  gtreqqless: I0,
  gtrless: O0,
  gtrsim: F0,
  gvertneqq: B0,
  gvnE: P0,
  Hacek: $0,
  hairsp: z0,
  half: U0,
  hamilt: H0,
  HARDcy: V0,
  hardcy: G0,
  harrcir: j0,
  harr: Z0,
  hArr: K0,
  harrw: W0,
  Hat: Y0,
  hbar: J0,
  Hcirc: X0,
  hcirc: Q0,
  hearts: ev,
  heartsuit: nv,
  hellip: tv,
  hercon: rv,
  hfr: ov,
  Hfr: sv,
  HilbertSpace: cv,
  hksearow: iv,
  hkswarow: av,
  hoarr: lv,
  homtht: uv,
  hookleftarrow: fv,
  hookrightarrow: pv,
  hopf: hv,
  Hopf: dv,
  horbar: gv,
  HorizontalLine: mv,
  hscr: _v,
  Hscr: bv,
  hslash: vv,
  Hstrok: kv,
  hstrok: xv,
  HumpDownHump: yv,
  HumpEqual: Ev,
  hybull: wv,
  hyphen: Av,
  Iacute: Cv,
  iacute: Sv,
  ic: Dv,
  Icirc: Tv,
  icirc: Rv,
  Icy: Lv,
  icy: Nv,
  Idot: qv,
  IEcy: Mv,
  iecy: Iv,
  iexcl: Ov,
  iff: Fv,
  ifr: Bv,
  Ifr: Pv,
  Igrave: $v,
  igrave: zv,
  ii: Uv,
  iiiint: Hv,
  iiint: Vv,
  iinfin: Gv,
  iiota: jv,
  IJlig: Zv,
  ijlig: Kv,
  Imacr: Wv,
  imacr: Yv,
  image: Jv,
  ImaginaryI: Xv,
  imagline: Qv,
  imagpart: ek,
  imath: nk,
  Im: tk,
  imof: rk,
  imped: ok,
  Implies: sk,
  incare: ck,
  in: "∈",
  infin: ik,
  infintie: ak,
  inodot: lk,
  intcal: uk,
  int: fk,
  Int: pk,
  integers: hk,
  Integral: dk,
  intercal: gk,
  Intersection: mk,
  intlarhk: _k,
  intprod: bk,
  InvisibleComma: vk,
  InvisibleTimes: kk,
  IOcy: xk,
  iocy: yk,
  Iogon: Ek,
  iogon: wk,
  Iopf: Ak,
  iopf: Ck,
  Iota: Sk,
  iota: Dk,
  iprod: Tk,
  iquest: Rk,
  iscr: Lk,
  Iscr: Nk,
  isin: qk,
  isindot: Mk,
  isinE: Ik,
  isins: Ok,
  isinsv: Fk,
  isinv: Bk,
  it: Pk,
  Itilde: $k,
  itilde: zk,
  Iukcy: Uk,
  iukcy: Hk,
  Iuml: Vk,
  iuml: Gk,
  Jcirc: jk,
  jcirc: Zk,
  Jcy: Kk,
  jcy: Wk,
  Jfr: Yk,
  jfr: Jk,
  jmath: Xk,
  Jopf: Qk,
  jopf: ex,
  Jscr: nx,
  jscr: tx,
  Jsercy: rx,
  jsercy: ox,
  Jukcy: sx,
  jukcy: cx,
  Kappa: ix,
  kappa: ax,
  kappav: lx,
  Kcedil: ux,
  kcedil: fx,
  Kcy: px,
  kcy: hx,
  Kfr: dx,
  kfr: gx,
  kgreen: mx,
  KHcy: _x,
  khcy: bx,
  KJcy: vx,
  kjcy: kx,
  Kopf: xx,
  kopf: yx,
  Kscr: Ex,
  kscr: wx,
  lAarr: Ax,
  Lacute: Cx,
  lacute: Sx,
  laemptyv: Dx,
  lagran: Tx,
  Lambda: Rx,
  lambda: Lx,
  lang: Nx,
  Lang: qx,
  langd: Mx,
  langle: Ix,
  lap: Ox,
  Laplacetrf: Fx,
  laquo: Bx,
  larrb: Px,
  larrbfs: $x,
  larr: zx,
  Larr: Ux,
  lArr: Hx,
  larrfs: Vx,
  larrhk: Gx,
  larrlp: jx,
  larrpl: Zx,
  larrsim: Kx,
  larrtl: Wx,
  latail: Yx,
  lAtail: Jx,
  lat: Xx,
  late: Qx,
  lates: ey,
  lbarr: ny,
  lBarr: ty,
  lbbrk: ry,
  lbrace: oy,
  lbrack: sy,
  lbrke: cy,
  lbrksld: iy,
  lbrkslu: ay,
  Lcaron: ly,
  lcaron: uy,
  Lcedil: fy,
  lcedil: py,
  lceil: hy,
  lcub: dy,
  Lcy: gy,
  lcy: my,
  ldca: _y,
  ldquo: by,
  ldquor: vy,
  ldrdhar: ky,
  ldrushar: xy,
  ldsh: yy,
  le: Ey,
  lE: wy,
  LeftAngleBracket: Ay,
  LeftArrowBar: Cy,
  leftarrow: Sy,
  LeftArrow: Dy,
  Leftarrow: Ty,
  LeftArrowRightArrow: Ry,
  leftarrowtail: Ly,
  LeftCeiling: Ny,
  LeftDoubleBracket: qy,
  LeftDownTeeVector: My,
  LeftDownVectorBar: Iy,
  LeftDownVector: Oy,
  LeftFloor: Fy,
  leftharpoondown: By,
  leftharpoonup: Py,
  leftleftarrows: $y,
  leftrightarrow: zy,
  LeftRightArrow: Uy,
  Leftrightarrow: Hy,
  leftrightarrows: Vy,
  leftrightharpoons: Gy,
  leftrightsquigarrow: jy,
  LeftRightVector: Zy,
  LeftTeeArrow: Ky,
  LeftTee: Wy,
  LeftTeeVector: Yy,
  leftthreetimes: Jy,
  LeftTriangleBar: Xy,
  LeftTriangle: Qy,
  LeftTriangleEqual: eE,
  LeftUpDownVector: nE,
  LeftUpTeeVector: tE,
  LeftUpVectorBar: rE,
  LeftUpVector: oE,
  LeftVectorBar: sE,
  LeftVector: cE,
  lEg: iE,
  leg: aE,
  leq: lE,
  leqq: uE,
  leqslant: fE,
  lescc: pE,
  les: hE,
  lesdot: dE,
  lesdoto: gE,
  lesdotor: mE,
  lesg: _E,
  lesges: bE,
  lessapprox: vE,
  lessdot: kE,
  lesseqgtr: xE,
  lesseqqgtr: yE,
  LessEqualGreater: EE,
  LessFullEqual: wE,
  LessGreater: AE,
  lessgtr: CE,
  LessLess: SE,
  lesssim: DE,
  LessSlantEqual: TE,
  LessTilde: RE,
  lfisht: LE,
  lfloor: NE,
  Lfr: qE,
  lfr: ME,
  lg: IE,
  lgE: OE,
  lHar: FE,
  lhard: BE,
  lharu: PE,
  lharul: $E,
  lhblk: zE,
  LJcy: UE,
  ljcy: HE,
  llarr: VE,
  ll: GE,
  Ll: jE,
  llcorner: ZE,
  Lleftarrow: KE,
  llhard: WE,
  lltri: YE,
  Lmidot: JE,
  lmidot: XE,
  lmoustache: QE,
  lmoust: ew,
  lnap: nw,
  lnapprox: tw,
  lne: rw,
  lnE: ow,
  lneq: sw,
  lneqq: cw,
  lnsim: iw,
  loang: aw,
  loarr: lw,
  lobrk: uw,
  longleftarrow: fw,
  LongLeftArrow: pw,
  Longleftarrow: hw,
  longleftrightarrow: dw,
  LongLeftRightArrow: gw,
  Longleftrightarrow: mw,
  longmapsto: _w,
  longrightarrow: bw,
  LongRightArrow: vw,
  Longrightarrow: kw,
  looparrowleft: xw,
  looparrowright: yw,
  lopar: Ew,
  Lopf: ww,
  lopf: Aw,
  loplus: Cw,
  lotimes: Sw,
  lowast: Dw,
  lowbar: Tw,
  LowerLeftArrow: Rw,
  LowerRightArrow: Lw,
  loz: Nw,
  lozenge: qw,
  lozf: Mw,
  lpar: Iw,
  lparlt: Ow,
  lrarr: Fw,
  lrcorner: Bw,
  lrhar: Pw,
  lrhard: $w,
  lrm: zw,
  lrtri: Uw,
  lsaquo: Hw,
  lscr: Vw,
  Lscr: Gw,
  lsh: jw,
  Lsh: Zw,
  lsim: Kw,
  lsime: Ww,
  lsimg: Yw,
  lsqb: Jw,
  lsquo: Xw,
  lsquor: Qw,
  Lstrok: e1,
  lstrok: n1,
  ltcc: t1,
  ltcir: r1,
  lt: o1,
  LT: s1,
  Lt: c1,
  ltdot: i1,
  lthree: a1,
  ltimes: l1,
  ltlarr: u1,
  ltquest: f1,
  ltri: p1,
  ltrie: h1,
  ltrif: d1,
  ltrPar: g1,
  lurdshar: m1,
  luruhar: _1,
  lvertneqq: b1,
  lvnE: v1,
  macr: k1,
  male: x1,
  malt: y1,
  maltese: E1,
  Map: "⤅",
  map: w1,
  mapsto: A1,
  mapstodown: C1,
  mapstoleft: S1,
  mapstoup: D1,
  marker: T1,
  mcomma: R1,
  Mcy: L1,
  mcy: N1,
  mdash: q1,
  mDDot: M1,
  measuredangle: I1,
  MediumSpace: O1,
  Mellintrf: F1,
  Mfr: B1,
  mfr: P1,
  mho: $1,
  micro: z1,
  midast: U1,
  midcir: H1,
  mid: V1,
  middot: G1,
  minusb: j1,
  minus: Z1,
  minusd: K1,
  minusdu: W1,
  MinusPlus: Y1,
  mlcp: J1,
  mldr: X1,
  mnplus: Q1,
  models: eA,
  Mopf: nA,
  mopf: tA,
  mp: rA,
  mscr: oA,
  Mscr: sA,
  mstpos: cA,
  Mu: iA,
  mu: aA,
  multimap: lA,
  mumap: uA,
  nabla: fA,
  Nacute: pA,
  nacute: hA,
  nang: dA,
  nap: gA,
  napE: mA,
  napid: _A,
  napos: bA,
  napprox: vA,
  natural: kA,
  naturals: xA,
  natur: yA,
  nbsp: EA,
  nbump: wA,
  nbumpe: AA,
  ncap: CA,
  Ncaron: SA,
  ncaron: DA,
  Ncedil: TA,
  ncedil: RA,
  ncong: LA,
  ncongdot: NA,
  ncup: qA,
  Ncy: MA,
  ncy: IA,
  ndash: OA,
  nearhk: FA,
  nearr: BA,
  neArr: PA,
  nearrow: $A,
  ne: zA,
  nedot: UA,
  NegativeMediumSpace: HA,
  NegativeThickSpace: VA,
  NegativeThinSpace: GA,
  NegativeVeryThinSpace: jA,
  nequiv: ZA,
  nesear: KA,
  nesim: WA,
  NestedGreaterGreater: YA,
  NestedLessLess: JA,
  NewLine: XA,
  nexist: QA,
  nexists: eC,
  Nfr: nC,
  nfr: tC,
  ngE: rC,
  nge: oC,
  ngeq: sC,
  ngeqq: cC,
  ngeqslant: iC,
  nges: aC,
  nGg: lC,
  ngsim: uC,
  nGt: fC,
  ngt: pC,
  ngtr: hC,
  nGtv: dC,
  nharr: gC,
  nhArr: mC,
  nhpar: _C,
  ni: bC,
  nis: vC,
  nisd: kC,
  niv: xC,
  NJcy: yC,
  njcy: EC,
  nlarr: wC,
  nlArr: AC,
  nldr: CC,
  nlE: SC,
  nle: DC,
  nleftarrow: TC,
  nLeftarrow: RC,
  nleftrightarrow: LC,
  nLeftrightarrow: NC,
  nleq: qC,
  nleqq: MC,
  nleqslant: IC,
  nles: OC,
  nless: FC,
  nLl: BC,
  nlsim: PC,
  nLt: $C,
  nlt: zC,
  nltri: UC,
  nltrie: HC,
  nLtv: VC,
  nmid: GC,
  NoBreak: jC,
  NonBreakingSpace: ZC,
  nopf: KC,
  Nopf: WC,
  Not: YC,
  not: JC,
  NotCongruent: XC,
  NotCupCap: QC,
  NotDoubleVerticalBar: eS,
  NotElement: nS,
  NotEqual: tS,
  NotEqualTilde: rS,
  NotExists: oS,
  NotGreater: sS,
  NotGreaterEqual: cS,
  NotGreaterFullEqual: iS,
  NotGreaterGreater: aS,
  NotGreaterLess: lS,
  NotGreaterSlantEqual: uS,
  NotGreaterTilde: fS,
  NotHumpDownHump: pS,
  NotHumpEqual: hS,
  notin: dS,
  notindot: gS,
  notinE: mS,
  notinva: _S,
  notinvb: bS,
  notinvc: vS,
  NotLeftTriangleBar: kS,
  NotLeftTriangle: xS,
  NotLeftTriangleEqual: yS,
  NotLess: ES,
  NotLessEqual: wS,
  NotLessGreater: AS,
  NotLessLess: CS,
  NotLessSlantEqual: SS,
  NotLessTilde: DS,
  NotNestedGreaterGreater: TS,
  NotNestedLessLess: RS,
  notni: LS,
  notniva: NS,
  notnivb: qS,
  notnivc: MS,
  NotPrecedes: IS,
  NotPrecedesEqual: OS,
  NotPrecedesSlantEqual: FS,
  NotReverseElement: BS,
  NotRightTriangleBar: PS,
  NotRightTriangle: $S,
  NotRightTriangleEqual: zS,
  NotSquareSubset: US,
  NotSquareSubsetEqual: HS,
  NotSquareSuperset: VS,
  NotSquareSupersetEqual: GS,
  NotSubset: jS,
  NotSubsetEqual: ZS,
  NotSucceeds: KS,
  NotSucceedsEqual: WS,
  NotSucceedsSlantEqual: YS,
  NotSucceedsTilde: JS,
  NotSuperset: XS,
  NotSupersetEqual: QS,
  NotTilde: eD,
  NotTildeEqual: nD,
  NotTildeFullEqual: tD,
  NotTildeTilde: rD,
  NotVerticalBar: oD,
  nparallel: sD,
  npar: cD,
  nparsl: iD,
  npart: aD,
  npolint: lD,
  npr: uD,
  nprcue: fD,
  nprec: pD,
  npreceq: hD,
  npre: dD,
  nrarrc: gD,
  nrarr: mD,
  nrArr: _D,
  nrarrw: bD,
  nrightarrow: vD,
  nRightarrow: kD,
  nrtri: xD,
  nrtrie: yD,
  nsc: ED,
  nsccue: wD,
  nsce: AD,
  Nscr: CD,
  nscr: SD,
  nshortmid: DD,
  nshortparallel: TD,
  nsim: RD,
  nsime: LD,
  nsimeq: ND,
  nsmid: qD,
  nspar: MD,
  nsqsube: ID,
  nsqsupe: OD,
  nsub: FD,
  nsubE: BD,
  nsube: PD,
  nsubset: $D,
  nsubseteq: zD,
  nsubseteqq: UD,
  nsucc: HD,
  nsucceq: VD,
  nsup: GD,
  nsupE: jD,
  nsupe: ZD,
  nsupset: KD,
  nsupseteq: WD,
  nsupseteqq: YD,
  ntgl: JD,
  Ntilde: XD,
  ntilde: QD,
  ntlg: eT,
  ntriangleleft: nT,
  ntrianglelefteq: tT,
  ntriangleright: rT,
  ntrianglerighteq: oT,
  Nu: sT,
  nu: cT,
  num: iT,
  numero: aT,
  numsp: lT,
  nvap: uT,
  nvdash: fT,
  nvDash: pT,
  nVdash: hT,
  nVDash: dT,
  nvge: gT,
  nvgt: mT,
  nvHarr: _T,
  nvinfin: bT,
  nvlArr: vT,
  nvle: kT,
  nvlt: xT,
  nvltrie: yT,
  nvrArr: ET,
  nvrtrie: wT,
  nvsim: AT,
  nwarhk: CT,
  nwarr: ST,
  nwArr: DT,
  nwarrow: TT,
  nwnear: RT,
  Oacute: LT,
  oacute: NT,
  oast: qT,
  Ocirc: MT,
  ocirc: IT,
  ocir: OT,
  Ocy: FT,
  ocy: BT,
  odash: PT,
  Odblac: $T,
  odblac: zT,
  odiv: UT,
  odot: HT,
  odsold: VT,
  OElig: GT,
  oelig: jT,
  ofcir: ZT,
  Ofr: KT,
  ofr: WT,
  ogon: YT,
  Ograve: JT,
  ograve: XT,
  ogt: QT,
  ohbar: eR,
  ohm: nR,
  oint: tR,
  olarr: rR,
  olcir: oR,
  olcross: sR,
  oline: cR,
  olt: iR,
  Omacr: aR,
  omacr: lR,
  Omega: uR,
  omega: fR,
  Omicron: pR,
  omicron: hR,
  omid: dR,
  ominus: gR,
  Oopf: mR,
  oopf: _R,
  opar: bR,
  OpenCurlyDoubleQuote: vR,
  OpenCurlyQuote: kR,
  operp: xR,
  oplus: yR,
  orarr: ER,
  Or: wR,
  or: AR,
  ord: CR,
  order: SR,
  orderof: DR,
  ordf: TR,
  ordm: RR,
  origof: LR,
  oror: NR,
  orslope: qR,
  orv: MR,
  oS: IR,
  Oscr: OR,
  oscr: FR,
  Oslash: BR,
  oslash: PR,
  osol: $R,
  Otilde: zR,
  otilde: UR,
  otimesas: HR,
  Otimes: VR,
  otimes: GR,
  Ouml: jR,
  ouml: ZR,
  ovbar: KR,
  OverBar: WR,
  OverBrace: YR,
  OverBracket: JR,
  OverParenthesis: XR,
  para: QR,
  parallel: e2,
  par: n2,
  parsim: t2,
  parsl: r2,
  part: o2,
  PartialD: s2,
  Pcy: c2,
  pcy: i2,
  percnt: a2,
  period: l2,
  permil: u2,
  perp: f2,
  pertenk: p2,
  Pfr: h2,
  pfr: d2,
  Phi: g2,
  phi: m2,
  phiv: _2,
  phmmat: b2,
  phone: v2,
  Pi: k2,
  pi: x2,
  pitchfork: y2,
  piv: E2,
  planck: w2,
  planckh: A2,
  plankv: C2,
  plusacir: S2,
  plusb: D2,
  pluscir: T2,
  plus: R2,
  plusdo: L2,
  plusdu: N2,
  pluse: q2,
  PlusMinus: M2,
  plusmn: I2,
  plussim: O2,
  plustwo: F2,
  pm: B2,
  Poincareplane: P2,
  pointint: $2,
  popf: z2,
  Popf: U2,
  pound: H2,
  prap: V2,
  Pr: G2,
  pr: j2,
  prcue: Z2,
  precapprox: K2,
  prec: W2,
  preccurlyeq: Y2,
  Precedes: J2,
  PrecedesEqual: X2,
  PrecedesSlantEqual: Q2,
  PrecedesTilde: eL,
  preceq: nL,
  precnapprox: tL,
  precneqq: rL,
  precnsim: oL,
  pre: sL,
  prE: cL,
  precsim: iL,
  prime: aL,
  Prime: lL,
  primes: uL,
  prnap: fL,
  prnE: pL,
  prnsim: hL,
  prod: dL,
  Product: gL,
  profalar: mL,
  profline: _L,
  profsurf: bL,
  prop: vL,
  Proportional: kL,
  Proportion: xL,
  propto: yL,
  prsim: EL,
  prurel: wL,
  Pscr: AL,
  pscr: CL,
  Psi: SL,
  psi: DL,
  puncsp: TL,
  Qfr: RL,
  qfr: LL,
  qint: NL,
  qopf: qL,
  Qopf: ML,
  qprime: IL,
  Qscr: OL,
  qscr: FL,
  quaternions: BL,
  quatint: PL,
  quest: $L,
  questeq: zL,
  quot: UL,
  QUOT: HL,
  rAarr: VL,
  race: GL,
  Racute: jL,
  racute: ZL,
  radic: KL,
  raemptyv: WL,
  rang: YL,
  Rang: JL,
  rangd: XL,
  range: QL,
  rangle: eN,
  raquo: nN,
  rarrap: tN,
  rarrb: rN,
  rarrbfs: oN,
  rarrc: sN,
  rarr: cN,
  Rarr: iN,
  rArr: aN,
  rarrfs: lN,
  rarrhk: uN,
  rarrlp: fN,
  rarrpl: pN,
  rarrsim: hN,
  Rarrtl: dN,
  rarrtl: gN,
  rarrw: mN,
  ratail: _N,
  rAtail: bN,
  ratio: vN,
  rationals: kN,
  rbarr: xN,
  rBarr: yN,
  RBarr: EN,
  rbbrk: wN,
  rbrace: AN,
  rbrack: CN,
  rbrke: SN,
  rbrksld: DN,
  rbrkslu: TN,
  Rcaron: RN,
  rcaron: LN,
  Rcedil: NN,
  rcedil: qN,
  rceil: MN,
  rcub: IN,
  Rcy: ON,
  rcy: FN,
  rdca: BN,
  rdldhar: PN,
  rdquo: $N,
  rdquor: zN,
  rdsh: UN,
  real: HN,
  realine: VN,
  realpart: GN,
  reals: jN,
  Re: ZN,
  rect: KN,
  reg: WN,
  REG: YN,
  ReverseElement: JN,
  ReverseEquilibrium: XN,
  ReverseUpEquilibrium: QN,
  rfisht: eq,
  rfloor: nq,
  rfr: tq,
  Rfr: rq,
  rHar: oq,
  rhard: sq,
  rharu: cq,
  rharul: iq,
  Rho: aq,
  rho: lq,
  rhov: uq,
  RightAngleBracket: fq,
  RightArrowBar: pq,
  rightarrow: hq,
  RightArrow: dq,
  Rightarrow: gq,
  RightArrowLeftArrow: mq,
  rightarrowtail: _q,
  RightCeiling: bq,
  RightDoubleBracket: vq,
  RightDownTeeVector: kq,
  RightDownVectorBar: xq,
  RightDownVector: yq,
  RightFloor: Eq,
  rightharpoondown: wq,
  rightharpoonup: Aq,
  rightleftarrows: Cq,
  rightleftharpoons: Sq,
  rightrightarrows: Dq,
  rightsquigarrow: Tq,
  RightTeeArrow: Rq,
  RightTee: Lq,
  RightTeeVector: Nq,
  rightthreetimes: qq,
  RightTriangleBar: Mq,
  RightTriangle: Iq,
  RightTriangleEqual: Oq,
  RightUpDownVector: Fq,
  RightUpTeeVector: Bq,
  RightUpVectorBar: Pq,
  RightUpVector: $q,
  RightVectorBar: zq,
  RightVector: Uq,
  ring: Hq,
  risingdotseq: Vq,
  rlarr: Gq,
  rlhar: jq,
  rlm: Zq,
  rmoustache: Kq,
  rmoust: Wq,
  rnmid: Yq,
  roang: Jq,
  roarr: Xq,
  robrk: Qq,
  ropar: eM,
  ropf: nM,
  Ropf: tM,
  roplus: rM,
  rotimes: oM,
  RoundImplies: sM,
  rpar: cM,
  rpargt: iM,
  rppolint: aM,
  rrarr: lM,
  Rrightarrow: uM,
  rsaquo: fM,
  rscr: pM,
  Rscr: hM,
  rsh: dM,
  Rsh: gM,
  rsqb: mM,
  rsquo: _M,
  rsquor: bM,
  rthree: vM,
  rtimes: kM,
  rtri: xM,
  rtrie: yM,
  rtrif: EM,
  rtriltri: wM,
  RuleDelayed: AM,
  ruluhar: CM,
  rx: SM,
  Sacute: DM,
  sacute: TM,
  sbquo: RM,
  scap: LM,
  Scaron: NM,
  scaron: qM,
  Sc: MM,
  sc: IM,
  sccue: OM,
  sce: FM,
  scE: BM,
  Scedil: PM,
  scedil: $M,
  Scirc: zM,
  scirc: UM,
  scnap: HM,
  scnE: VM,
  scnsim: GM,
  scpolint: jM,
  scsim: ZM,
  Scy: KM,
  scy: WM,
  sdotb: YM,
  sdot: JM,
  sdote: XM,
  searhk: QM,
  searr: eI,
  seArr: nI,
  searrow: tI,
  sect: rI,
  semi: oI,
  seswar: sI,
  setminus: cI,
  setmn: iI,
  sext: aI,
  Sfr: lI,
  sfr: uI,
  sfrown: fI,
  sharp: pI,
  SHCHcy: hI,
  shchcy: dI,
  SHcy: gI,
  shcy: mI,
  ShortDownArrow: _I,
  ShortLeftArrow: bI,
  shortmid: vI,
  shortparallel: kI,
  ShortRightArrow: xI,
  ShortUpArrow: yI,
  shy: EI,
  Sigma: wI,
  sigma: AI,
  sigmaf: CI,
  sigmav: SI,
  sim: DI,
  simdot: TI,
  sime: RI,
  simeq: LI,
  simg: NI,
  simgE: qI,
  siml: MI,
  simlE: II,
  simne: OI,
  simplus: FI,
  simrarr: BI,
  slarr: PI,
  SmallCircle: $I,
  smallsetminus: zI,
  smashp: UI,
  smeparsl: HI,
  smid: VI,
  smile: GI,
  smt: jI,
  smte: ZI,
  smtes: KI,
  SOFTcy: WI,
  softcy: YI,
  solbar: JI,
  solb: XI,
  sol: QI,
  Sopf: eO,
  sopf: nO,
  spades: tO,
  spadesuit: rO,
  spar: oO,
  sqcap: sO,
  sqcaps: cO,
  sqcup: iO,
  sqcups: aO,
  Sqrt: lO,
  sqsub: uO,
  sqsube: fO,
  sqsubset: pO,
  sqsubseteq: hO,
  sqsup: dO,
  sqsupe: gO,
  sqsupset: mO,
  sqsupseteq: _O,
  square: bO,
  Square: vO,
  SquareIntersection: kO,
  SquareSubset: xO,
  SquareSubsetEqual: yO,
  SquareSuperset: EO,
  SquareSupersetEqual: wO,
  SquareUnion: AO,
  squarf: CO,
  squ: SO,
  squf: DO,
  srarr: TO,
  Sscr: RO,
  sscr: LO,
  ssetmn: NO2,
  ssmile: qO,
  sstarf: MO,
  Star: IO,
  star: OO,
  starf: FO,
  straightepsilon: BO,
  straightphi: PO,
  strns: $O,
  sub: zO,
  Sub: UO,
  subdot: HO,
  subE: VO,
  sube: GO,
  subedot: jO,
  submult: ZO,
  subnE: KO,
  subne: WO,
  subplus: YO,
  subrarr: JO,
  subset: XO,
  Subset: QO,
  subseteq: eF,
  subseteqq: nF,
  SubsetEqual: tF,
  subsetneq: rF,
  subsetneqq: oF,
  subsim: sF,
  subsub: cF,
  subsup: iF,
  succapprox: aF,
  succ: lF,
  succcurlyeq: uF,
  Succeeds: fF,
  SucceedsEqual: pF,
  SucceedsSlantEqual: hF,
  SucceedsTilde: dF,
  succeq: gF,
  succnapprox: mF,
  succneqq: _F,
  succnsim: bF,
  succsim: vF,
  SuchThat: kF,
  sum: xF,
  Sum: yF,
  sung: EF,
  sup1: wF,
  sup2: AF,
  sup3: CF,
  sup: SF,
  Sup: DF,
  supdot: TF,
  supdsub: RF,
  supE: LF,
  supe: NF,
  supedot: qF,
  Superset: MF,
  SupersetEqual: IF,
  suphsol: OF,
  suphsub: FF,
  suplarr: BF,
  supmult: PF,
  supnE: $F,
  supne: zF,
  supplus: UF,
  supset: HF,
  Supset: VF,
  supseteq: GF,
  supseteqq: jF,
  supsetneq: ZF,
  supsetneqq: KF,
  supsim: WF,
  supsub: YF,
  supsup: JF,
  swarhk: XF,
  swarr: QF,
  swArr: eB,
  swarrow: nB,
  swnwar: tB,
  szlig: rB,
  Tab: oB,
  target: sB,
  Tau: cB,
  tau: iB,
  tbrk: aB,
  Tcaron: lB,
  tcaron: uB,
  Tcedil: fB,
  tcedil: pB,
  Tcy: hB,
  tcy: dB,
  tdot: gB,
  telrec: mB,
  Tfr: _B,
  tfr: bB,
  there4: vB,
  therefore: kB,
  Therefore: xB,
  Theta: yB,
  theta: EB,
  thetasym: wB,
  thetav: AB,
  thickapprox: CB,
  thicksim: SB,
  ThickSpace: DB,
  ThinSpace: TB,
  thinsp: RB,
  thkap: LB,
  thksim: NB,
  THORN: qB,
  thorn: MB,
  tilde: IB,
  Tilde: OB,
  TildeEqual: FB,
  TildeFullEqual: BB,
  TildeTilde: PB,
  timesbar: $B,
  timesb: zB,
  times: UB,
  timesd: HB,
  tint: VB,
  toea: GB,
  topbot: jB,
  topcir: ZB,
  top: KB,
  Topf: WB,
  topf: YB,
  topfork: JB,
  tosa: XB,
  tprime: QB,
  trade: eP,
  TRADE: nP,
  triangle: tP,
  triangledown: rP,
  triangleleft: oP,
  trianglelefteq: sP,
  triangleq: cP,
  triangleright: iP,
  trianglerighteq: aP,
  tridot: lP,
  trie: uP,
  triminus: fP,
  TripleDot: pP,
  triplus: hP,
  trisb: dP,
  tritime: gP,
  trpezium: mP,
  Tscr: _P,
  tscr: bP,
  TScy: vP,
  tscy: kP,
  TSHcy: xP,
  tshcy: yP,
  Tstrok: EP,
  tstrok: wP,
  twixt: AP,
  twoheadleftarrow: CP,
  twoheadrightarrow: SP,
  Uacute: DP,
  uacute: TP,
  uarr: RP,
  Uarr: LP,
  uArr: NP,
  Uarrocir: qP,
  Ubrcy: MP,
  ubrcy: IP,
  Ubreve: OP,
  ubreve: FP,
  Ucirc: BP,
  ucirc: PP,
  Ucy: $P,
  ucy: zP,
  udarr: UP,
  Udblac: HP,
  udblac: VP,
  udhar: GP,
  ufisht: jP,
  Ufr: ZP,
  ufr: KP,
  Ugrave: WP,
  ugrave: YP,
  uHar: JP,
  uharl: XP,
  uharr: QP,
  uhblk: e$,
  ulcorn: n$,
  ulcorner: t$,
  ulcrop: r$,
  ultri: o$,
  Umacr: s$,
  umacr: c$,
  uml: i$,
  UnderBar: a$,
  UnderBrace: l$,
  UnderBracket: u$,
  UnderParenthesis: f$,
  Union: p$,
  UnionPlus: h$,
  Uogon: d$,
  uogon: g$,
  Uopf: m$,
  uopf: _$,
  UpArrowBar: b$,
  uparrow: v$,
  UpArrow: k$,
  Uparrow: x$,
  UpArrowDownArrow: y$,
  updownarrow: E$,
  UpDownArrow: w$,
  Updownarrow: A$,
  UpEquilibrium: C$,
  upharpoonleft: S$,
  upharpoonright: D$,
  uplus: T$,
  UpperLeftArrow: R$,
  UpperRightArrow: L$,
  upsi: N$,
  Upsi: q$,
  upsih: M$,
  Upsilon: I$,
  upsilon: O$,
  UpTeeArrow: F$,
  UpTee: B$,
  upuparrows: P$,
  urcorn: $$,
  urcorner: z$,
  urcrop: U$,
  Uring: H$,
  uring: V$,
  urtri: G$,
  Uscr: j$,
  uscr: Z$,
  utdot: K$,
  Utilde: W$,
  utilde: Y$,
  utri: J$,
  utrif: X$,
  uuarr: Q$,
  Uuml: ez,
  uuml: nz,
  uwangle: tz,
  vangrt: rz,
  varepsilon: oz,
  varkappa: sz,
  varnothing: cz,
  varphi: iz,
  varpi: az,
  varpropto: lz,
  varr: uz,
  vArr: fz,
  varrho: pz,
  varsigma: hz,
  varsubsetneq: dz,
  varsubsetneqq: gz,
  varsupsetneq: mz,
  varsupsetneqq: _z,
  vartheta: bz,
  vartriangleleft: vz,
  vartriangleright: kz,
  vBar: xz,
  Vbar: yz,
  vBarv: Ez,
  Vcy: wz,
  vcy: Az,
  vdash: Cz,
  vDash: Sz,
  Vdash: Dz,
  VDash: Tz,
  Vdashl: Rz,
  veebar: Lz,
  vee: Nz,
  Vee: qz,
  veeeq: Mz,
  vellip: Iz,
  verbar: Oz,
  Verbar: Fz,
  vert: Bz,
  Vert: Pz,
  VerticalBar: $z,
  VerticalLine: zz,
  VerticalSeparator: Uz,
  VerticalTilde: Hz,
  VeryThinSpace: Vz,
  Vfr: Gz,
  vfr: jz,
  vltri: Zz,
  vnsub: Kz,
  vnsup: Wz,
  Vopf: Yz,
  vopf: Jz,
  vprop: Xz,
  vrtri: Qz,
  Vscr: e3,
  vscr: n3,
  vsubnE: t3,
  vsubne: r3,
  vsupnE: o3,
  vsupne: s3,
  Vvdash: c3,
  vzigzag: i3,
  Wcirc: a3,
  wcirc: l3,
  wedbar: u3,
  wedge: f3,
  Wedge: p3,
  wedgeq: h3,
  weierp: d3,
  Wfr: g3,
  wfr: m3,
  Wopf: _3,
  wopf: b3,
  wp: v3,
  wr: k3,
  wreath: x3,
  Wscr: y3,
  wscr: E3,
  xcap: w3,
  xcirc: A3,
  xcup: C3,
  xdtri: S3,
  Xfr: D3,
  xfr: T3,
  xharr: R3,
  xhArr: L3,
  Xi: N3,
  xi: q3,
  xlarr: M3,
  xlArr: I3,
  xmap: O3,
  xnis: F3,
  xodot: B3,
  Xopf: P3,
  xopf: $3,
  xoplus: z3,
  xotime: U3,
  xrarr: H3,
  xrArr: V3,
  Xscr: G3,
  xscr: j3,
  xsqcup: Z3,
  xuplus: K3,
  xutri: W3,
  xvee: Y3,
  xwedge: J3,
  Yacute: X3,
  yacute: Q3,
  YAcy: eU,
  yacy: nU,
  Ycirc: tU,
  ycirc: rU,
  Ycy: oU,
  ycy: sU,
  yen: cU,
  Yfr: iU,
  yfr: aU,
  YIcy: lU,
  yicy: uU,
  Yopf: fU,
  yopf: pU,
  Yscr: hU,
  yscr: dU,
  YUcy: gU,
  yucy: mU,
  yuml: _U,
  Yuml: bU,
  Zacute: vU,
  zacute: kU,
  Zcaron: xU,
  zcaron: yU,
  Zcy: EU,
  zcy: wU,
  Zdot: AU,
  zdot: CU,
  zeetrf: SU,
  ZeroWidthSpace: DU,
  Zeta: TU,
  zeta: RU,
  zfr: LU,
  Zfr: NU,
  ZHcy: qU,
  zhcy: MU,
  zigrarr: IU,
  zopf: OU,
  Zopf: FU,
  Zscr: BU,
  zscr: PU,
  zwj: $U,
  zwnj: zU
};
var zr = UU;
var Jn = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
var Me = {};
var wt = {};
function HU(n) {
  var e, t, r = wt[n];
  if (r)
    return r;
  for (r = wt[n] = [], e = 0; e < 128; e++)
    t = String.fromCharCode(e), /^[0-9a-z]$/i.test(t) ? r.push(t) : r.push("%" + ("0" + e.toString(16).toUpperCase()).slice(-2));
  for (e = 0; e < n.length; e++)
    r[n.charCodeAt(e)] = n[e];
  return r;
}
function pn(n, e, t) {
  var r, o, s, i, c, a = "";
  for (typeof e != "string" && (t = e, e = pn.defaultChars), typeof t > "u" && (t = true), c = HU(e), r = 0, o = n.length; r < o; r++) {
    if (s = n.charCodeAt(r), t && s === 37 && r + 2 < o && /^[0-9a-f]{2}$/i.test(n.slice(r + 1, r + 3))) {
      a += n.slice(r, r + 3), r += 2;
      continue;
    }
    if (s < 128) {
      a += c[s];
      continue;
    }
    if (s >= 55296 && s <= 57343) {
      if (s >= 55296 && s <= 56319 && r + 1 < o && (i = n.charCodeAt(r + 1), i >= 56320 && i <= 57343)) {
        a += encodeURIComponent(n[r] + n[r + 1]), r++;
        continue;
      }
      a += "%EF%BF%BD";
      continue;
    }
    a += encodeURIComponent(n[r]);
  }
  return a;
}
pn.defaultChars = ";/?:@&=+$,-_.!~*'()#";
pn.componentChars = "-_.!~*'()";
var VU = pn;
var At = {};
function GU(n) {
  var e, t, r = At[n];
  if (r)
    return r;
  for (r = At[n] = [], e = 0; e < 128; e++)
    t = String.fromCharCode(e), r.push(t);
  for (e = 0; e < n.length; e++)
    t = n.charCodeAt(e), r[t] = "%" + ("0" + t.toString(16).toUpperCase()).slice(-2);
  return r;
}
function hn(n, e) {
  var t;
  return typeof e != "string" && (e = hn.defaultChars), t = GU(e), n.replace(/(%[a-f0-9]{2})+/gi, function(r) {
    var o, s, i, c, a, l, u, p5 = "";
    for (o = 0, s = r.length; o < s; o += 3) {
      if (i = parseInt(r.slice(o + 1, o + 3), 16), i < 128) {
        p5 += t[i];
        continue;
      }
      if ((i & 224) === 192 && o + 3 < s && (c = parseInt(r.slice(o + 4, o + 6), 16), (c & 192) === 128)) {
        u = i << 6 & 1984 | c & 63, u < 128 ? p5 += "��" : p5 += String.fromCharCode(u), o += 3;
        continue;
      }
      if ((i & 240) === 224 && o + 6 < s && (c = parseInt(r.slice(o + 4, o + 6), 16), a = parseInt(r.slice(o + 7, o + 9), 16), (c & 192) === 128 && (a & 192) === 128)) {
        u = i << 12 & 61440 | c << 6 & 4032 | a & 63, u < 2048 || u >= 55296 && u <= 57343 ? p5 += "���" : p5 += String.fromCharCode(u), o += 6;
        continue;
      }
      if ((i & 248) === 240 && o + 9 < s && (c = parseInt(r.slice(o + 4, o + 6), 16), a = parseInt(r.slice(o + 7, o + 9), 16), l = parseInt(r.slice(o + 10, o + 12), 16), (c & 192) === 128 && (a & 192) === 128 && (l & 192) === 128)) {
        u = i << 18 & 1835008 | c << 12 & 258048 | a << 6 & 4032 | l & 63, u < 65536 || u > 1114111 ? p5 += "����" : (u -= 65536, p5 += String.fromCharCode(55296 + (u >> 10), 56320 + (u & 1023))), o += 9;
        continue;
      }
      p5 += "�";
    }
    return p5;
  });
}
hn.defaultChars = ";/?:@&=+$,#";
hn.componentChars = "";
var jU = hn;
var ZU = function(e) {
  var t = "";
  return t += e.protocol || "", t += e.slashes ? "//" : "", t += e.auth ? e.auth + "@" : "", e.hostname && e.hostname.indexOf(":") !== -1 ? t += "[" + e.hostname + "]" : t += e.hostname || "", t += e.port ? ":" + e.port : "", t += e.pathname || "", t += e.search || "", t += e.hash || "", t;
};
function cn() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
var KU = /^([a-z0-9.+-]+:)/i;
var WU = /:[0-9]*$/;
var YU = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
var JU = ["<", ">", '"', "`", " ", "\r", `
`, "	"];
var XU = ["{", "}", "|", "\\", "^", "`"].concat(JU);
var QU = ["'"].concat(XU);
var Ct = ["%", "/", "?", ";", "#"].concat(QU);
var St = ["/", "?", "#"];
var e9 = 255;
var Dt = /^[+a-z0-9A-Z_-]{0,63}$/;
var n9 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
var Tt = {
  javascript: true,
  "javascript:": true
};
var Rt = {
  http: true,
  https: true,
  ftp: true,
  gopher: true,
  file: true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
};
function t9(n, e) {
  if (n && n instanceof cn)
    return n;
  var t = new cn();
  return t.parse(n, e), t;
}
cn.prototype.parse = function(n, e) {
  var t, r, o, s, i, c = n;
  if (c = c.trim(), !e && n.split("#").length === 1) {
    var a = YU.exec(c);
    if (a)
      return this.pathname = a[1], a[2] && (this.search = a[2]), this;
  }
  var l = KU.exec(c);
  if (l && (l = l[0], o = l.toLowerCase(), this.protocol = l, c = c.substr(l.length)), (e || l || c.match(/^\/\/[^@\/]+@[^@\/]+/)) && (i = c.substr(0, 2) === "//", i && !(l && Tt[l]) && (c = c.substr(2), this.slashes = true)), !Tt[l] && (i || l && !Rt[l])) {
    var u = -1;
    for (t = 0; t < St.length; t++)
      s = c.indexOf(St[t]), s !== -1 && (u === -1 || s < u) && (u = s);
    var p5, f;
    for (u === -1 ? f = c.lastIndexOf("@") : f = c.lastIndexOf("@", u), f !== -1 && (p5 = c.slice(0, f), c = c.slice(f + 1), this.auth = p5), u = -1, t = 0; t < Ct.length; t++)
      s = c.indexOf(Ct[t]), s !== -1 && (u === -1 || s < u) && (u = s);
    u === -1 && (u = c.length), c[u - 1] === ":" && u--;
    var h5 = c.slice(0, u);
    c = c.slice(u), this.parseHost(h5), this.hostname = this.hostname || "";
    var d = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!d) {
      var g = this.hostname.split(/\./);
      for (t = 0, r = g.length; t < r; t++) {
        var E = g[t];
        if (E && !E.match(Dt)) {
          for (var x = "", b = 0, A = E.length; b < A; b++)
            E.charCodeAt(b) > 127 ? x += "x" : x += E[b];
          if (!x.match(Dt)) {
            var D = g.slice(0, t), L = g.slice(t + 1), v = E.match(n9);
            v && (D.push(v[1]), L.unshift(v[2])), L.length && (c = L.join(".") + c), this.hostname = D.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > e9 && (this.hostname = ""), d && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  var O = c.indexOf("#");
  O !== -1 && (this.hash = c.substr(O), c = c.slice(0, O));
  var z = c.indexOf("?");
  return z !== -1 && (this.search = c.substr(z), c = c.slice(0, z)), c && (this.pathname = c), Rt[o] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
cn.prototype.parseHost = function(n) {
  var e = WU.exec(n);
  e && (e = e[0], e !== ":" && (this.port = e.substr(1)), n = n.substr(0, n.length - e.length)), n && (this.hostname = n);
};
var r9 = t9;
Me.encode = VU;
Me.decode = jU;
Me.format = ZU;
Me.parse = r9;
var Ee = {};
var Cn;
var Lt;
function Ur() {
  return Lt || (Lt = 1, Cn = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/), Cn;
}
var Sn;
var Nt;
function Hr() {
  return Nt || (Nt = 1, Sn = /[\0-\x1F\x7F-\x9F]/), Sn;
}
var Dn;
var qt;
function o9() {
  return qt || (qt = 1, Dn = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/), Dn;
}
var Tn;
var Mt;
function Vr() {
  return Mt || (Mt = 1, Tn = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/), Tn;
}
var It;
function s9() {
  return It || (It = 1, Ee.Any = Ur(), Ee.Cc = Hr(), Ee.Cf = o9(), Ee.P = Jn, Ee.Z = Vr()), Ee;
}
(function(n) {
  function e(_) {
    return Object.prototype.toString.call(_);
  }
  function t(_) {
    return e(_) === "[object String]";
  }
  var r = Object.prototype.hasOwnProperty;
  function o(_, T) {
    return r.call(_, T);
  }
  function s(_) {
    var T = Array.prototype.slice.call(arguments, 1);
    return T.forEach(function(w) {
      if (w) {
        if (typeof w != "object")
          throw new TypeError(w + "must be object");
        Object.keys(w).forEach(function(m) {
          _[m] = w[m];
        });
      }
    }), _;
  }
  function i(_, T, w) {
    return [].concat(_.slice(0, T), w, _.slice(T + 1));
  }
  function c(_) {
    return !(_ >= 55296 && _ <= 57343 || _ >= 64976 && _ <= 65007 || (_ & 65535) === 65535 || (_ & 65535) === 65534 || _ >= 0 && _ <= 8 || _ === 11 || _ >= 14 && _ <= 31 || _ >= 127 && _ <= 159 || _ > 1114111);
  }
  function a(_) {
    if (_ > 65535) {
      _ -= 65536;
      var T = 55296 + (_ >> 10), w = 56320 + (_ & 1023);
      return String.fromCharCode(T, w);
    }
    return String.fromCharCode(_);
  }
  var l = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g, u = /&([a-z#][a-z0-9]{1,31});/gi, p5 = new RegExp(l.source + "|" + u.source, "gi"), f = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i, h5 = zr;
  function d(_, T) {
    var w;
    return o(h5, T) ? h5[T] : T.charCodeAt(0) === 35 && f.test(T) && (w = T[1].toLowerCase() === "x" ? parseInt(T.slice(2), 16) : parseInt(T.slice(1), 10), c(w)) ? a(w) : _;
  }
  function g(_) {
    return _.indexOf("\\") < 0 ? _ : _.replace(l, "$1");
  }
  function E(_) {
    return _.indexOf("\\") < 0 && _.indexOf("&") < 0 ? _ : _.replace(p5, function(T, w, m) {
      return w || d(T, m);
    });
  }
  var x = /[&<>"]/, b = /[&<>"]/g, A = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;"
  };
  function D(_) {
    return A[_];
  }
  function L(_) {
    return x.test(_) ? _.replace(b, D) : _;
  }
  var v = /[.?*+^$[\]\\(){}|-]/g;
  function O(_) {
    return _.replace(v, "\\$&");
  }
  function z(_) {
    switch (_) {
      case 9:
      case 32:
        return true;
    }
    return false;
  }
  function j(_) {
    if (_ >= 8192 && _ <= 8202)
      return true;
    switch (_) {
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 32:
      case 160:
      case 5760:
      case 8239:
      case 8287:
      case 12288:
        return true;
    }
    return false;
  }
  var M = Jn;
  function K(_) {
    return M.test(_);
  }
  function q(_) {
    switch (_) {
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 124:
      case 125:
      case 126:
        return true;
      default:
        return false;
    }
  }
  function Z(_) {
    return _ = _.trim().replace(/\s+/g, " "), "ẞ".toLowerCase() === "Ṿ" && (_ = _.replace(/ẞ/g, "ß")), _.toLowerCase().toUpperCase();
  }
  n.lib = {}, n.lib.mdurl = Me, n.lib.ucmicro = s9(), n.assign = s, n.isString = t, n.has = o, n.unescapeMd = g, n.unescapeAll = E, n.isValidEntityCode = c, n.fromCodePoint = a, n.escapeHtml = L, n.arrayReplaceAt = i, n.isSpace = z, n.isWhiteSpace = j, n.isMdAsciiPunct = q, n.isPunctChar = K, n.escapeRE = O, n.normalizeReference = Z;
})($);
var dn = {};
var c9 = function(e, t, r) {
  var o, s, i, c, a = -1, l = e.posMax, u = e.pos;
  for (e.pos = t + 1, o = 1; e.pos < l; ) {
    if (i = e.src.charCodeAt(e.pos), i === 93 && (o--, o === 0)) {
      s = true;
      break;
    }
    if (c = e.pos, e.md.inline.skipToken(e), i === 91) {
      if (c === e.pos - 1)
        o++;
      else if (r)
        return e.pos = u, -1;
    }
  }
  return s && (a = e.pos), e.pos = u, a;
};
var Ot = $.unescapeAll;
var i9 = function(e, t, r) {
  var o, s, i = t, c = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (e.charCodeAt(i) === 60) {
    for (i++; i < r; ) {
      if (o = e.charCodeAt(i), o === 10 || o === 60)
        return c;
      if (o === 62)
        return c.pos = i + 1, c.str = Ot(e.slice(t + 1, i)), c.ok = true, c;
      if (o === 92 && i + 1 < r) {
        i += 2;
        continue;
      }
      i++;
    }
    return c;
  }
  for (s = 0; i < r && (o = e.charCodeAt(i), !(o === 32 || o < 32 || o === 127)); ) {
    if (o === 92 && i + 1 < r) {
      if (e.charCodeAt(i + 1) === 32)
        break;
      i += 2;
      continue;
    }
    if (o === 40 && (s++, s > 32))
      return c;
    if (o === 41) {
      if (s === 0)
        break;
      s--;
    }
    i++;
  }
  return t === i || s !== 0 || (c.str = Ot(e.slice(t, i)), c.pos = i, c.ok = true), c;
};
var a9 = $.unescapeAll;
var l9 = function(e, t, r) {
  var o, s, i = 0, c = t, a = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (c >= r || (s = e.charCodeAt(c), s !== 34 && s !== 39 && s !== 40))
    return a;
  for (c++, s === 40 && (s = 41); c < r; ) {
    if (o = e.charCodeAt(c), o === s)
      return a.pos = c + 1, a.lines = i, a.str = a9(e.slice(t + 1, c)), a.ok = true, a;
    if (o === 40 && s === 41)
      return a;
    o === 10 ? i++ : o === 92 && c + 1 < r && (c++, e.charCodeAt(c) === 10 && i++), c++;
  }
  return a;
};
dn.parseLinkLabel = c9;
dn.parseLinkDestination = i9;
dn.parseLinkTitle = l9;
var u9 = $.assign;
var f9 = $.unescapeAll;
var Se = $.escapeHtml;
var ge = {};
ge.code_inline = function(n, e, t, r, o) {
  var s = n[e];
  return "<code" + o.renderAttrs(s) + ">" + Se(s.content) + "</code>";
};
ge.code_block = function(n, e, t, r, o) {
  var s = n[e];
  return "<pre" + o.renderAttrs(s) + "><code>" + Se(n[e].content) + `</code></pre>
`;
};
ge.fence = function(n, e, t, r, o) {
  var s = n[e], i = s.info ? f9(s.info).trim() : "", c = "", a = "", l, u, p5, f, h5;
  return i && (p5 = i.split(/(\s+)/g), c = p5[0], a = p5.slice(2).join("")), t.highlight ? l = t.highlight(s.content, c, a) || Se(s.content) : l = Se(s.content), l.indexOf("<pre") === 0 ? l + `
` : i ? (u = s.attrIndex("class"), f = s.attrs ? s.attrs.slice() : [], u < 0 ? f.push(["class", t.langPrefix + c]) : (f[u] = f[u].slice(), f[u][1] += " " + t.langPrefix + c), h5 = {
    attrs: f
  }, "<pre><code" + o.renderAttrs(h5) + ">" + l + `</code></pre>
`) : "<pre><code" + o.renderAttrs(s) + ">" + l + `</code></pre>
`;
};
ge.image = function(n, e, t, r, o) {
  var s = n[e];
  return s.attrs[s.attrIndex("alt")][1] = o.renderInlineAsText(s.children, t, r), o.renderToken(n, e, t);
};
ge.hardbreak = function(n, e, t) {
  return t.xhtmlOut ? `<br />
` : `<br>
`;
};
ge.softbreak = function(n, e, t) {
  return t.breaks ? t.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
ge.text = function(n, e) {
  return Se(n[e].content);
};
ge.html_block = function(n, e) {
  return n[e].content;
};
ge.html_inline = function(n, e) {
  return n[e].content;
};
function Ie() {
  this.rules = u9({}, ge);
}
Ie.prototype.renderAttrs = function(e) {
  var t, r, o;
  if (!e.attrs)
    return "";
  for (o = "", t = 0, r = e.attrs.length; t < r; t++)
    o += " " + Se(e.attrs[t][0]) + '="' + Se(e.attrs[t][1]) + '"';
  return o;
};
Ie.prototype.renderToken = function(e, t, r) {
  var o, s = "", i = false, c = e[t];
  return c.hidden ? "" : (c.block && c.nesting !== -1 && t && e[t - 1].hidden && (s += `
`), s += (c.nesting === -1 ? "</" : "<") + c.tag, s += this.renderAttrs(c), c.nesting === 0 && r.xhtmlOut && (s += " /"), c.block && (i = true, c.nesting === 1 && t + 1 < e.length && (o = e[t + 1], (o.type === "inline" || o.hidden || o.nesting === -1 && o.tag === c.tag) && (i = false))), s += i ? `>
` : ">", s);
};
Ie.prototype.renderInline = function(n, e, t) {
  for (var r, o = "", s = this.rules, i = 0, c = n.length; i < c; i++)
    r = n[i].type, typeof s[r] < "u" ? o += s[r](n, i, e, t, this) : o += this.renderToken(n, i, e);
  return o;
};
Ie.prototype.renderInlineAsText = function(n, e, t) {
  for (var r = "", o = 0, s = n.length; o < s; o++)
    n[o].type === "text" ? r += n[o].content : n[o].type === "image" ? r += this.renderInlineAsText(n[o].children, e, t) : n[o].type === "softbreak" && (r += `
`);
  return r;
};
Ie.prototype.render = function(n, e, t) {
  var r, o, s, i = "", c = this.rules;
  for (r = 0, o = n.length; r < o; r++)
    s = n[r].type, s === "inline" ? i += this.renderInline(n[r].children, e, t) : typeof c[s] < "u" ? i += c[s](n, r, e, t, this) : i += this.renderToken(n, r, e, t);
  return i;
};
var p9 = Ie;
function le() {
  this.__rules__ = [], this.__cache__ = null;
}
le.prototype.__find__ = function(n) {
  for (var e = 0; e < this.__rules__.length; e++)
    if (this.__rules__[e].name === n)
      return e;
  return -1;
};
le.prototype.__compile__ = function() {
  var n = this, e = [""];
  n.__rules__.forEach(function(t) {
    t.enabled && t.alt.forEach(function(r) {
      e.indexOf(r) < 0 && e.push(r);
    });
  }), n.__cache__ = {}, e.forEach(function(t) {
    n.__cache__[t] = [], n.__rules__.forEach(function(r) {
      r.enabled && (t && r.alt.indexOf(t) < 0 || n.__cache__[t].push(r.fn));
    });
  });
};
le.prototype.at = function(n, e, t) {
  var r = this.__find__(n), o = t || {};
  if (r === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__[r].fn = e, this.__rules__[r].alt = o.alt || [], this.__cache__ = null;
};
le.prototype.before = function(n, e, t, r) {
  var o = this.__find__(n), s = r || {};
  if (o === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__.splice(o, 0, {
    name: e,
    enabled: true,
    fn: t,
    alt: s.alt || []
  }), this.__cache__ = null;
};
le.prototype.after = function(n, e, t, r) {
  var o = this.__find__(n), s = r || {};
  if (o === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__.splice(o + 1, 0, {
    name: e,
    enabled: true,
    fn: t,
    alt: s.alt || []
  }), this.__cache__ = null;
};
le.prototype.push = function(n, e, t) {
  var r = t || {};
  this.__rules__.push({
    name: n,
    enabled: true,
    fn: e,
    alt: r.alt || []
  }), this.__cache__ = null;
};
le.prototype.enable = function(n, e) {
  Array.isArray(n) || (n = [n]);
  var t = [];
  return n.forEach(function(r) {
    var o = this.__find__(r);
    if (o < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + r);
    }
    this.__rules__[o].enabled = true, t.push(r);
  }, this), this.__cache__ = null, t;
};
le.prototype.enableOnly = function(n, e) {
  Array.isArray(n) || (n = [n]), this.__rules__.forEach(function(t) {
    t.enabled = false;
  }), this.enable(n, e);
};
le.prototype.disable = function(n, e) {
  Array.isArray(n) || (n = [n]);
  var t = [];
  return n.forEach(function(r) {
    var o = this.__find__(r);
    if (o < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + r);
    }
    this.__rules__[o].enabled = false, t.push(r);
  }, this), this.__cache__ = null, t;
};
le.prototype.getRules = function(n) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[n] || [];
};
var Xn = le;
var h9 = /\r\n?|\n/g;
var d9 = /\0/g;
var g9 = function(e) {
  var t;
  t = e.src.replace(h9, `
`), t = t.replace(d9, "�"), e.src = t;
};
var m9 = function(e) {
  var t;
  e.inlineMode ? (t = new e.Token("inline", "", 0), t.content = e.src, t.map = [0, 1], t.children = [], e.tokens.push(t)) : e.md.block.parse(e.src, e.md, e.env, e.tokens);
};
var _9 = function(e) {
  var t = e.tokens, r, o, s;
  for (o = 0, s = t.length; o < s; o++)
    r = t[o], r.type === "inline" && e.md.inline.parse(r.content, e.md, e.env, r.children);
};
var b9 = $.arrayReplaceAt;
function v9(n) {
  return /^<a[>\s]/i.test(n);
}
function k9(n) {
  return /^<\/a\s*>/i.test(n);
}
var x9 = function(e) {
  var t, r, o, s, i, c, a, l, u, p5, f, h5, d, g, E, x, b = e.tokens, A;
  if (e.md.options.linkify) {
    for (r = 0, o = b.length; r < o; r++)
      if (!(b[r].type !== "inline" || !e.md.linkify.pretest(b[r].content)))
        for (s = b[r].children, d = 0, t = s.length - 1; t >= 0; t--) {
          if (c = s[t], c.type === "link_close") {
            for (t--; s[t].level !== c.level && s[t].type !== "link_open"; )
              t--;
            continue;
          }
          if (c.type === "html_inline" && (v9(c.content) && d > 0 && d--, k9(c.content) && d++), !(d > 0) && c.type === "text" && e.md.linkify.test(c.content)) {
            for (u = c.content, A = e.md.linkify.match(u), a = [], h5 = c.level, f = 0, A.length > 0 && A[0].index === 0 && t > 0 && s[t - 1].type === "text_special" && (A = A.slice(1)), l = 0; l < A.length; l++)
              g = A[l].url, E = e.md.normalizeLink(g), e.md.validateLink(E) && (x = A[l].text, A[l].schema ? A[l].schema === "mailto:" && !/^mailto:/i.test(x) ? x = e.md.normalizeLinkText("mailto:" + x).replace(/^mailto:/, "") : x = e.md.normalizeLinkText(x) : x = e.md.normalizeLinkText("http://" + x).replace(/^http:\/\//, ""), p5 = A[l].index, p5 > f && (i = new e.Token("text", "", 0), i.content = u.slice(f, p5), i.level = h5, a.push(i)), i = new e.Token("link_open", "a", 1), i.attrs = [["href", E]], i.level = h5++, i.markup = "linkify", i.info = "auto", a.push(i), i = new e.Token("text", "", 0), i.content = x, i.level = h5, a.push(i), i = new e.Token("link_close", "a", -1), i.level = --h5, i.markup = "linkify", i.info = "auto", a.push(i), f = A[l].lastIndex);
            f < u.length && (i = new e.Token("text", "", 0), i.content = u.slice(f), i.level = h5, a.push(i)), b[r].children = s = b9(s, t, a);
          }
        }
  }
};
var Gr = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
var y9 = /\((c|tm|r)\)/i;
var E9 = /\((c|tm|r)\)/ig;
var w9 = {
  c: "©",
  r: "®",
  tm: "™"
};
function A9(n, e) {
  return w9[e.toLowerCase()];
}
function C9(n) {
  var e, t, r = 0;
  for (e = n.length - 1; e >= 0; e--)
    t = n[e], t.type === "text" && !r && (t.content = t.content.replace(E9, A9)), t.type === "link_open" && t.info === "auto" && r--, t.type === "link_close" && t.info === "auto" && r++;
}
function S9(n) {
  var e, t, r = 0;
  for (e = n.length - 1; e >= 0; e--)
    t = n[e], t.type === "text" && !r && Gr.test(t.content) && (t.content = t.content.replace(/\+-/g, "±").replace(/\.{2,}/g, "…").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1—").replace(/(^|\s)--(?=\s|$)/mg, "$1–").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1–")), t.type === "link_open" && t.info === "auto" && r--, t.type === "link_close" && t.info === "auto" && r++;
}
var D9 = function(e) {
  var t;
  if (e.md.options.typographer)
    for (t = e.tokens.length - 1; t >= 0; t--)
      e.tokens[t].type === "inline" && (y9.test(e.tokens[t].content) && C9(e.tokens[t].children), Gr.test(e.tokens[t].content) && S9(e.tokens[t].children));
};
var Ft = $.isWhiteSpace;
var Bt = $.isPunctChar;
var Pt = $.isMdAsciiPunct;
var T9 = /['"]/;
var $t = /['"]/g;
var zt = "’";
function Qe(n, e, t) {
  return n.slice(0, e) + t + n.slice(e + 1);
}
function R9(n, e) {
  var t, r, o, s, i, c, a, l, u, p5, f, h5, d, g, E, x, b, A, D, L, v;
  for (D = [], t = 0; t < n.length; t++) {
    for (r = n[t], a = n[t].level, b = D.length - 1; b >= 0 && !(D[b].level <= a); b--)
      ;
    if (D.length = b + 1, r.type === "text") {
      o = r.content, i = 0, c = o.length;
      e:
        for (; i < c && ($t.lastIndex = i, s = $t.exec(o), !!s); ) {
          if (E = x = true, i = s.index + 1, A = s[0] === "'", u = 32, s.index - 1 >= 0)
            u = o.charCodeAt(s.index - 1);
          else
            for (b = t - 1; b >= 0 && !(n[b].type === "softbreak" || n[b].type === "hardbreak"); b--)
              if (n[b].content) {
                u = n[b].content.charCodeAt(n[b].content.length - 1);
                break;
              }
          if (p5 = 32, i < c)
            p5 = o.charCodeAt(i);
          else
            for (b = t + 1; b < n.length && !(n[b].type === "softbreak" || n[b].type === "hardbreak"); b++)
              if (n[b].content) {
                p5 = n[b].content.charCodeAt(0);
                break;
              }
          if (f = Pt(u) || Bt(String.fromCharCode(u)), h5 = Pt(p5) || Bt(String.fromCharCode(p5)), d = Ft(u), g = Ft(p5), g ? E = false : h5 && (d || f || (E = false)), d ? x = false : f && (g || h5 || (x = false)), p5 === 34 && s[0] === '"' && u >= 48 && u <= 57 && (x = E = false), E && x && (E = f, x = h5), !E && !x) {
            A && (r.content = Qe(r.content, s.index, zt));
            continue;
          }
          if (x) {
            for (b = D.length - 1; b >= 0 && (l = D[b], !(D[b].level < a)); b--)
              if (l.single === A && D[b].level === a) {
                l = D[b], A ? (L = e.md.options.quotes[2], v = e.md.options.quotes[3]) : (L = e.md.options.quotes[0], v = e.md.options.quotes[1]), r.content = Qe(r.content, s.index, v), n[l.token].content = Qe(
                  n[l.token].content,
                  l.pos,
                  L
                ), i += v.length - 1, l.token === t && (i += L.length - 1), o = r.content, c = o.length, D.length = b;
                continue e;
              }
          }
          E ? D.push({
            token: t,
            pos: s.index,
            single: A,
            level: a
          }) : x && A && (r.content = Qe(r.content, s.index, zt));
        }
    }
  }
}
var L9 = function(e) {
  var t;
  if (e.md.options.typographer)
    for (t = e.tokens.length - 1; t >= 0; t--)
      e.tokens[t].type !== "inline" || !T9.test(e.tokens[t].content) || R9(e.tokens[t].children, e);
};
var N9 = function(e) {
  var t, r, o, s, i, c, a = e.tokens;
  for (t = 0, r = a.length; t < r; t++)
    if (a[t].type === "inline") {
      for (o = a[t].children, i = o.length, s = 0; s < i; s++)
        o[s].type === "text_special" && (o[s].type = "text");
      for (s = c = 0; s < i; s++)
        o[s].type === "text" && s + 1 < i && o[s + 1].type === "text" ? o[s + 1].content = o[s].content + o[s + 1].content : (s !== c && (o[c] = o[s]), c++);
      s !== c && (o.length = c);
    }
};
function Oe(n, e, t) {
  this.type = n, this.tag = e, this.attrs = null, this.map = null, this.nesting = t, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = false, this.hidden = false;
}
Oe.prototype.attrIndex = function(e) {
  var t, r, o;
  if (!this.attrs)
    return -1;
  for (t = this.attrs, r = 0, o = t.length; r < o; r++)
    if (t[r][0] === e)
      return r;
  return -1;
};
Oe.prototype.attrPush = function(e) {
  this.attrs ? this.attrs.push(e) : this.attrs = [e];
};
Oe.prototype.attrSet = function(e, t) {
  var r = this.attrIndex(e), o = [e, t];
  r < 0 ? this.attrPush(o) : this.attrs[r] = o;
};
Oe.prototype.attrGet = function(e) {
  var t = this.attrIndex(e), r = null;
  return t >= 0 && (r = this.attrs[t][1]), r;
};
Oe.prototype.attrJoin = function(e, t) {
  var r = this.attrIndex(e);
  r < 0 ? this.attrPush([e, t]) : this.attrs[r][1] = this.attrs[r][1] + " " + t;
};
var Qn = Oe;
var q9 = Qn;
function jr(n, e, t) {
  this.src = n, this.env = t, this.tokens = [], this.inlineMode = false, this.md = e;
}
jr.prototype.Token = q9;
var M9 = jr;
var I9 = Xn;
var Rn = [
  ["normalize", g9],
  ["block", m9],
  ["inline", _9],
  ["linkify", x9],
  ["replacements", D9],
  ["smartquotes", L9],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", N9]
];
function et() {
  this.ruler = new I9();
  for (var n = 0; n < Rn.length; n++)
    this.ruler.push(Rn[n][0], Rn[n][1]);
}
et.prototype.process = function(n) {
  var e, t, r;
  for (r = this.ruler.getRules(""), e = 0, t = r.length; e < t; e++)
    r[e](n);
};
et.prototype.State = M9;
var O9 = et;
var Ln = $.isSpace;
function Nn(n, e) {
  var t = n.bMarks[e] + n.tShift[e], r = n.eMarks[e];
  return n.src.slice(t, r);
}
function Ut(n) {
  var e = [], t = 0, r = n.length, o, s = false, i = 0, c = "";
  for (o = n.charCodeAt(t); t < r; )
    o === 124 && (s ? (c += n.substring(i, t - 1), i = t) : (e.push(c + n.substring(i, t)), c = "", i = t + 1)), s = o === 92, t++, o = n.charCodeAt(t);
  return e.push(c + n.substring(i)), e;
}
var F9 = function(e, t, r, o) {
  var s, i, c, a, l, u, p5, f, h5, d, g, E, x, b, A, D, L, v;
  if (t + 2 > r || (u = t + 1, e.sCount[u] < e.blkIndent) || e.sCount[u] - e.blkIndent >= 4 || (c = e.bMarks[u] + e.tShift[u], c >= e.eMarks[u]) || (L = e.src.charCodeAt(c++), L !== 124 && L !== 45 && L !== 58) || c >= e.eMarks[u] || (v = e.src.charCodeAt(c++), v !== 124 && v !== 45 && v !== 58 && !Ln(v)) || L === 45 && Ln(v))
    return false;
  for (; c < e.eMarks[u]; ) {
    if (s = e.src.charCodeAt(c), s !== 124 && s !== 45 && s !== 58 && !Ln(s))
      return false;
    c++;
  }
  for (i = Nn(e, t + 1), p5 = i.split("|"), d = [], a = 0; a < p5.length; a++) {
    if (g = p5[a].trim(), !g) {
      if (a === 0 || a === p5.length - 1)
        continue;
      return false;
    }
    if (!/^:?-+:?$/.test(g))
      return false;
    g.charCodeAt(g.length - 1) === 58 ? d.push(g.charCodeAt(0) === 58 ? "center" : "right") : g.charCodeAt(0) === 58 ? d.push("left") : d.push("");
  }
  if (i = Nn(e, t).trim(), i.indexOf("|") === -1 || e.sCount[t] - e.blkIndent >= 4 || (p5 = Ut(i), p5.length && p5[0] === "" && p5.shift(), p5.length && p5[p5.length - 1] === "" && p5.pop(), f = p5.length, f === 0 || f !== d.length))
    return false;
  if (o)
    return true;
  for (b = e.parentType, e.parentType = "table", D = e.md.block.ruler.getRules("blockquote"), h5 = e.push("table_open", "table", 1), h5.map = E = [t, 0], h5 = e.push("thead_open", "thead", 1), h5.map = [t, t + 1], h5 = e.push("tr_open", "tr", 1), h5.map = [t, t + 1], a = 0; a < p5.length; a++)
    h5 = e.push("th_open", "th", 1), d[a] && (h5.attrs = [["style", "text-align:" + d[a]]]), h5 = e.push("inline", "", 0), h5.content = p5[a].trim(), h5.children = [], h5 = e.push("th_close", "th", -1);
  for (h5 = e.push("tr_close", "tr", -1), h5 = e.push("thead_close", "thead", -1), u = t + 2; u < r && !(e.sCount[u] < e.blkIndent); u++) {
    for (A = false, a = 0, l = D.length; a < l; a++)
      if (D[a](e, u, r, true)) {
        A = true;
        break;
      }
    if (A || (i = Nn(e, u).trim(), !i) || e.sCount[u] - e.blkIndent >= 4)
      break;
    for (p5 = Ut(i), p5.length && p5[0] === "" && p5.shift(), p5.length && p5[p5.length - 1] === "" && p5.pop(), u === t + 2 && (h5 = e.push("tbody_open", "tbody", 1), h5.map = x = [t + 2, 0]), h5 = e.push("tr_open", "tr", 1), h5.map = [u, u + 1], a = 0; a < f; a++)
      h5 = e.push("td_open", "td", 1), d[a] && (h5.attrs = [["style", "text-align:" + d[a]]]), h5 = e.push("inline", "", 0), h5.content = p5[a] ? p5[a].trim() : "", h5.children = [], h5 = e.push("td_close", "td", -1);
    h5 = e.push("tr_close", "tr", -1);
  }
  return x && (h5 = e.push("tbody_close", "tbody", -1), x[1] = u), h5 = e.push("table_close", "table", -1), E[1] = u, e.parentType = b, e.line = u, true;
};
var B9 = function(e, t, r) {
  var o, s, i;
  if (e.sCount[t] - e.blkIndent < 4)
    return false;
  for (s = o = t + 1; o < r; ) {
    if (e.isEmpty(o)) {
      o++;
      continue;
    }
    if (e.sCount[o] - e.blkIndent >= 4) {
      o++, s = o;
      continue;
    }
    break;
  }
  return e.line = s, i = e.push("code_block", "code", 0), i.content = e.getLines(t, s, 4 + e.blkIndent, false) + `
`, i.map = [t, e.line], true;
};
var P9 = function(e, t, r, o) {
  var s, i, c, a, l, u, p5, f = false, h5 = e.bMarks[t] + e.tShift[t], d = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || h5 + 3 > d || (s = e.src.charCodeAt(h5), s !== 126 && s !== 96) || (l = h5, h5 = e.skipChars(h5, s), i = h5 - l, i < 3) || (p5 = e.src.slice(l, h5), c = e.src.slice(h5, d), s === 96 && c.indexOf(String.fromCharCode(s)) >= 0))
    return false;
  if (o)
    return true;
  for (a = t; a++, !(a >= r || (h5 = l = e.bMarks[a] + e.tShift[a], d = e.eMarks[a], h5 < d && e.sCount[a] < e.blkIndent)); )
    if (e.src.charCodeAt(h5) === s && !(e.sCount[a] - e.blkIndent >= 4) && (h5 = e.skipChars(h5, s), !(h5 - l < i) && (h5 = e.skipSpaces(h5), !(h5 < d)))) {
      f = true;
      break;
    }
  return i = e.sCount[t], e.line = a + (f ? 1 : 0), u = e.push("fence", "code", 0), u.info = c, u.content = e.getLines(t + 1, a, i, true), u.markup = p5, u.map = [t, e.line], true;
};
var $9 = $.isSpace;
var z9 = function(e, t, r, o) {
  var s, i, c, a, l, u, p5, f, h5, d, g, E, x, b, A, D, L, v, O, z, j = e.lineMax, M = e.bMarks[t] + e.tShift[t], K = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || e.src.charCodeAt(M) !== 62)
    return false;
  if (o)
    return true;
  for (d = [], g = [], b = [], A = [], v = e.md.block.ruler.getRules("blockquote"), x = e.parentType, e.parentType = "blockquote", f = t; f < r && (z = e.sCount[f] < e.blkIndent, M = e.bMarks[f] + e.tShift[f], K = e.eMarks[f], !(M >= K)); f++) {
    if (e.src.charCodeAt(M++) === 62 && !z) {
      for (a = e.sCount[f] + 1, e.src.charCodeAt(M) === 32 ? (M++, a++, s = false, D = true) : e.src.charCodeAt(M) === 9 ? (D = true, (e.bsCount[f] + a) % 4 === 3 ? (M++, a++, s = false) : s = true) : D = false, h5 = a, d.push(e.bMarks[f]), e.bMarks[f] = M; M < K && (i = e.src.charCodeAt(M), $9(i)); ) {
        i === 9 ? h5 += 4 - (h5 + e.bsCount[f] + (s ? 1 : 0)) % 4 : h5++;
        M++;
      }
      u = M >= K, g.push(e.bsCount[f]), e.bsCount[f] = e.sCount[f] + 1 + (D ? 1 : 0), b.push(e.sCount[f]), e.sCount[f] = h5 - a, A.push(e.tShift[f]), e.tShift[f] = M - e.bMarks[f];
      continue;
    }
    if (u)
      break;
    for (L = false, c = 0, l = v.length; c < l; c++)
      if (v[c](e, f, r, true)) {
        L = true;
        break;
      }
    if (L) {
      e.lineMax = f, e.blkIndent !== 0 && (d.push(e.bMarks[f]), g.push(e.bsCount[f]), A.push(e.tShift[f]), b.push(e.sCount[f]), e.sCount[f] -= e.blkIndent);
      break;
    }
    d.push(e.bMarks[f]), g.push(e.bsCount[f]), A.push(e.tShift[f]), b.push(e.sCount[f]), e.sCount[f] = -1;
  }
  for (E = e.blkIndent, e.blkIndent = 0, O = e.push("blockquote_open", "blockquote", 1), O.markup = ">", O.map = p5 = [t, 0], e.md.block.tokenize(e, t, f), O = e.push("blockquote_close", "blockquote", -1), O.markup = ">", e.lineMax = j, e.parentType = x, p5[1] = e.line, c = 0; c < A.length; c++)
    e.bMarks[c + t] = d[c], e.tShift[c + t] = A[c], e.sCount[c + t] = b[c], e.bsCount[c + t] = g[c];
  return e.blkIndent = E, true;
};
var U9 = $.isSpace;
var H9 = function(e, t, r, o) {
  var s, i, c, a, l = e.bMarks[t] + e.tShift[t], u = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || (s = e.src.charCodeAt(l++), s !== 42 && s !== 45 && s !== 95))
    return false;
  for (i = 1; l < u; ) {
    if (c = e.src.charCodeAt(l++), c !== s && !U9(c))
      return false;
    c === s && i++;
  }
  return i < 3 ? false : (o || (e.line = t + 1, a = e.push("hr", "hr", 0), a.map = [t, e.line], a.markup = Array(i + 1).join(String.fromCharCode(s))), true);
};
var Zr = $.isSpace;
function Ht(n, e) {
  var t, r, o, s;
  return r = n.bMarks[e] + n.tShift[e], o = n.eMarks[e], t = n.src.charCodeAt(r++), t !== 42 && t !== 45 && t !== 43 || r < o && (s = n.src.charCodeAt(r), !Zr(s)) ? -1 : r;
}
function Vt(n, e) {
  var t, r = n.bMarks[e] + n.tShift[e], o = r, s = n.eMarks[e];
  if (o + 1 >= s || (t = n.src.charCodeAt(o++), t < 48 || t > 57))
    return -1;
  for (; ; ) {
    if (o >= s)
      return -1;
    if (t = n.src.charCodeAt(o++), t >= 48 && t <= 57) {
      if (o - r >= 10)
        return -1;
      continue;
    }
    if (t === 41 || t === 46)
      break;
    return -1;
  }
  return o < s && (t = n.src.charCodeAt(o), !Zr(t)) ? -1 : o;
}
function V9(n, e) {
  var t, r, o = n.level + 2;
  for (t = e + 2, r = n.tokens.length - 2; t < r; t++)
    n.tokens[t].level === o && n.tokens[t].type === "paragraph_open" && (n.tokens[t + 2].hidden = true, n.tokens[t].hidden = true, t += 2);
}
var G9 = function(e, t, r, o) {
  var s, i, c, a, l, u, p5, f, h5, d, g, E, x, b, A, D, L, v, O, z, j, M, K, q, Z, _, T, w = t, m = false, k = true;
  if (e.sCount[w] - e.blkIndent >= 4 || e.listIndent >= 0 && e.sCount[w] - e.listIndent >= 4 && e.sCount[w] < e.blkIndent)
    return false;
  if (o && e.parentType === "paragraph" && e.sCount[w] >= e.blkIndent && (m = true), (M = Vt(e, w)) >= 0) {
    if (p5 = true, q = e.bMarks[w] + e.tShift[w], x = Number(e.src.slice(q, M - 1)), m && x !== 1)
      return false;
  } else if ((M = Ht(e, w)) >= 0)
    p5 = false;
  else
    return false;
  if (m && e.skipSpaces(M) >= e.eMarks[w])
    return false;
  if (o)
    return true;
  for (E = e.src.charCodeAt(M - 1), g = e.tokens.length, p5 ? (T = e.push("ordered_list_open", "ol", 1), x !== 1 && (T.attrs = [["start", x]])) : T = e.push("bullet_list_open", "ul", 1), T.map = d = [w, 0], T.markup = String.fromCharCode(E), K = false, _ = e.md.block.ruler.getRules("list"), L = e.parentType, e.parentType = "list"; w < r; ) {
    for (j = M, b = e.eMarks[w], u = A = e.sCount[w] + M - (e.bMarks[w] + e.tShift[w]); j < b; ) {
      if (s = e.src.charCodeAt(j), s === 9)
        A += 4 - (A + e.bsCount[w]) % 4;
      else if (s === 32)
        A++;
      else
        break;
      j++;
    }
    if (i = j, i >= b ? l = 1 : l = A - u, l > 4 && (l = 1), a = u + l, T = e.push("list_item_open", "li", 1), T.markup = String.fromCharCode(E), T.map = f = [w, 0], p5 && (T.info = e.src.slice(q, M - 1)), z = e.tight, O = e.tShift[w], v = e.sCount[w], D = e.listIndent, e.listIndent = e.blkIndent, e.blkIndent = a, e.tight = true, e.tShift[w] = i - e.bMarks[w], e.sCount[w] = A, i >= b && e.isEmpty(w + 1) ? e.line = Math.min(e.line + 2, r) : e.md.block.tokenize(e, w, r, true), (!e.tight || K) && (k = false), K = e.line - w > 1 && e.isEmpty(e.line - 1), e.blkIndent = e.listIndent, e.listIndent = D, e.tShift[w] = O, e.sCount[w] = v, e.tight = z, T = e.push("list_item_close", "li", -1), T.markup = String.fromCharCode(E), w = e.line, f[1] = w, w >= r || e.sCount[w] < e.blkIndent || e.sCount[w] - e.blkIndent >= 4)
      break;
    for (Z = false, c = 0, h5 = _.length; c < h5; c++)
      if (_[c](e, w, r, true)) {
        Z = true;
        break;
      }
    if (Z)
      break;
    if (p5) {
      if (M = Vt(e, w), M < 0)
        break;
      q = e.bMarks[w] + e.tShift[w];
    } else if (M = Ht(e, w), M < 0)
      break;
    if (E !== e.src.charCodeAt(M - 1))
      break;
  }
  return p5 ? T = e.push("ordered_list_close", "ol", -1) : T = e.push("bullet_list_close", "ul", -1), T.markup = String.fromCharCode(E), d[1] = w, e.line = w, e.parentType = L, k && V9(e, g), true;
};
var j9 = $.normalizeReference;
var en = $.isSpace;
var Z9 = function(e, t, r, o) {
  var s, i, c, a, l, u, p5, f, h5, d, g, E, x, b, A, D, L = 0, v = e.bMarks[t] + e.tShift[t], O = e.eMarks[t], z = t + 1;
  if (e.sCount[t] - e.blkIndent >= 4 || e.src.charCodeAt(v) !== 91)
    return false;
  for (; ++v < O; )
    if (e.src.charCodeAt(v) === 93 && e.src.charCodeAt(v - 1) !== 92) {
      if (v + 1 === O || e.src.charCodeAt(v + 1) !== 58)
        return false;
      break;
    }
  for (a = e.lineMax, A = e.md.block.ruler.getRules("reference"), d = e.parentType, e.parentType = "reference"; z < a && !e.isEmpty(z); z++)
    if (!(e.sCount[z] - e.blkIndent > 3) && !(e.sCount[z] < 0)) {
      for (b = false, u = 0, p5 = A.length; u < p5; u++)
        if (A[u](e, z, a, true)) {
          b = true;
          break;
        }
      if (b)
        break;
    }
  for (x = e.getLines(t, z, e.blkIndent, false).trim(), O = x.length, v = 1; v < O; v++) {
    if (s = x.charCodeAt(v), s === 91)
      return false;
    if (s === 93) {
      h5 = v;
      break;
    } else
      s === 10 ? L++ : s === 92 && (v++, v < O && x.charCodeAt(v) === 10 && L++);
  }
  if (h5 < 0 || x.charCodeAt(h5 + 1) !== 58)
    return false;
  for (v = h5 + 2; v < O; v++)
    if (s = x.charCodeAt(v), s === 10)
      L++;
    else if (!en(s))
      break;
  if (g = e.md.helpers.parseLinkDestination(x, v, O), !g.ok || (l = e.md.normalizeLink(g.str), !e.md.validateLink(l)))
    return false;
  for (v = g.pos, L += g.lines, i = v, c = L, E = v; v < O; v++)
    if (s = x.charCodeAt(v), s === 10)
      L++;
    else if (!en(s))
      break;
  for (g = e.md.helpers.parseLinkTitle(x, v, O), v < O && E !== v && g.ok ? (D = g.str, v = g.pos, L += g.lines) : (D = "", v = i, L = c); v < O && (s = x.charCodeAt(v), !!en(s)); )
    v++;
  if (v < O && x.charCodeAt(v) !== 10 && D)
    for (D = "", v = i, L = c; v < O && (s = x.charCodeAt(v), !!en(s)); )
      v++;
  return v < O && x.charCodeAt(v) !== 10 || (f = j9(x.slice(1, h5)), !f) ? false : (o || (typeof e.env.references > "u" && (e.env.references = {}), typeof e.env.references[f] > "u" && (e.env.references[f] = { title: D, href: l }), e.parentType = d, e.line = t + L + 1), true);
};
var K9 = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "source",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var gn = {};
var W9 = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var Y9 = "[^\"'=<>`\\x00-\\x20]+";
var J9 = "'[^']*'";
var X9 = '"[^"]*"';
var Q9 = "(?:" + Y9 + "|" + J9 + "|" + X9 + ")";
var e4 = "(?:\\s+" + W9 + "(?:\\s*=\\s*" + Q9 + ")?)";
var Kr = "<[A-Za-z][A-Za-z0-9\\-]*" + e4 + "*\\s*\\/?>";
var Wr = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
var n4 = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
var t4 = "<[?][\\s\\S]*?[?]>";
var r4 = "<![A-Z]+\\s+[^>]*>";
var o4 = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var s4 = new RegExp("^(?:" + Kr + "|" + Wr + "|" + n4 + "|" + t4 + "|" + r4 + "|" + o4 + ")");
var c4 = new RegExp("^(?:" + Kr + "|" + Wr + ")");
gn.HTML_TAG_RE = s4;
gn.HTML_OPEN_CLOSE_TAG_RE = c4;
var i4 = K9;
var a4 = gn.HTML_OPEN_CLOSE_TAG_RE;
var Re = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
  [/^<!--/, /-->/, true],
  [/^<\?/, /\?>/, true],
  [/^<![A-Z]/, />/, true],
  [/^<!\[CDATA\[/, /\]\]>/, true],
  [new RegExp("^</?(" + i4.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
  [new RegExp(a4.source + "\\s*$"), /^$/, false]
];
var l4 = function(e, t, r, o) {
  var s, i, c, a, l = e.bMarks[t] + e.tShift[t], u = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || !e.md.options.html || e.src.charCodeAt(l) !== 60)
    return false;
  for (a = e.src.slice(l, u), s = 0; s < Re.length && !Re[s][0].test(a); s++)
    ;
  if (s === Re.length)
    return false;
  if (o)
    return Re[s][2];
  if (i = t + 1, !Re[s][1].test(a)) {
    for (; i < r && !(e.sCount[i] < e.blkIndent); i++)
      if (l = e.bMarks[i] + e.tShift[i], u = e.eMarks[i], a = e.src.slice(l, u), Re[s][1].test(a)) {
        a.length !== 0 && i++;
        break;
      }
  }
  return e.line = i, c = e.push("html_block", "", 0), c.map = [t, i], c.content = e.getLines(t, i, e.blkIndent, true), true;
};
var Gt = $.isSpace;
var u4 = function(e, t, r, o) {
  var s, i, c, a, l = e.bMarks[t] + e.tShift[t], u = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || (s = e.src.charCodeAt(l), s !== 35 || l >= u))
    return false;
  for (i = 1, s = e.src.charCodeAt(++l); s === 35 && l < u && i <= 6; )
    i++, s = e.src.charCodeAt(++l);
  return i > 6 || l < u && !Gt(s) ? false : (o || (u = e.skipSpacesBack(u, l), c = e.skipCharsBack(u, 35, l), c > l && Gt(e.src.charCodeAt(c - 1)) && (u = c), e.line = t + 1, a = e.push("heading_open", "h" + String(i), 1), a.markup = "########".slice(0, i), a.map = [t, e.line], a = e.push("inline", "", 0), a.content = e.src.slice(l, u).trim(), a.map = [t, e.line], a.children = [], a = e.push("heading_close", "h" + String(i), -1), a.markup = "########".slice(0, i)), true);
};
var f4 = function(e, t, r) {
  var o, s, i, c, a, l, u, p5, f, h5 = t + 1, d, g = e.md.block.ruler.getRules("paragraph");
  if (e.sCount[t] - e.blkIndent >= 4)
    return false;
  for (d = e.parentType, e.parentType = "paragraph"; h5 < r && !e.isEmpty(h5); h5++)
    if (!(e.sCount[h5] - e.blkIndent > 3)) {
      if (e.sCount[h5] >= e.blkIndent && (l = e.bMarks[h5] + e.tShift[h5], u = e.eMarks[h5], l < u && (f = e.src.charCodeAt(l), (f === 45 || f === 61) && (l = e.skipChars(l, f), l = e.skipSpaces(l), l >= u)))) {
        p5 = f === 61 ? 1 : 2;
        break;
      }
      if (!(e.sCount[h5] < 0)) {
        for (s = false, i = 0, c = g.length; i < c; i++)
          if (g[i](e, h5, r, true)) {
            s = true;
            break;
          }
        if (s)
          break;
      }
    }
  return p5 ? (o = e.getLines(t, h5, e.blkIndent, false).trim(), e.line = h5 + 1, a = e.push("heading_open", "h" + String(p5), 1), a.markup = String.fromCharCode(f), a.map = [t, e.line], a = e.push("inline", "", 0), a.content = o, a.map = [t, e.line - 1], a.children = [], a = e.push("heading_close", "h" + String(p5), -1), a.markup = String.fromCharCode(f), e.parentType = d, true) : false;
};
var p4 = function(e, t, r) {
  var o, s, i, c, a, l, u = t + 1, p5 = e.md.block.ruler.getRules("paragraph");
  for (l = e.parentType, e.parentType = "paragraph"; u < r && !e.isEmpty(u); u++)
    if (!(e.sCount[u] - e.blkIndent > 3) && !(e.sCount[u] < 0)) {
      for (s = false, i = 0, c = p5.length; i < c; i++)
        if (p5[i](e, u, r, true)) {
          s = true;
          break;
        }
      if (s)
        break;
    }
  return o = e.getLines(t, u, e.blkIndent, false).trim(), e.line = u, a = e.push("paragraph_open", "p", 1), a.map = [t, e.line], a = e.push("inline", "", 0), a.content = o, a.map = [t, e.line], a.children = [], a = e.push("paragraph_close", "p", -1), e.parentType = l, true;
};
var Yr = Qn;
var mn = $.isSpace;
function me(n, e, t, r) {
  var o, s, i, c, a, l, u, p5;
  for (this.src = n, this.md = e, this.env = t, this.tokens = r, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = false, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0, this.result = "", s = this.src, p5 = false, i = c = l = u = 0, a = s.length; c < a; c++) {
    if (o = s.charCodeAt(c), !p5)
      if (mn(o)) {
        l++, o === 9 ? u += 4 - u % 4 : u++;
        continue;
      } else
        p5 = true;
    (o === 10 || c === a - 1) && (o !== 10 && c++, this.bMarks.push(i), this.eMarks.push(c), this.tShift.push(l), this.sCount.push(u), this.bsCount.push(0), p5 = false, l = 0, u = 0, i = c + 1);
  }
  this.bMarks.push(s.length), this.eMarks.push(s.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
me.prototype.push = function(n, e, t) {
  var r = new Yr(n, e, t);
  return r.block = true, t < 0 && this.level--, r.level = this.level, t > 0 && this.level++, this.tokens.push(r), r;
};
me.prototype.isEmpty = function(e) {
  return this.bMarks[e] + this.tShift[e] >= this.eMarks[e];
};
me.prototype.skipEmptyLines = function(e) {
  for (var t = this.lineMax; e < t && !(this.bMarks[e] + this.tShift[e] < this.eMarks[e]); e++)
    ;
  return e;
};
me.prototype.skipSpaces = function(e) {
  for (var t, r = this.src.length; e < r && (t = this.src.charCodeAt(e), !!mn(t)); e++)
    ;
  return e;
};
me.prototype.skipSpacesBack = function(e, t) {
  if (e <= t)
    return e;
  for (; e > t; )
    if (!mn(this.src.charCodeAt(--e)))
      return e + 1;
  return e;
};
me.prototype.skipChars = function(e, t) {
  for (var r = this.src.length; e < r && this.src.charCodeAt(e) === t; e++)
    ;
  return e;
};
me.prototype.skipCharsBack = function(e, t, r) {
  if (e <= r)
    return e;
  for (; e > r; )
    if (t !== this.src.charCodeAt(--e))
      return e + 1;
  return e;
};
me.prototype.getLines = function(e, t, r, o) {
  var s, i, c, a, l, u, p5, f = e;
  if (e >= t)
    return "";
  for (u = new Array(t - e), s = 0; f < t; f++, s++) {
    for (i = 0, p5 = a = this.bMarks[f], f + 1 < t || o ? l = this.eMarks[f] + 1 : l = this.eMarks[f]; a < l && i < r; ) {
      if (c = this.src.charCodeAt(a), mn(c))
        c === 9 ? i += 4 - (i + this.bsCount[f]) % 4 : i++;
      else if (a - p5 < this.tShift[f])
        i++;
      else
        break;
      a++;
    }
    i > r ? u[s] = new Array(i - r + 1).join(" ") + this.src.slice(a, l) : u[s] = this.src.slice(a, l);
  }
  return u.join("");
};
me.prototype.Token = Yr;
var h4 = me;
var d4 = Xn;
var nn = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", F9, ["paragraph", "reference"]],
  ["code", B9],
  ["fence", P9, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", z9, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", H9, ["paragraph", "reference", "blockquote", "list"]],
  ["list", G9, ["paragraph", "reference", "blockquote"]],
  ["reference", Z9],
  ["html_block", l4, ["paragraph", "reference", "blockquote"]],
  ["heading", u4, ["paragraph", "reference", "blockquote"]],
  ["lheading", f4],
  ["paragraph", p4]
];
function _n() {
  this.ruler = new d4();
  for (var n = 0; n < nn.length; n++)
    this.ruler.push(nn[n][0], nn[n][1], { alt: (nn[n][2] || []).slice() });
}
_n.prototype.tokenize = function(n, e, t) {
  for (var r, o, s, i = this.ruler.getRules(""), c = i.length, a = e, l = false, u = n.md.options.maxNesting; a < t && (n.line = a = n.skipEmptyLines(a), !(a >= t || n.sCount[a] < n.blkIndent)); ) {
    if (n.level >= u) {
      n.line = t;
      break;
    }
    for (s = n.line, o = 0; o < c; o++)
      if (r = i[o](n, a, t, false), r) {
        if (s >= n.line)
          throw new Error("block rule didn't increment state.line");
        break;
      }
    if (!r)
      throw new Error("none of the block rules matched");
    n.tight = !l, n.isEmpty(n.line - 1) && (l = true), a = n.line, a < t && n.isEmpty(a) && (l = true, a++, n.line = a);
  }
};
_n.prototype.parse = function(n, e, t, r) {
  var o;
  n && (o = new this.State(n, e, t, r), this.tokenize(o, o.line, o.lineMax));
};
_n.prototype.State = h4;
var g4 = _n;
function m4(n) {
  switch (n) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
var _4 = function(e, t) {
  for (var r = e.pos; r < e.posMax && !m4(e.src.charCodeAt(r)); )
    r++;
  return r === e.pos ? false : (t || (e.pending += e.src.slice(e.pos, r)), e.pos = r, true);
};
var b4 = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
var v4 = function(e, t) {
  var r, o, s, i, c, a, l, u;
  return !e.md.options.linkify || e.linkLevel > 0 || (r = e.pos, o = e.posMax, r + 3 > o) || e.src.charCodeAt(r) !== 58 || e.src.charCodeAt(r + 1) !== 47 || e.src.charCodeAt(r + 2) !== 47 || (s = e.pending.match(b4), !s) || (i = s[1], c = e.md.linkify.matchAtStart(e.src.slice(r - i.length)), !c) || (a = c.url, a.length <= i.length) || (a = a.replace(/\*+$/, ""), l = e.md.normalizeLink(a), !e.md.validateLink(l)) ? false : (t || (e.pending = e.pending.slice(0, -i.length), u = e.push("link_open", "a", 1), u.attrs = [["href", l]], u.markup = "linkify", u.info = "auto", u = e.push("text", "", 0), u.content = e.md.normalizeLinkText(a), u = e.push("link_close", "a", -1), u.markup = "linkify", u.info = "auto"), e.pos += a.length - i.length, true);
};
var k4 = $.isSpace;
var x4 = function(e, t) {
  var r, o, s, i = e.pos;
  if (e.src.charCodeAt(i) !== 10)
    return false;
  if (r = e.pending.length - 1, o = e.posMax, !t)
    if (r >= 0 && e.pending.charCodeAt(r) === 32)
      if (r >= 1 && e.pending.charCodeAt(r - 1) === 32) {
        for (s = r - 1; s >= 1 && e.pending.charCodeAt(s - 1) === 32; )
          s--;
        e.pending = e.pending.slice(0, s), e.push("hardbreak", "br", 0);
      } else
        e.pending = e.pending.slice(0, -1), e.push("softbreak", "br", 0);
    else
      e.push("softbreak", "br", 0);
  for (i++; i < o && k4(e.src.charCodeAt(i)); )
    i++;
  return e.pos = i, true;
};
var y4 = $.isSpace;
var nt = [];
for (jt = 0; jt < 256; jt++)
  nt.push(0);
var jt;
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(n) {
  nt[n.charCodeAt(0)] = 1;
});
var E4 = function(e, t) {
  var r, o, s, i, c, a = e.pos, l = e.posMax;
  if (e.src.charCodeAt(a) !== 92 || (a++, a >= l))
    return false;
  if (r = e.src.charCodeAt(a), r === 10) {
    for (t || e.push("hardbreak", "br", 0), a++; a < l && (r = e.src.charCodeAt(a), !!y4(r)); )
      a++;
    return e.pos = a, true;
  }
  return i = e.src[a], r >= 55296 && r <= 56319 && a + 1 < l && (o = e.src.charCodeAt(a + 1), o >= 56320 && o <= 57343 && (i += e.src[a + 1], a++)), s = "\\" + i, t || (c = e.push("text_special", "", 0), r < 256 && nt[r] !== 0 ? c.content = i : c.content = s, c.markup = s, c.info = "escape"), e.pos = a + 1, true;
};
var w4 = function(e, t) {
  var r, o, s, i, c, a, l, u, p5 = e.pos, f = e.src.charCodeAt(p5);
  if (f !== 96)
    return false;
  for (r = p5, p5++, o = e.posMax; p5 < o && e.src.charCodeAt(p5) === 96; )
    p5++;
  if (s = e.src.slice(r, p5), l = s.length, e.backticksScanned && (e.backticks[l] || 0) <= r)
    return t || (e.pending += s), e.pos += l, true;
  for (a = p5; (c = e.src.indexOf("`", a)) !== -1; ) {
    for (a = c + 1; a < o && e.src.charCodeAt(a) === 96; )
      a++;
    if (u = a - c, u === l)
      return t || (i = e.push("code_inline", "code", 0), i.markup = s, i.content = e.src.slice(p5, c).replace(/\n/g, " ").replace(/^ (.+) $/, "$1")), e.pos = a, true;
    e.backticks[u] = c;
  }
  return e.backticksScanned = true, t || (e.pending += s), e.pos += l, true;
};
var bn = {};
bn.tokenize = function(e, t) {
  var r, o, s, i, c, a = e.pos, l = e.src.charCodeAt(a);
  if (t || l !== 126 || (o = e.scanDelims(e.pos, true), i = o.length, c = String.fromCharCode(l), i < 2))
    return false;
  for (i % 2 && (s = e.push("text", "", 0), s.content = c, i--), r = 0; r < i; r += 2)
    s = e.push("text", "", 0), s.content = c + c, e.delimiters.push({
      marker: l,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: e.tokens.length - 1,
      end: -1,
      open: o.can_open,
      close: o.can_close
    });
  return e.pos += o.length, true;
};
function Zt(n, e) {
  var t, r, o, s, i, c = [], a = e.length;
  for (t = 0; t < a; t++)
    o = e[t], o.marker === 126 && o.end !== -1 && (s = e[o.end], i = n.tokens[o.token], i.type = "s_open", i.tag = "s", i.nesting = 1, i.markup = "~~", i.content = "", i = n.tokens[s.token], i.type = "s_close", i.tag = "s", i.nesting = -1, i.markup = "~~", i.content = "", n.tokens[s.token - 1].type === "text" && n.tokens[s.token - 1].content === "~" && c.push(s.token - 1));
  for (; c.length; ) {
    for (t = c.pop(), r = t + 1; r < n.tokens.length && n.tokens[r].type === "s_close"; )
      r++;
    r--, t !== r && (i = n.tokens[r], n.tokens[r] = n.tokens[t], n.tokens[t] = i);
  }
}
bn.postProcess = function(e) {
  var t, r = e.tokens_meta, o = e.tokens_meta.length;
  for (Zt(e, e.delimiters), t = 0; t < o; t++)
    r[t] && r[t].delimiters && Zt(e, r[t].delimiters);
};
var vn = {};
vn.tokenize = function(e, t) {
  var r, o, s, i = e.pos, c = e.src.charCodeAt(i);
  if (t || c !== 95 && c !== 42)
    return false;
  for (o = e.scanDelims(e.pos, c === 42), r = 0; r < o.length; r++)
    s = e.push("text", "", 0), s.content = String.fromCharCode(c), e.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: c,
      // Total length of these series of delimiters.
      //
      length: o.length,
      // A position of the token this delimiter corresponds to.
      //
      token: e.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: o.can_open,
      close: o.can_close
    });
  return e.pos += o.length, true;
};
function Kt(n, e) {
  var t, r, o, s, i, c, a = e.length;
  for (t = a - 1; t >= 0; t--)
    r = e[t], !(r.marker !== 95 && r.marker !== 42) && r.end !== -1 && (o = e[r.end], c = t > 0 && e[t - 1].end === r.end + 1 && // check that first two markers match and adjacent
    e[t - 1].marker === r.marker && e[t - 1].token === r.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    e[r.end + 1].token === o.token + 1, i = String.fromCharCode(r.marker), s = n.tokens[r.token], s.type = c ? "strong_open" : "em_open", s.tag = c ? "strong" : "em", s.nesting = 1, s.markup = c ? i + i : i, s.content = "", s = n.tokens[o.token], s.type = c ? "strong_close" : "em_close", s.tag = c ? "strong" : "em", s.nesting = -1, s.markup = c ? i + i : i, s.content = "", c && (n.tokens[e[t - 1].token].content = "", n.tokens[e[r.end + 1].token].content = "", t--));
}
vn.postProcess = function(e) {
  var t, r = e.tokens_meta, o = e.tokens_meta.length;
  for (Kt(e, e.delimiters), t = 0; t < o; t++)
    r[t] && r[t].delimiters && Kt(e, r[t].delimiters);
};
var A4 = $.normalizeReference;
var qn = $.isSpace;
var C4 = function(e, t) {
  var r, o, s, i, c, a, l, u, p5, f = "", h5 = "", d = e.pos, g = e.posMax, E = e.pos, x = true;
  if (e.src.charCodeAt(e.pos) !== 91 || (c = e.pos + 1, i = e.md.helpers.parseLinkLabel(e, e.pos, true), i < 0))
    return false;
  if (a = i + 1, a < g && e.src.charCodeAt(a) === 40) {
    for (x = false, a++; a < g && (o = e.src.charCodeAt(a), !(!qn(o) && o !== 10)); a++)
      ;
    if (a >= g)
      return false;
    if (E = a, l = e.md.helpers.parseLinkDestination(e.src, a, e.posMax), l.ok) {
      for (f = e.md.normalizeLink(l.str), e.md.validateLink(f) ? a = l.pos : f = "", E = a; a < g && (o = e.src.charCodeAt(a), !(!qn(o) && o !== 10)); a++)
        ;
      if (l = e.md.helpers.parseLinkTitle(e.src, a, e.posMax), a < g && E !== a && l.ok)
        for (h5 = l.str, a = l.pos; a < g && (o = e.src.charCodeAt(a), !(!qn(o) && o !== 10)); a++)
          ;
    }
    (a >= g || e.src.charCodeAt(a) !== 41) && (x = true), a++;
  }
  if (x) {
    if (typeof e.env.references > "u")
      return false;
    if (a < g && e.src.charCodeAt(a) === 91 ? (E = a + 1, a = e.md.helpers.parseLinkLabel(e, a), a >= 0 ? s = e.src.slice(E, a++) : a = i + 1) : a = i + 1, s || (s = e.src.slice(c, i)), u = e.env.references[A4(s)], !u)
      return e.pos = d, false;
    f = u.href, h5 = u.title;
  }
  return t || (e.pos = c, e.posMax = i, p5 = e.push("link_open", "a", 1), p5.attrs = r = [["href", f]], h5 && r.push(["title", h5]), e.linkLevel++, e.md.inline.tokenize(e), e.linkLevel--, p5 = e.push("link_close", "a", -1)), e.pos = a, e.posMax = g, true;
};
var S4 = $.normalizeReference;
var Mn = $.isSpace;
var D4 = function(e, t) {
  var r, o, s, i, c, a, l, u, p5, f, h5, d, g, E = "", x = e.pos, b = e.posMax;
  if (e.src.charCodeAt(e.pos) !== 33 || e.src.charCodeAt(e.pos + 1) !== 91 || (a = e.pos + 2, c = e.md.helpers.parseLinkLabel(e, e.pos + 1, false), c < 0))
    return false;
  if (l = c + 1, l < b && e.src.charCodeAt(l) === 40) {
    for (l++; l < b && (o = e.src.charCodeAt(l), !(!Mn(o) && o !== 10)); l++)
      ;
    if (l >= b)
      return false;
    for (g = l, p5 = e.md.helpers.parseLinkDestination(e.src, l, e.posMax), p5.ok && (E = e.md.normalizeLink(p5.str), e.md.validateLink(E) ? l = p5.pos : E = ""), g = l; l < b && (o = e.src.charCodeAt(l), !(!Mn(o) && o !== 10)); l++)
      ;
    if (p5 = e.md.helpers.parseLinkTitle(e.src, l, e.posMax), l < b && g !== l && p5.ok)
      for (f = p5.str, l = p5.pos; l < b && (o = e.src.charCodeAt(l), !(!Mn(o) && o !== 10)); l++)
        ;
    else
      f = "";
    if (l >= b || e.src.charCodeAt(l) !== 41)
      return e.pos = x, false;
    l++;
  } else {
    if (typeof e.env.references > "u")
      return false;
    if (l < b && e.src.charCodeAt(l) === 91 ? (g = l + 1, l = e.md.helpers.parseLinkLabel(e, l), l >= 0 ? i = e.src.slice(g, l++) : l = c + 1) : l = c + 1, i || (i = e.src.slice(a, c)), u = e.env.references[S4(i)], !u)
      return e.pos = x, false;
    E = u.href, f = u.title;
  }
  return t || (s = e.src.slice(a, c), e.md.inline.parse(
    s,
    e.md,
    e.env,
    d = []
  ), h5 = e.push("image", "img", 0), h5.attrs = r = [["src", E], ["alt", ""]], h5.children = d, h5.content = s, f && r.push(["title", f])), e.pos = l, e.posMax = b, true;
};
var T4 = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
var R4 = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
var L4 = function(e, t) {
  var r, o, s, i, c, a, l = e.pos;
  if (e.src.charCodeAt(l) !== 60)
    return false;
  for (c = e.pos, a = e.posMax; ; ) {
    if (++l >= a || (i = e.src.charCodeAt(l), i === 60))
      return false;
    if (i === 62)
      break;
  }
  return r = e.src.slice(c + 1, l), R4.test(r) ? (o = e.md.normalizeLink(r), e.md.validateLink(o) ? (t || (s = e.push("link_open", "a", 1), s.attrs = [["href", o]], s.markup = "autolink", s.info = "auto", s = e.push("text", "", 0), s.content = e.md.normalizeLinkText(r), s = e.push("link_close", "a", -1), s.markup = "autolink", s.info = "auto"), e.pos += r.length + 2, true) : false) : T4.test(r) ? (o = e.md.normalizeLink("mailto:" + r), e.md.validateLink(o) ? (t || (s = e.push("link_open", "a", 1), s.attrs = [["href", o]], s.markup = "autolink", s.info = "auto", s = e.push("text", "", 0), s.content = e.md.normalizeLinkText(r), s = e.push("link_close", "a", -1), s.markup = "autolink", s.info = "auto"), e.pos += r.length + 2, true) : false) : false;
};
var N4 = gn.HTML_TAG_RE;
function q4(n) {
  return /^<a[>\s]/i.test(n);
}
function M4(n) {
  return /^<\/a\s*>/i.test(n);
}
function I4(n) {
  var e = n | 32;
  return e >= 97 && e <= 122;
}
var O4 = function(e, t) {
  var r, o, s, i, c = e.pos;
  return !e.md.options.html || (s = e.posMax, e.src.charCodeAt(c) !== 60 || c + 2 >= s) || (r = e.src.charCodeAt(c + 1), r !== 33 && r !== 63 && r !== 47 && !I4(r)) || (o = e.src.slice(c).match(N4), !o) ? false : (t || (i = e.push("html_inline", "", 0), i.content = o[0], q4(i.content) && e.linkLevel++, M4(i.content) && e.linkLevel--), e.pos += o[0].length, true);
};
var Wt = zr;
var F4 = $.has;
var B4 = $.isValidEntityCode;
var Yt = $.fromCodePoint;
var P4 = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
var $4 = /^&([a-z][a-z0-9]{1,31});/i;
var z4 = function(e, t) {
  var r, o, s, i, c = e.pos, a = e.posMax;
  if (e.src.charCodeAt(c) !== 38 || c + 1 >= a)
    return false;
  if (r = e.src.charCodeAt(c + 1), r === 35) {
    if (s = e.src.slice(c).match(P4), s)
      return t || (o = s[1][0].toLowerCase() === "x" ? parseInt(s[1].slice(1), 16) : parseInt(s[1], 10), i = e.push("text_special", "", 0), i.content = B4(o) ? Yt(o) : Yt(65533), i.markup = s[0], i.info = "entity"), e.pos += s[0].length, true;
  } else if (s = e.src.slice(c).match($4), s && F4(Wt, s[1]))
    return t || (i = e.push("text_special", "", 0), i.content = Wt[s[1]], i.markup = s[0], i.info = "entity"), e.pos += s[0].length, true;
  return false;
};
function Jt(n) {
  var e, t, r, o, s, i, c, a, l = {}, u = n.length;
  if (u) {
    var p5 = 0, f = -2, h5 = [];
    for (e = 0; e < u; e++)
      if (r = n[e], h5.push(0), (n[p5].marker !== r.marker || f !== r.token - 1) && (p5 = e), f = r.token, r.length = r.length || 0, !!r.close) {
        for (l.hasOwnProperty(r.marker) || (l[r.marker] = [-1, -1, -1, -1, -1, -1]), s = l[r.marker][(r.open ? 3 : 0) + r.length % 3], t = p5 - h5[p5] - 1, i = t; t > s; t -= h5[t] + 1)
          if (o = n[t], o.marker === r.marker && o.open && o.end < 0 && (c = false, (o.close || r.open) && (o.length + r.length) % 3 === 0 && (o.length % 3 !== 0 || r.length % 3 !== 0) && (c = true), !c)) {
            a = t > 0 && !n[t - 1].open ? h5[t - 1] + 1 : 0, h5[e] = e - t + a, h5[t] = a, r.open = false, o.end = e, o.close = false, i = -1, f = -2;
            break;
          }
        i !== -1 && (l[r.marker][(r.open ? 3 : 0) + (r.length || 0) % 3] = i);
      }
  }
}
var U4 = function(e) {
  var t, r = e.tokens_meta, o = e.tokens_meta.length;
  for (Jt(e.delimiters), t = 0; t < o; t++)
    r[t] && r[t].delimiters && Jt(r[t].delimiters);
};
var H4 = function(e) {
  var t, r, o = 0, s = e.tokens, i = e.tokens.length;
  for (t = r = 0; t < i; t++)
    s[t].nesting < 0 && o--, s[t].level = o, s[t].nesting > 0 && o++, s[t].type === "text" && t + 1 < i && s[t + 1].type === "text" ? s[t + 1].content = s[t].content + s[t + 1].content : (t !== r && (s[r] = s[t]), r++);
  t !== r && (s.length = r);
};
var tt2 = Qn;
var Xt = $.isWhiteSpace;
var Qt = $.isPunctChar;
var er = $.isMdAsciiPunct;
function je(n, e, t, r) {
  this.src = n, this.env = t, this.md = e, this.tokens = r, this.tokens_meta = Array(r.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = false, this.linkLevel = 0;
}
je.prototype.pushPending = function() {
  var n = new tt2("text", "", 0);
  return n.content = this.pending, n.level = this.pendingLevel, this.tokens.push(n), this.pending = "", n;
};
je.prototype.push = function(n, e, t) {
  this.pending && this.pushPending();
  var r = new tt2(n, e, t), o = null;
  return t < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), r.level = this.level, t > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], o = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(r), this.tokens_meta.push(o), r;
};
je.prototype.scanDelims = function(n, e) {
  var t = n, r, o, s, i, c, a, l, u, p5, f = true, h5 = true, d = this.posMax, g = this.src.charCodeAt(n);
  for (r = n > 0 ? this.src.charCodeAt(n - 1) : 32; t < d && this.src.charCodeAt(t) === g; )
    t++;
  return s = t - n, o = t < d ? this.src.charCodeAt(t) : 32, l = er(r) || Qt(String.fromCharCode(r)), p5 = er(o) || Qt(String.fromCharCode(o)), a = Xt(r), u = Xt(o), u ? f = false : p5 && (a || l || (f = false)), a ? h5 = false : l && (u || p5 || (h5 = false)), e ? (i = f, c = h5) : (i = f && (!h5 || l), c = h5 && (!f || p5)), {
    can_open: i,
    can_close: c,
    length: s
  };
};
je.prototype.Token = tt2;
var V4 = je;
var nr = Xn;
var In = [
  ["text", _4],
  ["linkify", v4],
  ["newline", x4],
  ["escape", E4],
  ["backticks", w4],
  ["strikethrough", bn.tokenize],
  ["emphasis", vn.tokenize],
  ["link", C4],
  ["image", D4],
  ["autolink", L4],
  ["html_inline", O4],
  ["entity", z4]
];
var On = [
  ["balance_pairs", U4],
  ["strikethrough", bn.postProcess],
  ["emphasis", vn.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", H4]
];
function Ze() {
  var n;
  for (this.ruler = new nr(), n = 0; n < In.length; n++)
    this.ruler.push(In[n][0], In[n][1]);
  for (this.ruler2 = new nr(), n = 0; n < On.length; n++)
    this.ruler2.push(On[n][0], On[n][1]);
}
Ze.prototype.skipToken = function(n) {
  var e, t, r = n.pos, o = this.ruler.getRules(""), s = o.length, i = n.md.options.maxNesting, c = n.cache;
  if (typeof c[r] < "u") {
    n.pos = c[r];
    return;
  }
  if (n.level < i) {
    for (t = 0; t < s; t++)
      if (n.level++, e = o[t](n, true), n.level--, e) {
        if (r >= n.pos)
          throw new Error("inline rule didn't increment state.pos");
        break;
      }
  } else
    n.pos = n.posMax;
  e || n.pos++, c[r] = n.pos;
};
Ze.prototype.tokenize = function(n) {
  for (var e, t, r, o = this.ruler.getRules(""), s = o.length, i = n.posMax, c = n.md.options.maxNesting; n.pos < i; ) {
    if (r = n.pos, n.level < c) {
      for (t = 0; t < s; t++)
        if (e = o[t](n, false), e) {
          if (r >= n.pos)
            throw new Error("inline rule didn't increment state.pos");
          break;
        }
    }
    if (e) {
      if (n.pos >= i)
        break;
      continue;
    }
    n.pending += n.src[n.pos++];
  }
  n.pending && n.pushPending();
};
Ze.prototype.parse = function(n, e, t, r) {
  var o, s, i, c = new this.State(n, e, t, r);
  for (this.tokenize(c), s = this.ruler2.getRules(""), i = s.length, o = 0; o < i; o++)
    s[o](c);
};
Ze.prototype.State = V4;
var G4 = Ze;
var Fn;
var tr;
function j4() {
  return tr || (tr = 1, Fn = function(n) {
    var e = {};
    n = n || {}, e.src_Any = Ur().source, e.src_Cc = Hr().source, e.src_Z = Vr().source, e.src_P = Jn.source, e.src_ZPCc = [e.src_Z, e.src_P, e.src_Cc].join("|"), e.src_ZCc = [e.src_Z, e.src_Cc].join("|");
    var t = "[><｜]";
    return e.src_pseudo_letter = "(?:(?!" + t + "|" + e.src_ZPCc + ")" + e.src_Any + ")", e.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", e.src_auth = "(?:(?:(?!" + e.src_ZCc + "|[@/\\[\\]()]).)+@)?", e.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", e.src_host_terminator = "(?=$|" + t + "|" + e.src_ZPCc + ")(?!" + (n["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + e.src_ZPCc + "))", e.src_path = "(?:[/?#](?:(?!" + e.src_ZCc + "|" + t + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + e.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + e.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + e.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + e.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + e.src_ZCc + "|[']).)+\\'|\\'(?=" + e.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + e.src_ZCc + "|[.]|$)|" + (n["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + e.src_ZCc + "|$)|;(?!" + e.src_ZCc + "|$)|\\!+(?!" + e.src_ZCc + "|[!]|$)|\\?(?!" + e.src_ZCc + "|[?]|$))+|\\/)?", e.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', e.src_xn = "xn--[a-z0-9\\-]{1,59}", e.src_domain_root = // Allow letters & digits (http://test1)
    "(?:" + e.src_xn + "|" + e.src_pseudo_letter + "{1,63})", e.src_domain = "(?:" + e.src_xn + "|(?:" + e.src_pseudo_letter + ")|(?:" + e.src_pseudo_letter + "(?:-|" + e.src_pseudo_letter + "){0,61}" + e.src_pseudo_letter + "))", e.src_host = "(?:(?:(?:(?:" + e.src_domain + ")\\.)*" + e.src_domain + "))", e.tpl_host_fuzzy = "(?:" + e.src_ip4 + "|(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%)))", e.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%))", e.src_host_strict = e.src_host + e.src_host_terminator, e.tpl_host_fuzzy_strict = e.tpl_host_fuzzy + e.src_host_terminator, e.src_host_port_strict = e.src_host + e.src_port + e.src_host_terminator, e.tpl_host_port_fuzzy_strict = e.tpl_host_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_port_no_ip_fuzzy_strict = e.tpl_host_no_ip_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + e.src_ZPCc + "|>|$))", e.tpl_email_fuzzy = "(^|" + t + '|"|\\(|' + e.src_ZCc + ")(" + e.src_email_name + "@" + e.tpl_host_fuzzy_strict + ")", e.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + e.src_ZPCc + "))((?![$+<=>^`|｜])" + e.tpl_host_port_fuzzy_strict + e.src_path + ")", e.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + e.src_ZPCc + "))((?![$+<=>^`|｜])" + e.tpl_host_port_no_ip_fuzzy_strict + e.src_path + ")", e;
  }), Fn;
}
function zn(n) {
  var e = Array.prototype.slice.call(arguments, 1);
  return e.forEach(function(t) {
    t && Object.keys(t).forEach(function(r) {
      n[r] = t[r];
    });
  }), n;
}
function kn(n) {
  return Object.prototype.toString.call(n);
}
function Z4(n) {
  return kn(n) === "[object String]";
}
function K4(n) {
  return kn(n) === "[object Object]";
}
function W4(n) {
  return kn(n) === "[object RegExp]";
}
function rr(n) {
  return kn(n) === "[object Function]";
}
function Y4(n) {
  return n.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var Jr = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};
function J4(n) {
  return Object.keys(n || {}).reduce(function(e, t) {
    return e || Jr.hasOwnProperty(t);
  }, false);
}
var X4 = {
  "http:": {
    validate: function(n, e, t) {
      var r = n.slice(e);
      return t.re.http || (t.re.http = new RegExp(
        "^\\/\\/" + t.re.src_auth + t.re.src_host_port_strict + t.re.src_path,
        "i"
      )), t.re.http.test(r) ? r.match(t.re.http)[0].length : 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(n, e, t) {
      var r = n.slice(e);
      return t.re.no_http || (t.re.no_http = new RegExp(
        "^" + t.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        "(?:localhost|(?:(?:" + t.re.src_domain + ")\\.)+" + t.re.src_domain_root + ")" + t.re.src_port + t.re.src_host_terminator + t.re.src_path,
        "i"
      )), t.re.no_http.test(r) ? e >= 3 && n[e - 3] === ":" || e >= 3 && n[e - 3] === "/" ? 0 : r.match(t.re.no_http)[0].length : 0;
    }
  },
  "mailto:": {
    validate: function(n, e, t) {
      var r = n.slice(e);
      return t.re.mailto || (t.re.mailto = new RegExp(
        "^" + t.re.src_email_name + "@" + t.re.src_host_strict,
        "i"
      )), t.re.mailto.test(r) ? r.match(t.re.mailto)[0].length : 0;
    }
  }
};
var Q4 = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
var e8 = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split("|");
function n8(n) {
  n.__index__ = -1, n.__text_cache__ = "";
}
function t8(n) {
  return function(e, t) {
    var r = e.slice(t);
    return n.test(r) ? r.match(n)[0].length : 0;
  };
}
function or() {
  return function(n, e) {
    e.normalize(n);
  };
}
function an(n) {
  var e = n.re = j4()(n.__opts__), t = n.__tlds__.slice();
  n.onCompile(), n.__tlds_replaced__ || t.push(Q4), t.push(e.src_xn), e.src_tlds = t.join("|");
  function r(c) {
    return c.replace("%TLDS%", e.src_tlds);
  }
  e.email_fuzzy = RegExp(r(e.tpl_email_fuzzy), "i"), e.link_fuzzy = RegExp(r(e.tpl_link_fuzzy), "i"), e.link_no_ip_fuzzy = RegExp(r(e.tpl_link_no_ip_fuzzy), "i"), e.host_fuzzy_test = RegExp(r(e.tpl_host_fuzzy_test), "i");
  var o = [];
  n.__compiled__ = {};
  function s(c, a) {
    throw new Error('(LinkifyIt) Invalid schema "' + c + '": ' + a);
  }
  Object.keys(n.__schemas__).forEach(function(c) {
    var a = n.__schemas__[c];
    if (a !== null) {
      var l = { validate: null, link: null };
      if (n.__compiled__[c] = l, K4(a)) {
        W4(a.validate) ? l.validate = t8(a.validate) : rr(a.validate) ? l.validate = a.validate : s(c, a), rr(a.normalize) ? l.normalize = a.normalize : a.normalize ? s(c, a) : l.normalize = or();
        return;
      }
      if (Z4(a)) {
        o.push(c);
        return;
      }
      s(c, a);
    }
  }), o.forEach(function(c) {
    n.__compiled__[n.__schemas__[c]] && (n.__compiled__[c].validate = n.__compiled__[n.__schemas__[c]].validate, n.__compiled__[c].normalize = n.__compiled__[n.__schemas__[c]].normalize);
  }), n.__compiled__[""] = { validate: null, normalize: or() };
  var i = Object.keys(n.__compiled__).filter(function(c) {
    return c.length > 0 && n.__compiled__[c];
  }).map(Y4).join("|");
  n.re.schema_test = RegExp("(^|(?!_)(?:[><｜]|" + e.src_ZPCc + "))(" + i + ")", "i"), n.re.schema_search = RegExp("(^|(?!_)(?:[><｜]|" + e.src_ZPCc + "))(" + i + ")", "ig"), n.re.schema_at_start = RegExp("^" + n.re.schema_search.source, "i"), n.re.pretest = RegExp(
    "(" + n.re.schema_test.source + ")|(" + n.re.host_fuzzy_test.source + ")|@",
    "i"
  ), n8(n);
}
function r8(n, e) {
  var t = n.__index__, r = n.__last_index__, o = n.__text_cache__.slice(t, r);
  this.schema = n.__schema__.toLowerCase(), this.index = t + e, this.lastIndex = r + e, this.raw = o, this.text = o, this.url = o;
}
function Un(n, e) {
  var t = new r8(n, e);
  return n.__compiled__[t.schema].normalize(t, n), t;
}
function ce(n, e) {
  if (!(this instanceof ce))
    return new ce(n, e);
  e || J4(n) && (e = n, n = {}), this.__opts__ = zn({}, Jr, e), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = zn({}, X4, n), this.__compiled__ = {}, this.__tlds__ = e8, this.__tlds_replaced__ = false, this.re = {}, an(this);
}
ce.prototype.add = function(e, t) {
  return this.__schemas__[e] = t, an(this), this;
};
ce.prototype.set = function(e) {
  return this.__opts__ = zn(this.__opts__, e), this;
};
ce.prototype.test = function(e) {
  if (this.__text_cache__ = e, this.__index__ = -1, !e.length)
    return false;
  var t, r, o, s, i, c, a, l, u;
  if (this.re.schema_test.test(e)) {
    for (a = this.re.schema_search, a.lastIndex = 0; (t = a.exec(e)) !== null; )
      if (s = this.testSchemaAt(e, t[2], a.lastIndex), s) {
        this.__schema__ = t[2], this.__index__ = t.index + t[1].length, this.__last_index__ = t.index + t[0].length + s;
        break;
      }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (l = e.search(this.re.host_fuzzy_test), l >= 0 && (this.__index__ < 0 || l < this.__index__) && (r = e.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (i = r.index + r[1].length, (this.__index__ < 0 || i < this.__index__) && (this.__schema__ = "", this.__index__ = i, this.__last_index__ = r.index + r[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (u = e.indexOf("@"), u >= 0 && (o = e.match(this.re.email_fuzzy)) !== null && (i = o.index + o[1].length, c = o.index + o[0].length, (this.__index__ < 0 || i < this.__index__ || i === this.__index__ && c > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = i, this.__last_index__ = c))), this.__index__ >= 0;
};
ce.prototype.pretest = function(e) {
  return this.re.pretest.test(e);
};
ce.prototype.testSchemaAt = function(e, t, r) {
  return this.__compiled__[t.toLowerCase()] ? this.__compiled__[t.toLowerCase()].validate(e, r, this) : 0;
};
ce.prototype.match = function(e) {
  var t = 0, r = [];
  this.__index__ >= 0 && this.__text_cache__ === e && (r.push(Un(this, t)), t = this.__last_index__);
  for (var o = t ? e.slice(t) : e; this.test(o); )
    r.push(Un(this, t)), o = o.slice(this.__last_index__), t += this.__last_index__;
  return r.length ? r : null;
};
ce.prototype.matchAtStart = function(e) {
  if (this.__text_cache__ = e, this.__index__ = -1, !e.length)
    return null;
  var t = this.re.schema_at_start.exec(e);
  if (!t)
    return null;
  var r = this.testSchemaAt(e, t[2], t[0].length);
  return r ? (this.__schema__ = t[2], this.__index__ = t.index + t[1].length, this.__last_index__ = t.index + t[0].length + r, Un(this, 0)) : null;
};
ce.prototype.tlds = function(e, t) {
  return e = Array.isArray(e) ? e : [e], t ? (this.__tlds__ = this.__tlds__.concat(e).sort().filter(function(r, o, s) {
    return r !== s[o - 1];
  }).reverse(), an(this), this) : (this.__tlds__ = e.slice(), this.__tlds_replaced__ = true, an(this), this);
};
ce.prototype.normalize = function(e) {
  e.schema || (e.url = "http://" + e.url), e.schema === "mailto:" && !/^mailto:/i.test(e.url) && (e.url = "mailto:" + e.url);
};
ce.prototype.onCompile = function() {
};
var o8 = ce;
var Le = 2147483647;
var pe = 36;
var rt = 1;
var Ve = 26;
var s8 = 38;
var c8 = 700;
var Xr = 72;
var Qr = 128;
var eo = "-";
var i8 = /^xn--/;
var a8 = /[^\0-\x7F]/;
var l8 = /[\x2E\u3002\uFF0E\uFF61]/g;
var u8 = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
var Bn = pe - rt;
var he = Math.floor;
var Pn = String.fromCharCode;
function ve(n) {
  throw new RangeError(u8[n]);
}
function f8(n, e) {
  const t = [];
  let r = n.length;
  for (; r--; )
    t[r] = e(n[r]);
  return t;
}
function no(n, e) {
  const t = n.split("@");
  let r = "";
  t.length > 1 && (r = t[0] + "@", n = t[1]), n = n.replace(l8, ".");
  const o = n.split("."), s = f8(o, e).join(".");
  return r + s;
}
function ot(n) {
  const e = [];
  let t = 0;
  const r = n.length;
  for (; t < r; ) {
    const o = n.charCodeAt(t++);
    if (o >= 55296 && o <= 56319 && t < r) {
      const s = n.charCodeAt(t++);
      (s & 64512) == 56320 ? e.push(((o & 1023) << 10) + (s & 1023) + 65536) : (e.push(o), t--);
    } else
      e.push(o);
  }
  return e;
}
var to = (n) => String.fromCodePoint(...n);
var p8 = function(n) {
  return n >= 48 && n < 58 ? 26 + (n - 48) : n >= 65 && n < 91 ? n - 65 : n >= 97 && n < 123 ? n - 97 : pe;
};
var sr = function(n, e) {
  return n + 22 + 75 * (n < 26) - ((e != 0) << 5);
};
var ro = function(n, e, t) {
  let r = 0;
  for (n = t ? he(n / c8) : n >> 1, n += he(n / e); n > Bn * Ve >> 1; r += pe)
    n = he(n / Bn);
  return he(r + (Bn + 1) * n / (n + s8));
};
var st = function(n) {
  const e = [], t = n.length;
  let r = 0, o = Qr, s = Xr, i = n.lastIndexOf(eo);
  i < 0 && (i = 0);
  for (let c = 0; c < i; ++c)
    n.charCodeAt(c) >= 128 && ve("not-basic"), e.push(n.charCodeAt(c));
  for (let c = i > 0 ? i + 1 : 0; c < t; ) {
    const a = r;
    for (let u = 1, p5 = pe; ; p5 += pe) {
      c >= t && ve("invalid-input");
      const f = p8(n.charCodeAt(c++));
      f >= pe && ve("invalid-input"), f > he((Le - r) / u) && ve("overflow"), r += f * u;
      const h5 = p5 <= s ? rt : p5 >= s + Ve ? Ve : p5 - s;
      if (f < h5)
        break;
      const d = pe - h5;
      u > he(Le / d) && ve("overflow"), u *= d;
    }
    const l = e.length + 1;
    s = ro(r - a, l, a == 0), he(r / l) > Le - o && ve("overflow"), o += he(r / l), r %= l, e.splice(r++, 0, o);
  }
  return String.fromCodePoint(...e);
};
var ct = function(n) {
  const e = [];
  n = ot(n);
  const t = n.length;
  let r = Qr, o = 0, s = Xr;
  for (const a of n)
    a < 128 && e.push(Pn(a));
  const i = e.length;
  let c = i;
  for (i && e.push(eo); c < t; ) {
    let a = Le;
    for (const u of n)
      u >= r && u < a && (a = u);
    const l = c + 1;
    a - r > he((Le - o) / l) && ve("overflow"), o += (a - r) * l, r = a;
    for (const u of n)
      if (u < r && ++o > Le && ve("overflow"), u === r) {
        let p5 = o;
        for (let f = pe; ; f += pe) {
          const h5 = f <= s ? rt : f >= s + Ve ? Ve : f - s;
          if (p5 < h5)
            break;
          const d = p5 - h5, g = pe - h5;
          e.push(
            Pn(sr(h5 + d % g, 0))
          ), p5 = he(d / g);
        }
        e.push(Pn(sr(p5, 0))), s = ro(o, l, c === i), o = 0, ++c;
      }
    ++o, ++r;
  }
  return e.join("");
};
var oo = function(n) {
  return no(n, function(e) {
    return i8.test(e) ? st(e.slice(4).toLowerCase()) : e;
  });
};
var so = function(n) {
  return no(n, function(e) {
    return a8.test(e) ? "xn--" + ct(e) : e;
  });
};
var h8 = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  version: "2.3.1",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  ucs2: {
    decode: ot,
    encode: to
  },
  decode: st,
  encode: ct,
  toASCII: so,
  toUnicode: oo
};
var d8 = Object.freeze(Object.defineProperty({
  __proto__: null,
  decode: st,
  default: h8,
  encode: ct,
  toASCII: so,
  toUnicode: oo,
  ucs2decode: ot,
  ucs2encode: to
}, Symbol.toStringTag, { value: "Module" }));
var g8 = Zo(d8);
var m8 = {
  options: {
    html: false,
    // Enable HTML tags in source
    xhtmlOut: false,
    // Use '/' to close single tags (<br />)
    breaks: false,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: false,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 100
    // Internal protection, recursion limit
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
};
var _8 = {
  options: {
    html: false,
    // Enable HTML tags in source
    xhtmlOut: false,
    // Use '/' to close single tags (<br />)
    breaks: false,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: false,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20
    // Internal protection, recursion limit
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
};
var b8 = {
  options: {
    html: true,
    // Enable HTML tags in source
    xhtmlOut: true,
    // Use '/' to close single tags (<br />)
    breaks: false,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: false,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20
    // Internal protection, recursion limit
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
};
var Pe = $;
var v8 = dn;
var k8 = p9;
var x8 = O9;
var y8 = g4;
var E8 = G4;
var w8 = o8;
var we = Me;
var co = g8;
var A8 = {
  default: m8,
  zero: _8,
  commonmark: b8
};
var C8 = /^(vbscript|javascript|file|data):/;
var S8 = /^data:image\/(gif|png|jpeg|webp);/;
function D8(n) {
  var e = n.trim().toLowerCase();
  return C8.test(e) ? !!S8.test(e) : true;
}
var io = ["http:", "https:", "mailto:"];
function T8(n) {
  var e = we.parse(n, true);
  if (e.hostname && (!e.protocol || io.indexOf(e.protocol) >= 0))
    try {
      e.hostname = co.toASCII(e.hostname);
    } catch {
    }
  return we.encode(we.format(e));
}
function R8(n) {
  var e = we.parse(n, true);
  if (e.hostname && (!e.protocol || io.indexOf(e.protocol) >= 0))
    try {
      e.hostname = co.toUnicode(e.hostname);
    } catch {
    }
  return we.decode(we.format(e), we.decode.defaultChars + "%");
}
function ie(n, e) {
  if (!(this instanceof ie))
    return new ie(n, e);
  e || Pe.isString(n) || (e = n || {}, n = "default"), this.inline = new E8(), this.block = new y8(), this.core = new x8(), this.renderer = new k8(), this.linkify = new w8(), this.validateLink = D8, this.normalizeLink = T8, this.normalizeLinkText = R8, this.utils = Pe, this.helpers = Pe.assign({}, v8), this.options = {}, this.configure(n), e && this.set(e);
}
ie.prototype.set = function(n) {
  return Pe.assign(this.options, n), this;
};
ie.prototype.configure = function(n) {
  var e = this, t;
  if (Pe.isString(n) && (t = n, n = A8[t], !n))
    throw new Error('Wrong `markdown-it` preset "' + t + '", check name');
  if (!n)
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  return n.options && e.set(n.options), n.components && Object.keys(n.components).forEach(function(r) {
    n.components[r].rules && e[r].ruler.enableOnly(n.components[r].rules), n.components[r].rules2 && e[r].ruler2.enableOnly(n.components[r].rules2);
  }), this;
};
ie.prototype.enable = function(n, e) {
  var t = [];
  Array.isArray(n) || (n = [n]), ["core", "block", "inline"].forEach(function(o) {
    t = t.concat(this[o].ruler.enable(n, true));
  }, this), t = t.concat(this.inline.ruler2.enable(n, true));
  var r = n.filter(function(o) {
    return t.indexOf(o) < 0;
  });
  if (r.length && !e)
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + r);
  return this;
};
ie.prototype.disable = function(n, e) {
  var t = [];
  Array.isArray(n) || (n = [n]), ["core", "block", "inline"].forEach(function(o) {
    t = t.concat(this[o].ruler.disable(n, true));
  }, this), t = t.concat(this.inline.ruler2.disable(n, true));
  var r = n.filter(function(o) {
    return t.indexOf(o) < 0;
  });
  if (r.length && !e)
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + r);
  return this;
};
ie.prototype.use = function(n) {
  var e = [this].concat(Array.prototype.slice.call(arguments, 1));
  return n.apply(n, e), this;
};
ie.prototype.parse = function(n, e) {
  if (typeof n != "string")
    throw new Error("Input data should be a String");
  var t = new this.core.State(n, this, e);
  return this.core.process(t), t.tokens;
};
ie.prototype.render = function(n, e) {
  return e = e || {}, this.renderer.render(this.parse(n, e), this.options, e);
};
ie.prototype.parseInline = function(n, e) {
  var t = new this.core.State(n, this, e);
  return t.inlineMode = true, this.core.process(t), t.tokens;
};
ie.prototype.renderInline = function(n, e) {
  return e = e || {}, this.renderer.render(this.parseInline(n, e), this.options, e);
};
var L8 = ie;
var N8 = L8;
var q8 = Gn(N8);
var M8 = defineComponent({
  name: "VueMarkdown",
  props: {
    source: {
      type: String,
      required: true
    },
    options: {
      type: Object,
      required: false
    },
    plugins: {
      type: Array,
      required: false
    }
  },
  setup(n) {
    const e = ref(new q8(n.options ?? {}));
    for (const r of n.plugins ?? [])
      e.value.use(r);
    const t = computed2(() => e.value.render(n.source));
    return () => h("div", { innerHTML: t.value });
  }
});
var I8 = {
  key: 0,
  class: "chat-message-actions"
};
var O8 = {
  key: 2,
  class: "chat-message-files"
};
var Hn = defineComponent({
  __name: "Message",
  props: {
    message: {}
  },
  setup(n, { expose: e }) {
    const t = n;
    be.registerLanguage("javascript", Rr), be.registerLanguage("typescript", vi), be.registerLanguage("python", _i), be.registerLanguage("xml", Lr), be.registerLanguage("bash", mi);
    const { message: r } = toRefs(t), { options: o } = Ge(), s = ref(null), i = ref({}), c = computed2(() => r.value.text || "&lt;Empty response&gt;"), a = computed2(() => ({
      "chat-message-from-user": r.value.sender === "user",
      "chat-message-from-bot": r.value.sender === "bot",
      "chat-message-transparent": r.value.transparent === true
    })), l = (d) => {
      d.use(Ei, {
        attrs: {
          target: "_blank",
          rel: "noopener"
        }
      });
    }, u = () => {
      var d;
      (d = s.value) != null && d.scrollIntoView && s.value.scrollIntoView({
        block: "center"
      });
    }, p5 = {
      highlight(d, g) {
        if (g && be.getLanguage(g))
          try {
            return be.highlight(d, { language: g }).value;
          } catch {
          }
        return "";
      }
    }, f = { ...(o == null ? void 0 : o.messageComponents) ?? {} };
    e({ scrollToView: u });
    const h5 = async (d) => await new Promise((g, E) => {
      const x = new FileReader();
      x.onload = () => g(x.result), x.onerror = E, x.readAsDataURL(d);
    });
    return onMounted(async () => {
      if (r.value.files)
        for (const d of r.value.files)
          try {
            const g = await h5(d);
            i.value[d.name] = g;
          } catch (g) {
            console.error("Error reading file:", g);
          }
    }), (d, g) => (openBlock(), createElementBlock("div", {
      ref_key: "messageContainer",
      ref: s,
      class: normalizeClass(["chat-message", a.value])
    }, [
      d.$slots.beforeMessage ? (openBlock(), createElementBlock("div", I8, [
        renderSlot(d.$slots, "beforeMessage", normalizeProps(guardReactiveProps({ message: unref(r) })))
      ])) : createCommentVNode("", true),
      renderSlot(d.$slots, "default", {}, () => [
        unref(r).type === "component" && f[unref(r).key] ? (openBlock(), createBlock(resolveDynamicComponent(f[unref(r).key]), normalizeProps(mergeProps({ key: 0 }, unref(r).arguments)), null, 16)) : (openBlock(), createBlock(unref(M8), {
          key: 1,
          class: "chat-message-markdown",
          source: c.value,
          options: p5,
          plugins: [l]
        }, null, 8, ["source", "plugins"])),
        (unref(r).files ?? []).length > 0 ? (openBlock(), createElementBlock("div", O8, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(r).files ?? [], (E) => (openBlock(), createElementBlock("div", {
            key: E.name,
            class: "chat-message-file"
          }, [
            createVNode(Nr, {
              file: E,
              "is-removable": false,
              "is-previewable": true
            }, null, 8, ["file"])
          ]))), 128))
        ])) : createCommentVNode("", true)
      ])
    ], 2));
  }
});
var F8 = createBaseVNode("div", { class: "chat-message-typing-body" }, [
  createBaseVNode("span", { class: "chat-message-typing-circle" }),
  createBaseVNode("span", { class: "chat-message-typing-circle" }),
  createBaseVNode("span", { class: "chat-message-typing-circle" })
], -1);
var B8 = defineComponent({
  __name: "MessageTyping",
  props: {
    animation: { default: "bouncing" }
  },
  setup(n) {
    const e = n, t = {
      id: "typing",
      text: "",
      sender: "bot",
      createdAt: ""
    }, r = ref(), o = computed2(() => ({
      // eslint-disable-next-line @typescript-eslint/naming-convention
      "chat-message-typing": true,
      [`chat-message-typing-animation-${e.animation}`]: true
    }));
    return onMounted(() => {
      var s;
      (s = r.value) == null || s.scrollToView();
    }), (s, i) => (openBlock(), createBlock(unref(Hn), {
      ref_key: "messageContainer",
      ref: r,
      class: normalizeClass(o.value),
      message: t
    }, {
      default: withCtx(() => [
        F8
      ]),
      _: 1
    }, 8, ["class"]));
  }
});
var P8 = { class: "chat-messages-list" };
var $8 = defineComponent({
  __name: "MessagesList",
  props: {
    messages: {}
  },
  setup(n) {
    const e = Yn(), t = ref([]), { initialMessages: r, waitingForResponse: o } = e;
    return watch2(
      () => t.value.length,
      () => {
        const s = t.value[t.value.length - 1];
        s && s.scrollToView();
      }
    ), (s, i) => (openBlock(), createElementBlock("div", P8, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(r), (c) => (openBlock(), createBlock(Hn, {
        key: c.id,
        message: c
      }, null, 8, ["message"]))), 128)),
      (openBlock(true), createElementBlock(Fragment, null, renderList(s.messages, (c) => (openBlock(), createBlock(Hn, {
        key: c.id,
        ref_for: true,
        ref_key: "messageComponents",
        ref: t,
        message: c
      }, {
        beforeMessage: withCtx(({ message: a }) => [
          renderSlot(s.$slots, "beforeMessage", normalizeProps(guardReactiveProps({ message: a })))
        ]),
        _: 2
      }, 1032, ["message"]))), 128)),
      unref(o) ? (openBlock(), createBlock(B8, { key: 0 })) : createCommentVNode("", true)
    ]));
  }
});
var z8 = { class: "chat-heading" };
var U8 = ["title"];
var H8 = { key: 0 };
var ao = defineComponent({
  __name: "Chat",
  setup(n) {
    const { t: e } = fn(), t = Yn(), { messages: r, currentSessionId: o } = t, { options: s } = Ge(), i = computed2(() => s.mode === "window" && s.showWindowCloseButton);
    async function c() {
      t.startNewSession && (t.startNewSession(), nextTick(() => {
        re.emit("scrollToBottom");
      }));
    }
    async function a() {
      t.loadPreviousSession && (await t.loadPreviousSession(), nextTick(() => {
        re.emit("scrollToBottom");
      }));
    }
    function l() {
      re.emit("close");
    }
    return onMounted(async () => {
      await a(), !s.showWelcomeScreen && !o.value && await c();
    }), (u, p5) => (openBlock(), createBlock(gi, { class: "chat-wrapper" }, {
      header: withCtx(() => [
        createBaseVNode("div", z8, [
          createBaseVNode("h1", null, toDisplayString(unref(e)("title")), 1),
          i.value ? (openBlock(), createElementBlock("button", {
            key: 0,
            class: "chat-close-button",
            title: unref(e)("closeButtonTooltip"),
            onClick: l
          }, [
            createVNode(unref(Qs), {
              height: "18",
              width: "18"
            })
          ], 8, U8)) : createCommentVNode("", true)
        ]),
        unref(e)("subtitle") ? (openBlock(), createElementBlock("p", H8, toDisplayString(unref(e)("subtitle")), 1)) : createCommentVNode("", true)
      ]),
      footer: withCtx(() => [
        unref(o) ? (openBlock(), createBlock(fi, { key: 0 })) : (openBlock(), createBlock(lc, { key: 1 }))
      ]),
      default: withCtx(() => [
        !unref(o) && unref(s).showWelcomeScreen ? (openBlock(), createBlock(nc, {
          key: 0,
          "onClick:button": c
        })) : (openBlock(), createBlock($8, {
          key: 1,
          messages: unref(r)
        }, null, 8, ["messages"]))
      ]),
      _: 1
    }));
  }
});
var V8 = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
var G8 = createBaseVNode("path", {
  fill: "currentColor",
  d: "M12 3c5.5 0 10 3.58 10 8s-4.5 8-10 8c-1.24 0-2.43-.18-3.53-.5C5.55 21 2 21 2 21c2.33-2.33 2.7-3.9 2.75-4.5C3.05 15.07 2 13.13 2 11c0-4.42 4.5-8 10-8"
}, null, -1);
var j8 = [
  G8
];
function Z8(n, e) {
  return openBlock(), createElementBlock("svg", V8, [...j8]);
}
var K8 = { name: "mdi-chat", render: Z8 };
var W8 = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
var Y8 = createBaseVNode("path", {
  fill: "currentColor",
  d: "M7.41 8.58L12 13.17l4.59-4.59L18 10l-6 6l-6-6z"
}, null, -1);
var J8 = [
  Y8
];
function X8(n, e) {
  return openBlock(), createElementBlock("svg", W8, [...J8]);
}
var Q8 = { name: "mdi-chevron-down", render: X8 };
var eH = { class: "chat-window-wrapper" };
var nH = { class: "chat-window" };
var tH = defineComponent({
  __name: "ChatWindow",
  setup(n) {
    const e = ref(false);
    function t() {
      e.value = !e.value, e.value && nextTick(() => {
        re.emit("scrollToBottom");
      });
    }
    return (r, o) => (openBlock(), createElementBlock("div", eH, [
      createVNode(Transition, { name: "chat-window-transition" }, {
        default: withCtx(() => [
          withDirectives(createBaseVNode("div", nH, [
            createVNode(ao)
          ], 512), [
            [vShow, e.value]
          ])
        ]),
        _: 1
      }),
      createBaseVNode("div", {
        class: "chat-window-toggle",
        onClick: t
      }, [
        createVNode(Transition, {
          name: "chat-window-toggle-transition",
          mode: "out-in"
        }, {
          default: withCtx(() => [
            e.value ? (openBlock(), createBlock(unref(Q8), {
              key: 1,
              height: "32",
              width: "32"
            })) : (openBlock(), createBlock(unref(K8), {
              key: 0,
              height: "32",
              width: "32"
            }))
          ]),
          _: 1
        })
      ])
    ]));
  }
});
var rH = defineComponent({
  __name: "App",
  props: {},
  setup(n) {
    const { options: e } = Ge(), t = computed2(() => e.mode === "fullscreen");
    return onMounted(() => {
      be.registerLanguage("xml", Lr), be.registerLanguage("javascript", Rr);
    }), (r, o) => t.value ? (openBlock(), createBlock(unref(ao), {
      key: 0,
      class: "n8n-chat"
    })) : (openBlock(), createBlock(unref(tH), {
      key: 1,
      class: "n8n-chat"
    }));
  }
});
function sH(n) {
  var o, s;
  const e = {
    ...Fe,
    ...n,
    webhookConfig: {
      ...Fe.webhookConfig,
      ...n == null ? void 0 : n.webhookConfig
    },
    i18n: {
      ...Fe.i18n,
      ...n == null ? void 0 : n.i18n,
      en: {
        ...(o = Fe.i18n) == null ? void 0 : o.en,
        ...(s = n == null ? void 0 : n.i18n) == null ? void 0 : s.en
      }
    },
    theme: {
      ...Fe.theme,
      ...n == null ? void 0 : n.theme
    }
  }, t = e.target ?? Mo;
  typeof t == "string" && Go(t);
  const r = createApp(rH);
  return r.use(jo, e), r.mount(t), r;
}
export {
  sH as createChat
};
/*! Bundled license information:

@vue/shared/dist/shared.esm-bundler.js:
  (**
  * @vue/shared v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
  (*! #__NO_SIDE_EFFECTS__ *)

@vue/reactivity/dist/reactivity.esm-bundler.js:
  (**
  * @vue/reactivity v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

@vue/runtime-core/dist/runtime-core.esm-bundler.js:
  (**
  * @vue/runtime-core v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

@vue/runtime-core/dist/runtime-core.esm-bundler.js:
  (*! #__NO_SIDE_EFFECTS__ *)

@vue/runtime-core/dist/runtime-core.esm-bundler.js:
  (*! #__NO_SIDE_EFFECTS__ *)

@vue/runtime-core/dist/runtime-core.esm-bundler.js:
  (*! #__NO_SIDE_EFFECTS__ *)

@vue/runtime-dom/dist/runtime-dom.esm-bundler.js:
  (**
  * @vue/runtime-dom v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

@vue/runtime-dom/dist/runtime-dom.esm-bundler.js:
  (*! #__NO_SIDE_EFFECTS__ *)

@vue/runtime-dom/dist/runtime-dom.esm-bundler.js:
  (*! #__NO_SIDE_EFFECTS__ *)

vue/dist/vue.runtime.esm-bundler.js:
  (**
  * vue v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
*/
//# sourceMappingURL=@n8n_chat.js.map
