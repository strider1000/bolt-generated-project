import { ref as ee, computed as te, nextTick as $e, openBlock as S, createElementBlock as P, renderSlot as Ae, createElementVNode as G, inject as cr, isRef as _o, defineComponent as ae, createVNode as de, withCtx as xe, createTextVNode as ir, toDisplayString as ze, unref as B, createCommentVNode as se, getCurrentScope as bo, onScopeDispose as vo, readonly as ko, createBlock as Y, onMounted as qe, onUnmounted as xo, normalizeStyle as yo, withModifiers as Eo, withDirectives as ar, withKeys as wo, vModelText as Ao, Fragment as tn, renderList as rn, onBeforeUnmount as Co, h as So, toRefs as Do, normalizeClass as lr, normalizeProps as $n, guardReactiveProps as ur, resolveDynamicComponent as To, mergeProps as Ro, watch as Lo, Transition as pt, vShow as No, createApp as qo } from "vue";
const Fe = {
  webhookUrl: "http://localhost:5678",
  webhookConfig: {
    method: "POST",
    headers: {}
  },
  target: "#n8n-chat",
  mode: "window",
  loadPreviousSession: !0,
  chatInputKey: "chatInput",
  chatSessionKey: "sessionId",
  defaultLanguage: "en",
  showWelcomeScreen: !1,
  initialMessages: ["Hi there! 👋", "My name is Nathan. How can I assist you today?"],
  i18n: {
    en: {
      title: "Hi there! 👋",
      subtitle: "Start a chat. We're here to help you 24/7.",
      footer: "",
      getStarted: "New Conversation",
      inputPlaceholder: "Type your question..",
      closeButtonTooltip: "Close chat"
    }
  },
  theme: {}
}, Mo = "#n8n-chat", Io = "n8n-chat", ht = `${Io}/sessionId`, fr = "Chat", pr = "ChatOptions";
var X = [];
for (var wn = 0; wn < 256; ++wn)
  X.push((wn + 256).toString(16).slice(1));
function Oo(n, e = 0) {
  return (X[n[e + 0]] + X[n[e + 1]] + X[n[e + 2]] + X[n[e + 3]] + "-" + X[n[e + 4]] + X[n[e + 5]] + "-" + X[n[e + 6]] + X[n[e + 7]] + "-" + X[n[e + 8]] + X[n[e + 9]] + "-" + X[n[e + 10]] + X[n[e + 11]] + X[n[e + 12]] + X[n[e + 13]] + X[n[e + 14]] + X[n[e + 15]]).toLowerCase();
}
var Je, Fo = new Uint8Array(16);
function Bo() {
  if (!Je && (Je = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Je))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Je(Fo);
}
var Po = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const dt = {
  randomUUID: Po
};
function Be(n, e, t) {
  if (dt.randomUUID && !e && !n)
    return dt.randomUUID();
  n = n || {};
  var r = n.random || (n.rng || Bo)();
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, Oo(r);
}
async function $o() {
  return "";
}
async function Vn(...n) {
  var s, i;
  const e = await $o(), t = (s = n[1]) == null ? void 0 : s.body, r = {
    ...e ? { authorization: `Bearer ${e}` } : {},
    ...(i = n[1]) == null ? void 0 : i.headers
  };
  return t instanceof FormData ? delete r["Content-Type"] : r["Content-Type"] = "application/json", await (await fetch(n[0], {
    ...n[1],
    mode: "cors",
    cache: "no-cache",
    headers: r
  })).json();
}
async function hr(n, e = {}, t = {}) {
  let r = n;
  return Object.keys(e).length > 0 && (r = `${r}?${new URLSearchParams(
    e
  ).toString()}`), await Vn(r, { ...t, method: "GET" });
}
async function dr(n, e = {}, t = {}) {
  return await Vn(n, {
    ...t,
    method: "POST",
    body: JSON.stringify(e)
  });
}
async function zo(n, e = {}, t = [], r = {}) {
  const o = new FormData();
  for (const s in e)
    o.append(s, e[s]);
  for (const s of t)
    o.append("files", s);
  return await Vn(n, {
    ...r,
    method: "POST",
    body: o
  });
}
async function Uo(n, e) {
  var r, o;
  return await (((r = e.webhookConfig) == null ? void 0 : r.method) === "POST" ? dr : hr)(
    `${e.webhookUrl}`,
    {
      action: "loadPreviousSession",
      [e.chatSessionKey]: n,
      ...e.metadata ? { metadata: e.metadata } : {}
    },
    {
      headers: (o = e.webhookConfig) == null ? void 0 : o.headers
    }
  );
}
async function Ho(n, e, t, r) {
  var s, i, c;
  return e.length > 0 ? await zo(
    `${r.webhookUrl}`,
    {
      action: "sendMessage",
      [r.chatSessionKey]: t,
      [r.chatInputKey]: n,
      ...r.metadata ? { metadata: r.metadata } : {}
    },
    e,
    {
      headers: (s = r.webhookConfig) == null ? void 0 : s.headers
    }
  ) : await (((i = r.webhookConfig) == null ? void 0 : i.method) === "POST" ? dr : hr)(
    `${r.webhookUrl}`,
    {
      action: "sendMessage",
      [r.chatSessionKey]: t,
      [r.chatInputKey]: n,
      ...r.metadata ? { metadata: r.metadata } : {}
    },
    {
      headers: (c = r.webhookConfig) == null ? void 0 : c.headers
    }
  );
}
function Vo() {
  const n = /* @__PURE__ */ new Map();
  function e(o, s) {
    const i = n.get(o);
    i && i.splice(i.indexOf(s) >>> 0, 1);
  }
  function t(o, s) {
    let i = n.get(o);
    return i ? i.push(s) : i = [s], n.set(o, i), () => e(o, s);
  }
  function r(o, s) {
    const i = n.get(o);
    i && i.slice().forEach(async (c) => {
      await c(s);
    });
  }
  return {
    on: t,
    off: e,
    emit: r
  };
}
function Go(n) {
  if (!document.querySelector(n)) {
    const t = document.createElement("div");
    n.startsWith("#") && (t.id = n.replace("#", "")), n.startsWith(".") && t.classList.add(n.replace(".", "")), document.body.appendChild(t);
  }
}
const re = Vo(), jo = {
  install(n, e) {
    n.provide(pr, e);
    const t = ee([]), r = ee(null), o = ee(!1), s = te(
      () => (e.initialMessages ?? []).map((u) => ({
        id: Be(),
        text: u,
        sender: "bot",
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
      }))
    );
    async function i(u, p = []) {
      const f = {
        id: Be(),
        text: u,
        sender: "user",
        files: p,
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      t.value.push(f), o.value = !0, $e(() => {
        re.emit("scrollToBottom");
      });
      const h = await Ho(
        u,
        p,
        r.value,
        e
      );
      let d = h.output ?? h.text ?? "";
      if (d === "" && Object.keys(h).length > 0)
        try {
          d = JSON.stringify(h, null, 2);
        } catch {
        }
      const g = {
        id: Be(),
        text: d,
        sender: "bot",
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      t.value.push(g), o.value = !1, $e(() => {
        re.emit("scrollToBottom");
      });
    }
    async function c() {
      if (!e.loadPreviousSession)
        return;
      const u = localStorage.getItem(ht) ?? Be(), p = await Uo(u, e), f = (/* @__PURE__ */ new Date()).toISOString();
      return t.value = ((p == null ? void 0 : p.data) || []).map((h, d) => ({
        id: `${d}`,
        text: h.kwargs.content,
        sender: h.id.includes("HumanMessage") ? "user" : "bot",
        createdAt: f
      })), t.value.length && (r.value = u), u;
    }
    async function a() {
      r.value = Be(), localStorage.setItem(ht, r.value);
    }
    const l = {
      initialMessages: s,
      messages: t,
      currentSessionId: r,
      waitingForResponse: o,
      loadPreviousSession: c,
      startNewSession: a,
      sendMessage: i
    };
    n.provide(fr, l), n.config.globalProperties.$chat = l;
  }
};
function Gn(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function Zo(n) {
  if (n.__esModule)
    return n;
  var e = n.default;
  if (typeof e == "function") {
    var t = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(n).forEach(function(r) {
    var o = Object.getOwnPropertyDescriptor(n, r);
    Object.defineProperty(t, r, o.get ? o : {
      enumerable: !0,
      get: function() {
        return n[r];
      }
    });
  }), t;
}
function gr(n) {
  return n instanceof Map ? n.clear = n.delete = n.set = function() {
    throw new Error("map is read-only");
  } : n instanceof Set && (n.add = n.clear = n.delete = function() {
    throw new Error("set is read-only");
  }), Object.freeze(n), Object.getOwnPropertyNames(n).forEach((e) => {
    const t = n[e], r = typeof t;
    (r === "object" || r === "function") && !Object.isFrozen(t) && gr(t);
  }), n;
}
class gt {
  /**
   * @param {CompiledMode} mode
   */
  constructor(e) {
    e.data === void 0 && (e.data = {}), this.data = e.data, this.isMatchIgnored = !1;
  }
  ignoreMatch() {
    this.isMatchIgnored = !0;
  }
}
function mr(n) {
  return n.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function ke(n, ...e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const r in n)
    t[r] = n[r];
  return e.forEach(function(r) {
    for (const o in r)
      t[o] = r[o];
  }), /** @type {T} */
  t;
}
const Ko = "</span>", mt = (n) => !!n.scope, Wo = (n, { prefix: e }) => {
  if (n.startsWith("language:"))
    return n.replace("language:", "language-");
  if (n.includes(".")) {
    const t = n.split(".");
    return [
      `${e}${t.shift()}`,
      ...t.map((r, o) => `${r}${"_".repeat(o + 1)}`)
    ].join(" ");
  }
  return `${e}${n}`;
};
class Yo {
  /**
   * Creates a new HTMLRenderer
   *
   * @param {Tree} parseTree - the parse tree (must support `walk` API)
   * @param {{classPrefix: string}} options
   */
  constructor(e, t) {
    this.buffer = "", this.classPrefix = t.classPrefix, e.walk(this);
  }
  /**
   * Adds texts to the output stream
   *
   * @param {string} text */
  addText(e) {
    this.buffer += mr(e);
  }
  /**
   * Adds a node open to the output stream (if needed)
   *
   * @param {Node} node */
  openNode(e) {
    if (!mt(e))
      return;
    const t = Wo(
      e.scope,
      { prefix: this.classPrefix }
    );
    this.span(t);
  }
  /**
   * Adds a node close to the output stream (if needed)
   *
   * @param {Node} node */
  closeNode(e) {
    mt(e) && (this.buffer += Ko);
  }
  /**
   * returns the accumulated buffer
  */
  value() {
    return this.buffer;
  }
  // helpers
  /**
   * Builds a span element
   *
   * @param {string} className */
  span(e) {
    this.buffer += `<span class="${e}">`;
  }
}
const _t = (n = {}) => {
  const e = { children: [] };
  return Object.assign(e, n), e;
};
class jn {
  constructor() {
    this.rootNode = _t(), this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  /** @param {Node} node */
  add(e) {
    this.top.children.push(e);
  }
  /** @param {string} scope */
  openNode(e) {
    const t = _t({ scope: e });
    this.add(t), this.stack.push(t);
  }
  closeNode() {
    if (this.stack.length > 1)
      return this.stack.pop();
  }
  closeAllNodes() {
    for (; this.closeNode(); )
      ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  /**
   * @typedef { import("./html_renderer").Renderer } Renderer
   * @param {Renderer} builder
   */
  walk(e) {
    return this.constructor._walk(e, this.rootNode);
  }
  /**
   * @param {Renderer} builder
   * @param {Node} node
   */
  static _walk(e, t) {
    return typeof t == "string" ? e.addText(t) : t.children && (e.openNode(t), t.children.forEach((r) => this._walk(e, r)), e.closeNode(t)), e;
  }
  /**
   * @param {Node} node
   */
  static _collapse(e) {
    typeof e != "string" && e.children && (e.children.every((t) => typeof t == "string") ? e.children = [e.children.join("")] : e.children.forEach((t) => {
      jn._collapse(t);
    }));
  }
}
class Jo extends jn {
  /**
   * @param {*} options
   */
  constructor(e) {
    super(), this.options = e;
  }
  /**
   * @param {string} text
   */
  addText(e) {
    e !== "" && this.add(e);
  }
  /** @param {string} scope */
  startScope(e) {
    this.openNode(e);
  }
  endScope() {
    this.closeNode();
  }
  /**
   * @param {Emitter & {root: DataNode}} emitter
   * @param {string} name
   */
  __addSublanguage(e, t) {
    const r = e.root;
    t && (r.scope = `language:${t}`), this.add(r);
  }
  toHTML() {
    return new Yo(this, this.options).value();
  }
  finalize() {
    return this.closeAllNodes(), !0;
  }
}
function Ue(n) {
  return n ? typeof n == "string" ? n : n.source : null;
}
function _r(n) {
  return De("(?=", n, ")");
}
function Xo(n) {
  return De("(?:", n, ")*");
}
function Qo(n) {
  return De("(?:", n, ")?");
}
function De(...n) {
  return n.map((t) => Ue(t)).join("");
}
function es(n) {
  const e = n[n.length - 1];
  return typeof e == "object" && e.constructor === Object ? (n.splice(n.length - 1, 1), e) : {};
}
function Zn(...n) {
  return "(" + (es(n).capture ? "" : "?:") + n.map((r) => Ue(r)).join("|") + ")";
}
function br(n) {
  return new RegExp(n.toString() + "|").exec("").length - 1;
}
function ns(n, e) {
  const t = n && n.exec(e);
  return t && t.index === 0;
}
const ts = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function Kn(n, { joinWith: e }) {
  let t = 0;
  return n.map((r) => {
    t += 1;
    const o = t;
    let s = Ue(r), i = "";
    for (; s.length > 0; ) {
      const c = ts.exec(s);
      if (!c) {
        i += s;
        break;
      }
      i += s.substring(0, c.index), s = s.substring(c.index + c[0].length), c[0][0] === "\\" && c[1] ? i += "\\" + String(Number(c[1]) + o) : (i += c[0], c[0] === "(" && t++);
    }
    return i;
  }).map((r) => `(${r})`).join(e);
}
const rs = /\b\B/, vr = "[a-zA-Z]\\w*", Wn = "[a-zA-Z_]\\w*", kr = "\\b\\d+(\\.\\d+)?", xr = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", yr = "\\b(0b[01]+)", os = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", ss = (n = {}) => {
  const e = /^#![ ]*\//;
  return n.binary && (n.begin = De(
    e,
    /.*\b/,
    n.binary,
    /\b.*/
  )), ke({
    scope: "meta",
    begin: e,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": (t, r) => {
      t.index !== 0 && r.ignoreMatch();
    }
  }, n);
}, He = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
}, cs = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [He]
}, is = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [He]
}, as = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
}, ln = function(n, e, t = {}) {
  const r = ke(
    {
      scope: "comment",
      begin: n,
      end: e,
      contains: []
    },
    t
  );
  r.contains.push({
    scope: "doctag",
    // hack to avoid the space from being included. the space is necessary to
    // match here to prevent the plain text rule below from gobbling up doctags
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: !0,
    relevance: 0
  });
  const o = Zn(
    // list of common 1 and 2 letter words in English
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    // note: this is not an exhaustive list of contractions, just popular ones
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    // contractions - can't we'd they're let's, etc
    /[A-Za-z]+[-][a-z]+/,
    // `no-way`, etc.
    /[A-Za-z][a-z]{2,}/
    // allow capitalized words at beginning of sentences
  );
  return r.contains.push(
    {
      // TODO: how to include ", (, ) without breaking grammars that use these for
      // comment delimiters?
      // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
      // ---
      // this tries to find sequences of 3 english words in a row (without any
      // "programming" type syntax) this gives us a strong signal that we've
      // TRULY found a comment - vs perhaps scanning with the wrong language.
      // It's possible to find something that LOOKS like the start of the
      // comment - but then if there is no readable text - good chance it is a
      // false match and not a comment.
      //
      // for a visual example please see:
      // https://github.com/highlightjs/highlight.js/issues/2827
      begin: De(
        /[ ]+/,
        // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
        "(",
        o,
        /[.]?[:]?([.][ ]|[ ])/,
        "){3}"
      )
      // look for 3 words in a row
    }
  ), r;
}, ls = ln("//", "$"), us = ln("/\\*", "\\*/"), fs = ln("#", "$"), ps = {
  scope: "number",
  begin: kr,
  relevance: 0
}, hs = {
  scope: "number",
  begin: xr,
  relevance: 0
}, ds = {
  scope: "number",
  begin: yr,
  relevance: 0
}, gs = {
  scope: "regexp",
  begin: /\/(?=[^/\n]*\/)/,
  end: /\/[gimuy]*/,
  contains: [
    He,
    {
      begin: /\[/,
      end: /\]/,
      relevance: 0,
      contains: [He]
    }
  ]
}, ms = {
  scope: "title",
  begin: vr,
  relevance: 0
}, _s = {
  scope: "title",
  begin: Wn,
  relevance: 0
}, bs = {
  // excludes method names from keyword processing
  begin: "\\.\\s*" + Wn,
  relevance: 0
}, vs = function(n) {
  return Object.assign(
    n,
    {
      /** @type {ModeCallback} */
      "on:begin": (e, t) => {
        t.data._beginMatch = e[1];
      },
      /** @type {ModeCallback} */
      "on:end": (e, t) => {
        t.data._beginMatch !== e[1] && t.ignoreMatch();
      }
    }
  );
};
var Xe = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  APOS_STRING_MODE: cs,
  BACKSLASH_ESCAPE: He,
  BINARY_NUMBER_MODE: ds,
  BINARY_NUMBER_RE: yr,
  COMMENT: ln,
  C_BLOCK_COMMENT_MODE: us,
  C_LINE_COMMENT_MODE: ls,
  C_NUMBER_MODE: hs,
  C_NUMBER_RE: xr,
  END_SAME_AS_BEGIN: vs,
  HASH_COMMENT_MODE: fs,
  IDENT_RE: vr,
  MATCH_NOTHING_RE: rs,
  METHOD_GUARD: bs,
  NUMBER_MODE: ps,
  NUMBER_RE: kr,
  PHRASAL_WORDS_MODE: as,
  QUOTE_STRING_MODE: is,
  REGEXP_MODE: gs,
  RE_STARTERS_RE: os,
  SHEBANG: ss,
  TITLE_MODE: ms,
  UNDERSCORE_IDENT_RE: Wn,
  UNDERSCORE_TITLE_MODE: _s
});
function ks(n, e) {
  n.input[n.index - 1] === "." && e.ignoreMatch();
}
function xs(n, e) {
  n.className !== void 0 && (n.scope = n.className, delete n.className);
}
function ys(n, e) {
  e && n.beginKeywords && (n.begin = "\\b(" + n.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", n.__beforeBegin = ks, n.keywords = n.keywords || n.beginKeywords, delete n.beginKeywords, n.relevance === void 0 && (n.relevance = 0));
}
function Es(n, e) {
  Array.isArray(n.illegal) && (n.illegal = Zn(...n.illegal));
}
function ws(n, e) {
  if (n.match) {
    if (n.begin || n.end)
      throw new Error("begin & end are not supported with match");
    n.begin = n.match, delete n.match;
  }
}
function As(n, e) {
  n.relevance === void 0 && (n.relevance = 1);
}
const Cs = (n, e) => {
  if (!n.beforeMatch)
    return;
  if (n.starts)
    throw new Error("beforeMatch cannot be used with starts");
  const t = Object.assign({}, n);
  Object.keys(n).forEach((r) => {
    delete n[r];
  }), n.keywords = t.keywords, n.begin = De(t.beforeMatch, _r(t.begin)), n.starts = {
    relevance: 0,
    contains: [
      Object.assign(t, { endsParent: !0 })
    ]
  }, n.relevance = 0, delete t.beforeMatch;
}, Ss = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  // common variable name
  "list",
  // common variable name
  "value"
  // common variable name
], Ds = "keyword";
function Er(n, e, t = Ds) {
  const r = /* @__PURE__ */ Object.create(null);
  return typeof n == "string" ? o(t, n.split(" ")) : Array.isArray(n) ? o(t, n) : Object.keys(n).forEach(function(s) {
    Object.assign(
      r,
      Er(n[s], e, s)
    );
  }), r;
  function o(s, i) {
    e && (i = i.map((c) => c.toLowerCase())), i.forEach(function(c) {
      const a = c.split("|");
      r[a[0]] = [s, Ts(a[0], a[1])];
    });
  }
}
function Ts(n, e) {
  return e ? Number(e) : Rs(n) ? 0 : 1;
}
function Rs(n) {
  return Ss.includes(n.toLowerCase());
}
const bt = {}, Ce = (n) => {
  console.error(n);
}, vt = (n, ...e) => {
  console.log(`WARN: ${n}`, ...e);
}, Te = (n, e) => {
  bt[`${n}/${e}`] || (console.log(`Deprecated as of ${n}. ${e}`), bt[`${n}/${e}`] = !0);
}, on = new Error();
function wr(n, e, { key: t }) {
  let r = 0;
  const o = n[t], s = {}, i = {};
  for (let c = 1; c <= e.length; c++)
    i[c + r] = o[c], s[c + r] = !0, r += br(e[c - 1]);
  n[t] = i, n[t]._emit = s, n[t]._multi = !0;
}
function Ls(n) {
  if (Array.isArray(n.begin)) {
    if (n.skip || n.excludeBegin || n.returnBegin)
      throw Ce("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), on;
    if (typeof n.beginScope != "object" || n.beginScope === null)
      throw Ce("beginScope must be object"), on;
    wr(n, n.begin, { key: "beginScope" }), n.begin = Kn(n.begin, { joinWith: "" });
  }
}
function Ns(n) {
  if (Array.isArray(n.end)) {
    if (n.skip || n.excludeEnd || n.returnEnd)
      throw Ce("skip, excludeEnd, returnEnd not compatible with endScope: {}"), on;
    if (typeof n.endScope != "object" || n.endScope === null)
      throw Ce("endScope must be object"), on;
    wr(n, n.end, { key: "endScope" }), n.end = Kn(n.end, { joinWith: "" });
  }
}
function qs(n) {
  n.scope && typeof n.scope == "object" && n.scope !== null && (n.beginScope = n.scope, delete n.scope);
}
function Ms(n) {
  qs(n), typeof n.beginScope == "string" && (n.beginScope = { _wrap: n.beginScope }), typeof n.endScope == "string" && (n.endScope = { _wrap: n.endScope }), Ls(n), Ns(n);
}
function Is(n) {
  function e(i, c) {
    return new RegExp(
      Ue(i),
      "m" + (n.case_insensitive ? "i" : "") + (n.unicodeRegex ? "u" : "") + (c ? "g" : "")
    );
  }
  class t {
    constructor() {
      this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
    }
    // @ts-ignore
    addRule(c, a) {
      a.position = this.position++, this.matchIndexes[this.matchAt] = a, this.regexes.push([a, c]), this.matchAt += br(c) + 1;
    }
    compile() {
      this.regexes.length === 0 && (this.exec = () => null);
      const c = this.regexes.map((a) => a[1]);
      this.matcherRe = e(Kn(c, { joinWith: "|" }), !0), this.lastIndex = 0;
    }
    /** @param {string} s */
    exec(c) {
      this.matcherRe.lastIndex = this.lastIndex;
      const a = this.matcherRe.exec(c);
      if (!a)
        return null;
      const l = a.findIndex((p, f) => f > 0 && p !== void 0), u = this.matchIndexes[l];
      return a.splice(0, l), Object.assign(a, u);
    }
  }
  class r {
    constructor() {
      this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
    }
    // @ts-ignore
    getMatcher(c) {
      if (this.multiRegexes[c])
        return this.multiRegexes[c];
      const a = new t();
      return this.rules.slice(c).forEach(([l, u]) => a.addRule(l, u)), a.compile(), this.multiRegexes[c] = a, a;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    // @ts-ignore
    addRule(c, a) {
      this.rules.push([c, a]), a.type === "begin" && this.count++;
    }
    /** @param {string} s */
    exec(c) {
      const a = this.getMatcher(this.regexIndex);
      a.lastIndex = this.lastIndex;
      let l = a.exec(c);
      if (this.resumingScanAtSamePosition() && !(l && l.index === this.lastIndex)) {
        const u = this.getMatcher(0);
        u.lastIndex = this.lastIndex + 1, l = u.exec(c);
      }
      return l && (this.regexIndex += l.position + 1, this.regexIndex === this.count && this.considerAll()), l;
    }
  }
  function o(i) {
    const c = new r();
    return i.contains.forEach((a) => c.addRule(a.begin, { rule: a, type: "begin" })), i.terminatorEnd && c.addRule(i.terminatorEnd, { type: "end" }), i.illegal && c.addRule(i.illegal, { type: "illegal" }), c;
  }
  function s(i, c) {
    const a = (
      /** @type CompiledMode */
      i
    );
    if (i.isCompiled)
      return a;
    [
      xs,
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      ws,
      Ms,
      Cs
    ].forEach((u) => u(i, c)), n.compilerExtensions.forEach((u) => u(i, c)), i.__beforeBegin = null, [
      ys,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      Es,
      // default to 1 relevance if not specified
      As
    ].forEach((u) => u(i, c)), i.isCompiled = !0;
    let l = null;
    return typeof i.keywords == "object" && i.keywords.$pattern && (i.keywords = Object.assign({}, i.keywords), l = i.keywords.$pattern, delete i.keywords.$pattern), l = l || /\w+/, i.keywords && (i.keywords = Er(i.keywords, n.case_insensitive)), a.keywordPatternRe = e(l, !0), c && (i.begin || (i.begin = /\B|\b/), a.beginRe = e(a.begin), !i.end && !i.endsWithParent && (i.end = /\B|\b/), i.end && (a.endRe = e(a.end)), a.terminatorEnd = Ue(a.end) || "", i.endsWithParent && c.terminatorEnd && (a.terminatorEnd += (i.end ? "|" : "") + c.terminatorEnd)), i.illegal && (a.illegalRe = e(
      /** @type {RegExp | string} */
      i.illegal
    )), i.contains || (i.contains = []), i.contains = [].concat(...i.contains.map(function(u) {
      return Os(u === "self" ? i : u);
    })), i.contains.forEach(function(u) {
      s(
        /** @type Mode */
        u,
        a
      );
    }), i.starts && s(i.starts, c), a.matcher = o(a), a;
  }
  if (n.compilerExtensions || (n.compilerExtensions = []), n.contains && n.contains.includes("self"))
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  return n.classNameAliases = ke(n.classNameAliases || {}), s(
    /** @type Mode */
    n
  );
}
function Ar(n) {
  return n ? n.endsWithParent || Ar(n.starts) : !1;
}
function Os(n) {
  return n.variants && !n.cachedVariants && (n.cachedVariants = n.variants.map(function(e) {
    return ke(n, { variants: null }, e);
  })), n.cachedVariants ? n.cachedVariants : Ar(n) ? ke(n, { starts: n.starts ? ke(n.starts) : null }) : Object.isFrozen(n) ? ke(n) : n;
}
var Fs = "11.9.0";
class Bs extends Error {
  constructor(e, t) {
    super(e), this.name = "HTMLInjectionError", this.html = t;
  }
}
const An = mr, kt = ke, xt = Symbol("nomatch"), Ps = 7, Cr = function(n) {
  const e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null), r = [];
  let o = !0;
  const s = "Could not find the language '{}', did you forget to load/include a language module?", i = { disableAutodetect: !0, name: "Plain text", contains: [] };
  let c = {
    ignoreUnescapedHTML: !1,
    throwUnescapedHTML: !1,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: Jo
  };
  function a(m) {
    return c.noHighlightRe.test(m);
  }
  function l(m) {
    let k = m.className + " ";
    k += m.parentNode ? m.parentNode.className : "";
    const R = c.languageDetectRe.exec(k);
    if (R) {
      const F = j(R[1]);
      return F || (vt(s.replace("{}", R[1])), vt("Falling back to no-highlight mode for this block.", m)), F ? R[1] : "no-highlight";
    }
    return k.split(/\s+/).find((F) => a(F) || j(F));
  }
  function u(m, k, R) {
    let F = "", U = "";
    typeof k == "object" ? (F = m, R = k.ignoreIllegals, U = k.language) : (Te("10.7.0", "highlight(lang, code, ...args) has been deprecated."), Te("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), U = m, F = k), R === void 0 && (R = !0);
    const W = {
      code: F,
      language: U
    };
    T("before:highlight", W);
    const ne = W.result ? W.result : p(W.language, W.code, R);
    return ne.code = W.code, T("after:highlight", ne), ne;
  }
  function p(m, k, R, F) {
    const U = /* @__PURE__ */ Object.create(null);
    function W(y, C) {
      return y.keywords[C];
    }
    function ne() {
      if (!N.keywords) {
        J.addText(V);
        return;
      }
      let y = 0;
      N.keywordPatternRe.lastIndex = 0;
      let C = N.keywordPatternRe.exec(V), I = "";
      for (; C; ) {
        I += V.substring(y, C.index);
        const H = fe.case_insensitive ? C[0].toLowerCase() : C[0], Q = W(N, H);
        if (Q) {
          const [_e, go] = Q;
          if (J.addText(I), I = "", U[H] = (U[H] || 0) + 1, U[H] <= Ps && (Ye += go), _e.startsWith("_"))
            I += C[0];
          else {
            const mo = fe.classNameAliases[_e] || _e;
            ue(C[0], mo);
          }
        } else
          I += C[0];
        y = N.keywordPatternRe.lastIndex, C = N.keywordPatternRe.exec(V);
      }
      I += V.substring(y), J.addText(I);
    }
    function Ke() {
      if (V === "")
        return;
      let y = null;
      if (typeof N.subLanguage == "string") {
        if (!e[N.subLanguage]) {
          J.addText(V);
          return;
        }
        y = p(N.subLanguage, V, !0, ft[N.subLanguage]), ft[N.subLanguage] = /** @type {CompiledMode} */
        y._top;
      } else
        y = h(V, N.subLanguage.length ? N.subLanguage : null);
      N.relevance > 0 && (Ye += y.relevance), J.__addSublanguage(y._emitter, y.language);
    }
    function oe() {
      N.subLanguage != null ? Ke() : ne(), V = "";
    }
    function ue(y, C) {
      y !== "" && (J.startScope(C), J.addText(y), J.endScope());
    }
    function it(y, C) {
      let I = 1;
      const H = C.length - 1;
      for (; I <= H; ) {
        if (!y._emit[I]) {
          I++;
          continue;
        }
        const Q = fe.classNameAliases[y[I]] || y[I], _e = C[I];
        Q ? ue(_e, Q) : (V = _e, ne(), V = ""), I++;
      }
    }
    function at(y, C) {
      return y.scope && typeof y.scope == "string" && J.openNode(fe.classNameAliases[y.scope] || y.scope), y.beginScope && (y.beginScope._wrap ? (ue(V, fe.classNameAliases[y.beginScope._wrap] || y.beginScope._wrap), V = "") : y.beginScope._multi && (it(y.beginScope, C), V = "")), N = Object.create(y, { parent: { value: N } }), N;
    }
    function lt(y, C, I) {
      let H = ns(y.endRe, I);
      if (H) {
        if (y["on:end"]) {
          const Q = new gt(y);
          y["on:end"](C, Q), Q.isMatchIgnored && (H = !1);
        }
        if (H) {
          for (; y.endsParent && y.parent; )
            y = y.parent;
          return y;
        }
      }
      if (y.endsWithParent)
        return lt(y.parent, C, I);
    }
    function lo(y) {
      return N.matcher.regexIndex === 0 ? (V += y[0], 1) : (En = !0, 0);
    }
    function uo(y) {
      const C = y[0], I = y.rule, H = new gt(I), Q = [I.__beforeBegin, I["on:begin"]];
      for (const _e of Q)
        if (_e && (_e(y, H), H.isMatchIgnored))
          return lo(C);
      return I.skip ? V += C : (I.excludeBegin && (V += C), oe(), !I.returnBegin && !I.excludeBegin && (V = C)), at(I, y), I.returnBegin ? 0 : C.length;
    }
    function fo(y) {
      const C = y[0], I = k.substring(y.index), H = lt(N, y, I);
      if (!H)
        return xt;
      const Q = N;
      N.endScope && N.endScope._wrap ? (oe(), ue(C, N.endScope._wrap)) : N.endScope && N.endScope._multi ? (oe(), it(N.endScope, y)) : Q.skip ? V += C : (Q.returnEnd || Q.excludeEnd || (V += C), oe(), Q.excludeEnd && (V = C));
      do
        N.scope && J.closeNode(), !N.skip && !N.subLanguage && (Ye += N.relevance), N = N.parent;
      while (N !== H.parent);
      return H.starts && at(H.starts, y), Q.returnEnd ? 0 : C.length;
    }
    function po() {
      const y = [];
      for (let C = N; C !== fe; C = C.parent)
        C.scope && y.unshift(C.scope);
      y.forEach((C) => J.openNode(C));
    }
    let We = {};
    function ut(y, C) {
      const I = C && C[0];
      if (V += y, I == null)
        return oe(), 0;
      if (We.type === "begin" && C.type === "end" && We.index === C.index && I === "") {
        if (V += k.slice(C.index, C.index + 1), !o) {
          const H = new Error(`0 width match regex (${m})`);
          throw H.languageName = m, H.badRule = We.rule, H;
        }
        return 1;
      }
      if (We = C, C.type === "begin")
        return uo(C);
      if (C.type === "illegal" && !R) {
        const H = new Error('Illegal lexeme "' + I + '" for mode "' + (N.scope || "<unnamed>") + '"');
        throw H.mode = N, H;
      } else if (C.type === "end") {
        const H = fo(C);
        if (H !== xt)
          return H;
      }
      if (C.type === "illegal" && I === "")
        return 1;
      if (yn > 1e5 && yn > C.index * 3)
        throw new Error("potential infinite loop, way more iterations than matches");
      return V += I, I.length;
    }
    const fe = j(m);
    if (!fe)
      throw Ce(s.replace("{}", m)), new Error('Unknown language: "' + m + '"');
    const ho = Is(fe);
    let xn = "", N = F || ho;
    const ft = {}, J = new c.__emitter(c);
    po();
    let V = "", Ye = 0, ye = 0, yn = 0, En = !1;
    try {
      if (fe.__emitTokens)
        fe.__emitTokens(k, J);
      else {
        for (N.matcher.considerAll(); ; ) {
          yn++, En ? En = !1 : N.matcher.considerAll(), N.matcher.lastIndex = ye;
          const y = N.matcher.exec(k);
          if (!y)
            break;
          const C = k.substring(ye, y.index), I = ut(C, y);
          ye = y.index + I;
        }
        ut(k.substring(ye));
      }
      return J.finalize(), xn = J.toHTML(), {
        language: m,
        value: xn,
        relevance: Ye,
        illegal: !1,
        _emitter: J,
        _top: N
      };
    } catch (y) {
      if (y.message && y.message.includes("Illegal"))
        return {
          language: m,
          value: An(k),
          illegal: !0,
          relevance: 0,
          _illegalBy: {
            message: y.message,
            index: ye,
            context: k.slice(ye - 100, ye + 100),
            mode: y.mode,
            resultSoFar: xn
          },
          _emitter: J
        };
      if (o)
        return {
          language: m,
          value: An(k),
          illegal: !1,
          relevance: 0,
          errorRaised: y,
          _emitter: J,
          _top: N
        };
      throw y;
    }
  }
  function f(m) {
    const k = {
      value: An(m),
      illegal: !1,
      relevance: 0,
      _top: i,
      _emitter: new c.__emitter(c)
    };
    return k._emitter.addText(m), k;
  }
  function h(m, k) {
    k = k || c.languages || Object.keys(e);
    const R = f(m), F = k.filter(j).filter(K).map(
      (oe) => p(oe, m, !1)
    );
    F.unshift(R);
    const U = F.sort((oe, ue) => {
      if (oe.relevance !== ue.relevance)
        return ue.relevance - oe.relevance;
      if (oe.language && ue.language) {
        if (j(oe.language).supersetOf === ue.language)
          return 1;
        if (j(ue.language).supersetOf === oe.language)
          return -1;
      }
      return 0;
    }), [W, ne] = U, Ke = W;
    return Ke.secondBest = ne, Ke;
  }
  function d(m, k, R) {
    const F = k && t[k] || R;
    m.classList.add("hljs"), m.classList.add(`language-${F}`);
  }
  function g(m) {
    let k = null;
    const R = l(m);
    if (a(R))
      return;
    if (T(
      "before:highlightElement",
      { el: m, language: R }
    ), m.dataset.highlighted) {
      console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", m);
      return;
    }
    if (m.children.length > 0 && (c.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(m)), c.throwUnescapedHTML))
      throw new Bs(
        "One of your code blocks includes unescaped HTML.",
        m.innerHTML
      );
    k = m;
    const F = k.textContent, U = R ? u(F, { language: R, ignoreIllegals: !0 }) : h(F);
    m.innerHTML = U.value, m.dataset.highlighted = "yes", d(m, R, U.language), m.result = {
      language: U.language,
      // TODO: remove with version 11.0
      re: U.relevance,
      relevance: U.relevance
    }, U.secondBest && (m.secondBest = {
      language: U.secondBest.language,
      relevance: U.secondBest.relevance
    }), T("after:highlightElement", { el: m, result: U, text: F });
  }
  function E(m) {
    c = kt(c, m);
  }
  const x = () => {
    D(), Te("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function b() {
    D(), Te("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let A = !1;
  function D() {
    if (document.readyState === "loading") {
      A = !0;
      return;
    }
    document.querySelectorAll(c.cssSelector).forEach(g);
  }
  function L() {
    A && D();
  }
  typeof window < "u" && window.addEventListener && window.addEventListener("DOMContentLoaded", L, !1);
  function v(m, k) {
    let R = null;
    try {
      R = k(n);
    } catch (F) {
      if (Ce("Language definition for '{}' could not be registered.".replace("{}", m)), o)
        Ce(F);
      else
        throw F;
      R = i;
    }
    R.name || (R.name = m), e[m] = R, R.rawDefinition = k.bind(null, n), R.aliases && M(R.aliases, { languageName: m });
  }
  function O(m) {
    delete e[m];
    for (const k of Object.keys(t))
      t[k] === m && delete t[k];
  }
  function z() {
    return Object.keys(e);
  }
  function j(m) {
    return m = (m || "").toLowerCase(), e[m] || e[t[m]];
  }
  function M(m, { languageName: k }) {
    typeof m == "string" && (m = [m]), m.forEach((R) => {
      t[R.toLowerCase()] = k;
    });
  }
  function K(m) {
    const k = j(m);
    return k && !k.disableAutodetect;
  }
  function q(m) {
    m["before:highlightBlock"] && !m["before:highlightElement"] && (m["before:highlightElement"] = (k) => {
      m["before:highlightBlock"](
        Object.assign({ block: k.el }, k)
      );
    }), m["after:highlightBlock"] && !m["after:highlightElement"] && (m["after:highlightElement"] = (k) => {
      m["after:highlightBlock"](
        Object.assign({ block: k.el }, k)
      );
    });
  }
  function Z(m) {
    q(m), r.push(m);
  }
  function _(m) {
    const k = r.indexOf(m);
    k !== -1 && r.splice(k, 1);
  }
  function T(m, k) {
    const R = m;
    r.forEach(function(F) {
      F[R] && F[R](k);
    });
  }
  function w(m) {
    return Te("10.7.0", "highlightBlock will be removed entirely in v12.0"), Te("10.7.0", "Please use highlightElement now."), g(m);
  }
  Object.assign(n, {
    highlight: u,
    highlightAuto: h,
    highlightAll: D,
    highlightElement: g,
    // TODO: Remove with v12 API
    highlightBlock: w,
    configure: E,
    initHighlighting: x,
    initHighlightingOnLoad: b,
    registerLanguage: v,
    unregisterLanguage: O,
    listLanguages: z,
    getLanguage: j,
    registerAliases: M,
    autoDetection: K,
    inherit: kt,
    addPlugin: Z,
    removePlugin: _
  }), n.debugMode = function() {
    o = !1;
  }, n.safeMode = function() {
    o = !0;
  }, n.versionString = Fs, n.regex = {
    concat: De,
    lookahead: _r,
    either: Zn,
    optional: Qo,
    anyNumberOfTimes: Xo
  };
  for (const m in Xe)
    typeof Xe[m] == "object" && gr(Xe[m]);
  return Object.assign(n, Xe), n;
}, Ne = Cr({});
Ne.newInstance = () => Cr({});
var $s = Ne;
Ne.HighlightJS = Ne;
Ne.default = Ne;
const be = /* @__PURE__ */ Gn($s), yt = "[A-Za-z$_][0-9A-Za-z$_]*", zs = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
], Us = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
], Sr = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
], Dr = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
], Tr = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
], Hs = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
], Vs = [].concat(
  Tr,
  Sr,
  Dr
);
function Rr(n) {
  const e = n.regex, t = (k, { after: R }) => {
    const F = "</" + k[0].slice(1);
    return k.input.indexOf(F, R) !== -1;
  }, r = yt, o = {
    begin: "<>",
    end: "</>"
  }, s = /<[A-Za-z0-9\\._:-]+\s*\/>/, i = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (k, R) => {
      const F = k[0].length + k.index, U = k.input[F];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        U === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        U === ","
      ) {
        R.ignoreMatch();
        return;
      }
      U === ">" && (t(k, { after: F }) || R.ignoreMatch());
      let W;
      const ne = k.input.substring(F);
      if (W = ne.match(/^\s*=/)) {
        R.ignoreMatch();
        return;
      }
      if ((W = ne.match(/^\s+extends\s+/)) && W.index === 0) {
        R.ignoreMatch();
        return;
      }
    }
  }, c = {
    $pattern: yt,
    keyword: zs,
    literal: Us,
    built_in: Vs,
    "variable.language": Hs
  }, a = "[0-9](_?[0-9])*", l = `\\.(${a})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", p = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${u})((${l})|\\.)?|(${l}))[eE][+-]?(${a})\\b` },
      { begin: `\\b(${u})\\b((${l})\\b|\\.)?|(${l})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, f = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: c,
    contains: []
    // defined later
  }, h = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "xml"
    }
  }, d = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "css"
    }
  }, g = {
    begin: "gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "graphql"
    }
  }, E = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      n.BACKSLASH_ESCAPE,
      f
    ]
  }, b = {
    className: "comment",
    variants: [
      n.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: r + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      n.C_BLOCK_COMMENT_MODE,
      n.C_LINE_COMMENT_MODE
    ]
  }, A = [
    n.APOS_STRING_MODE,
    n.QUOTE_STRING_MODE,
    h,
    d,
    g,
    E,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    p
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  f.contains = A.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: c,
    contains: [
      "self"
    ].concat(A)
  });
  const D = [].concat(b, f.contains), L = D.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: c,
      contains: ["self"].concat(D)
    }
  ]), v = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: c,
    contains: L
  }, O = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          r,
          /\s+/,
          /extends/,
          /\s+/,
          e.concat(r, "(", e.concat(/\./, r), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          r
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, z = {
    relevance: 0,
    match: e.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...Sr,
        ...Dr
      ]
    }
  }, j = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, M = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          r,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [v],
    illegal: /%/
  }, K = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function q(k) {
    return e.concat("(?!", k.join("|"), ")");
  }
  const Z = {
    match: e.concat(
      /\b/,
      q([
        ...Tr,
        "super",
        "import"
      ]),
      r,
      e.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  }, _ = {
    begin: e.concat(/\./, e.lookahead(
      e.concat(r, /(?![0-9A-Za-z$_(])/)
    )),
    end: r,
    excludeBegin: !0,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, T = {
    match: [
      /get|set/,
      /\s+/,
      r,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      v
    ]
  }, w = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + n.UNDERSCORE_IDENT_RE + ")\\s*=>", m = {
    match: [
      /const|var|let/,
      /\s+/,
      r,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      e.lookahead(w)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      v
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: c,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: L, CLASS_REFERENCE: z },
    illegal: /#(?![$_A-z])/,
    contains: [
      n.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      j,
      n.APOS_STRING_MODE,
      n.QUOTE_STRING_MODE,
      h,
      d,
      g,
      E,
      b,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      p,
      z,
      {
        className: "attr",
        begin: r + e.lookahead(":"),
        relevance: 0
      },
      m,
      {
        // "value" container
        begin: "(" + n.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          b,
          n.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: w,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: n.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: c,
                    contains: L
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: o.begin, end: o.end },
              { match: s },
              {
                begin: i.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": i.isTrulyOpeningTag,
                end: i.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: i.begin,
                end: i.end,
                skip: !0,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      M,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + n.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: !0,
        label: "func.def",
        contains: [
          v,
          n.inherit(n.TITLE_MODE, { begin: r, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      _,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + r,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [v]
      },
      Z,
      K,
      O,
      T,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function Lr(n) {
  const e = n.regex, t = e.concat(/[\p{L}_]/u, e.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u), r = /[\p{L}0-9._:-]+/u, o = {
    className: "symbol",
    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
  }, s = {
    begin: /\s/,
    contains: [
      {
        className: "keyword",
        begin: /#?[a-z_][a-z1-9_-]+/,
        illegal: /\n/
      }
    ]
  }, i = n.inherit(s, {
    begin: /\(/,
    end: /\)/
  }), c = n.inherit(n.APOS_STRING_MODE, { className: "string" }), a = n.inherit(n.QUOTE_STRING_MODE, { className: "string" }), l = {
    endsWithParent: !0,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: "attr",
        begin: r,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: "string",
            endsParent: !0,
            variants: [
              {
                begin: /"/,
                end: /"/,
                contains: [o]
              },
              {
                begin: /'/,
                end: /'/,
                contains: [o]
              },
              { begin: /[^\s"'=<>`]+/ }
            ]
          }
        ]
      }
    ]
  };
  return {
    name: "HTML, XML",
    aliases: [
      "html",
      "xhtml",
      "rss",
      "atom",
      "xjb",
      "xsd",
      "xsl",
      "plist",
      "wsf",
      "svg"
    ],
    case_insensitive: !0,
    unicodeRegex: !0,
    contains: [
      {
        className: "meta",
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          s,
          a,
          c,
          i,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                contains: [
                  s,
                  i,
                  a,
                  c
                ]
              }
            ]
          }
        ]
      },
      n.COMMENT(
        /<!--/,
        /-->/,
        { relevance: 10 }
      ),
      {
        begin: /<!\[CDATA\[/,
        end: /\]\]>/,
        relevance: 10
      },
      o,
      // xml processing instructions
      {
        className: "meta",
        end: /\?>/,
        variants: [
          {
            begin: /<\?xml/,
            relevance: 10,
            contains: [
              a
            ]
          },
          {
            begin: /<\?[a-z][a-z0-9]+/
          }
        ]
      },
      {
        className: "tag",
        /*
        The lookahead pattern (?=...) ensures that 'begin' only matches
        '<style' as a single word, followed by a whitespace or an
        ending bracket.
        */
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: { name: "style" },
        contains: [l],
        starts: {
          end: /<\/style>/,
          returnEnd: !0,
          subLanguage: [
            "css",
            "xml"
          ]
        }
      },
      {
        className: "tag",
        // See the comment in the <style tag about the lookahead pattern
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: { name: "script" },
        contains: [l],
        starts: {
          end: /<\/script>/,
          returnEnd: !0,
          subLanguage: [
            "javascript",
            "handlebars",
            "xml"
          ]
        }
      },
      // we need this for now for jSX
      {
        className: "tag",
        begin: /<>|<\/>/
      },
      // open tag
      {
        className: "tag",
        begin: e.concat(
          /</,
          e.lookahead(e.concat(
            t,
            // <tag/>
            // <tag>
            // <tag ...
            e.either(/\/>/, />/, /\s/)
          ))
        ),
        end: /\/?>/,
        contains: [
          {
            className: "name",
            begin: t,
            relevance: 0,
            starts: l
          }
        ]
      },
      // close tag
      {
        className: "tag",
        begin: e.concat(
          /<\//,
          e.lookahead(e.concat(
            t,
            />/
          ))
        ),
        contains: [
          {
            className: "name",
            begin: t,
            relevance: 0
          },
          {
            begin: />/,
            relevance: 0,
            endsParent: !0
          }
        ]
      }
    ]
  };
}
const un = (n, e) => {
  const t = n.__vccOpts || n;
  for (const [r, o] of e)
    t[r] = o;
  return t;
}, Gs = {}, js = { class: "chat-button" };
function Zs(n, e) {
  return S(), P("button", js, [
    Ae(n.$slots, "default")
  ]);
}
const Ks = /* @__PURE__ */ un(Gs, [["render", Zs]]), Ws = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Ys = /* @__PURE__ */ G("path", {
  fill: "currentColor",
  d: "M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12z"
}, null, -1), Js = [
  Ys
];
function Xs(n, e) {
  return S(), P("svg", Ws, [...Js]);
}
const Qs = { name: "mdi-close", render: Xs };
function Yn() {
  return cr(fr);
}
function Ge() {
  return {
    options: cr(pr)
  };
}
function fn() {
  const { options: n } = Ge(), e = (n == null ? void 0 : n.defaultLanguage) ?? "en";
  function t(o) {
    var i, c;
    const s = (c = (i = n == null ? void 0 : n.i18n) == null ? void 0 : i[e]) == null ? void 0 : c[o];
    return _o(s) ? s.value : s ?? o;
  }
  function r(o) {
    var s, i;
    return !!((i = (s = n == null ? void 0 : n.i18n) == null ? void 0 : s[e]) != null && i[o]);
  }
  return { t, te: r };
}
const ec = { class: "chat-get-started" }, nc = /* @__PURE__ */ ae({
  __name: "GetStarted",
  setup(n) {
    const { t: e } = fn();
    return (t, r) => (S(), P("div", ec, [
      de(Ks, {
        onClick: r[0] || (r[0] = (o) => t.$emit("click:button"))
      }, {
        default: xe(() => [
          ir(ze(B(e)("getStarted")), 1)
        ]),
        _: 1
      })
    ]));
  }
}), tc = {}, rc = { class: "chat-powered-by" }, oc = /* @__PURE__ */ G("a", { href: "https://n8n.io?utm_source=n8n-external&utm_medium=widget-powered-by" }, "n8n", -1);
function sc(n, e) {
  return S(), P("div", rc, [
    ir(" Powered by "),
    oc
  ]);
}
const cc = /* @__PURE__ */ un(tc, [["render", sc]]), ic = { class: "chat-get-started-footer" }, ac = { key: 0 }, lc = /* @__PURE__ */ ae({
  __name: "GetStartedFooter",
  setup(n) {
    const { t: e, te: t } = fn();
    return (r, o) => (S(), P("div", ic, [
      B(t)("footer") ? (S(), P("div", ac, ze(B(e)("footer")), 1)) : se("", !0),
      de(cc)
    ]));
  }
});
function uc(n) {
  return bo() ? (vo(n), !0) : !1;
}
function fc() {
  const n = /* @__PURE__ */ new Set(), e = (o) => {
    n.delete(o);
  };
  return {
    on: (o) => {
      n.add(o);
      const s = () => e(o);
      return uc(s), {
        off: s
      };
    },
    off: e,
    trigger: (...o) => Promise.all(Array.from(n).map((s) => s(...o)))
  };
}
const pc = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const hc = (n, e) => Object.prototype.hasOwnProperty.call(n, e), dc = pc ? window.document : void 0, gc = {
  multiple: !0,
  accept: "*",
  reset: !1,
  directory: !1
};
function mc(n = {}) {
  const {
    document: e = dc
  } = n, t = ee(null), { on: r, trigger: o } = fc();
  let s;
  e && (s = e.createElement("input"), s.type = "file", s.onchange = (a) => {
    const l = a.target;
    t.value = l.files, o(t.value);
  });
  const i = () => {
    t.value = null, s && s.value && (s.value = "", o(null));
  }, c = (a) => {
    if (!s)
      return;
    const l = {
      ...gc,
      ...n,
      ...a
    };
    s.multiple = l.multiple, s.accept = l.accept, s.webkitdirectory = l.directory, hc(l, "capture") && (s.capture = l.capture), l.reset && i(), s.click();
  };
  return {
    files: ko(t),
    open: c,
    reset: i,
    onChange: r
  };
}
const _c = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, bc = /* @__PURE__ */ G("path", {
  fill: "currentColor",
  d: "M14 2H6c-1.11 0-2 .89-2 2v16c0 1.11.89 2 2 2h7.81c-.53-.91-.81-1.95-.81-3c0-3.31 2.69-6 6-6c.34 0 .67.03 1 .08V8zm-1 7V3.5L18.5 9zm10 11h-3v3h-2v-3h-3v-2h3v-3h2v3h3z"
}, null, -1), vc = [
  bc
];
function kc(n, e) {
  return S(), P("svg", _c, [...vc]);
}
const xc = { name: "mdi-filePlus", render: kc }, yc = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Ec = /* @__PURE__ */ G("path", {
  fill: "currentColor",
  d: "m2 21l21-9L2 3v7l15 2l-15 2z"
}, null, -1), wc = [
  Ec
];
function Ac(n, e) {
  return S(), P("svg", yc, [...wc]);
}
const Cc = { name: "mdi-send", render: Ac }, Sc = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Dc = /* @__PURE__ */ G("path", {
  fill: "currentColor",
  d: "M20 6.91L17.09 4L12 9.09L6.91 4L4 6.91L9.09 12L4 17.09L6.91 20L12 14.91L17.09 20L20 17.09L14.91 12z"
}, null, -1), Tc = [
  Dc
];
function Rc(n, e) {
  return S(), P("svg", Sc, [...Tc]);
}
const Lc = { name: "mdi-closeThick", render: Rc }, Nc = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, qc = /* @__PURE__ */ G("path", {
  fill: "currentColor",
  d: "M13 9h5.5L13 3.5zM6 2h8l6 6v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V4c0-1.11.89-2 2-2m0 18h12v-8l-4 4l-2-2zM8 9a2 2 0 0 0-2 2a2 2 0 0 0 2 2a2 2 0 0 0 2-2a2 2 0 0 0-2-2"
}, null, -1), Mc = [
  qc
];
function Ic(n, e) {
  return S(), P("svg", Nc, [...Mc]);
}
const Oc = { name: "mdi-fileImage", render: Ic }, Fc = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Bc = /* @__PURE__ */ G("path", {
  fill: "currentColor",
  d: "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8zm-1 11h-2v5a2 2 0 0 1-2 2a2 2 0 0 1-2-2a2 2 0 0 1 2-2c.4 0 .7.1 1 .3V11h3zm0-4V3.5L18.5 9z"
}, null, -1), Pc = [
  Bc
];
function $c(n, e) {
  return S(), P("svg", Fc, [...Pc]);
}
const zc = { name: "mdi-fileMusic", render: $c }, Uc = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Hc = /* @__PURE__ */ G("path", {
  fill: "currentColor",
  d: "M13 9h5.5L13 3.5zM6 2h8l6 6v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V4c0-1.11.89-2 2-2m9 16v-2H6v2zm3-4v-2H6v2z"
}, null, -1), Vc = [
  Hc
];
function Gc(n, e) {
  return S(), P("svg", Uc, [...Vc]);
}
const Et = { name: "mdi-fileText", render: Gc }, jc = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Zc = /* @__PURE__ */ G("path", {
  fill: "currentColor",
  d: "M13 9h5.5L13 3.5zM6 2h8l6 6v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V4c0-1.11.89-2 2-2m11 17v-6l-3 2.2V13H7v6h7v-2.2z"
}, null, -1), Kc = [
  Zc
];
function Wc(n, e) {
  return S(), P("svg", jc, [...Kc]);
}
const Yc = { name: "mdi-fileVideo", render: Wc }, Jc = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Xc = /* @__PURE__ */ G("path", {
  fill: "currentColor",
  d: "M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"
}, null, -1), Qc = [
  Xc
];
function ei(n, e) {
  return S(), P("svg", Jc, [...Qc]);
}
const ni = { name: "mdi-openInNew", render: ei }, ti = { class: "chat-file-name" }, ri = /* @__PURE__ */ ae({
  __name: "ChatFile",
  props: {
    file: {},
    isRemovable: { type: Boolean },
    isPreviewable: { type: Boolean }
  },
  emits: ["remove"],
  setup(n, { emit: e }) {
    const t = n, r = e, o = {
      document: Et,
      audio: zc,
      image: Oc,
      video: Yc
    }, s = te(() => {
      var a;
      const c = (a = t.file) == null ? void 0 : a.type.split("/")[0];
      return o[c] || Et;
    });
    function i() {
      t.isRemovable && r("remove", t.file), t.isPreviewable && window.open(URL.createObjectURL(t.file));
    }
    return (c, a) => (S(), P("div", {
      class: "chat-file",
      onClick: i
    }, [
      de(B(s)),
      G("p", ti, ze(c.file.name), 1),
      c.isRemovable ? (S(), Y(B(Lc), {
        key: 0,
        class: "chat-file-delete"
      })) : se("", !0),
      c.isPreviewable ? (S(), Y(B(ni), {
        key: 1,
        class: "chat-file-preview"
      })) : se("", !0)
    ]));
  }
}), Nr = /* @__PURE__ */ un(ri, [["__scopeId", "data-v-c15a8ecf"]]), oi = { class: "chat-inputs" }, si = ["disabled", "placeholder"], ci = { class: "chat-inputs-controls" }, ii = ["disabled"], ai = ["disabled"], li = {
  key: 0,
  class: "chat-files"
}, ui = /* @__PURE__ */ ae({
  __name: "Input",
  emits: ["arrowKeyDown"],
  setup(n, { emit: e }) {
    const t = e, { options: r } = Ge(), o = Yn(), { waitingForResponse: s } = o, { t: i } = fn(), c = ee(null), a = ee(null), l = ee(""), u = ee(!1), p = te(() => {
      var q;
      return l.value === "" || s.value || ((q = r.disabled) == null ? void 0 : q.value) === !0;
    }), f = te(() => {
      var q;
      return ((q = r.disabled) == null ? void 0 : q.value) === !0;
    }), h = te(
      () => {
        var q;
        return d.value && s.value && !((q = r.disabled) != null && q.value);
      }
    ), d = te(() => B(r.allowFileUploads) === !0), g = te(() => B(r.allowedFilesMimeTypes)), E = te(() => ({
      "--controls-count": d.value ? 2 : 1
    })), {
      open: x,
      reset: b,
      onChange: A
    } = mc({
      multiple: !0,
      reset: !1
    });
    A((q) => {
      if (!q)
        return;
      const Z = new DataTransfer();
      if (c.value)
        for (let _ = 0; _ < c.value.length; _++)
          Z.items.add(c.value[_]);
      for (let _ = 0; _ < q.length; _++)
        Z.items.add(q[_]);
      c.value = Z.files;
    }), qe(() => {
      re.on("focusInput", L), re.on("blurInput", D), re.on("setInputValue", v);
    }), xo(() => {
      re.off("focusInput", L), re.off("blurInput", D), re.off("setInputValue", v);
    });
    function D() {
      a.value && a.value.blur();
    }
    function L() {
      a.value && a.value.focus();
    }
    function v(q) {
      l.value = q, L();
    }
    async function O(q) {
      if (q.preventDefault(), p.value)
        return;
      const Z = l.value;
      l.value = "", u.value = !0, await o.sendMessage(Z, Array.from(c.value ?? [])), u.value = !1, b(), c.value = null;
    }
    async function z(q) {
      q.shiftKey || await O(q);
    }
    function j(q) {
      if (!c.value)
        return;
      const Z = new DataTransfer();
      for (let _ = 0; _ < c.value.length; _++) {
        const T = c.value[_];
        q.name !== T.name && Z.items.add(T);
      }
      b(), c.value = Z.files;
    }
    function M(q) {
      (q.key === "ArrowUp" || q.key === "ArrowDown") && (q.preventDefault(), t("arrowKeyDown", {
        key: q.key,
        currentInputValue: l.value
      }));
    }
    function K() {
      h.value || x({ accept: B(g) });
    }
    return (q, Z) => {
      var _;
      return S(), P("div", {
        class: "chat-input",
        style: yo(E.value),
        onKeydown: Eo(M, ["stop"])
      }, [
        G("div", oi, [
          ar(G("textarea", {
            ref_key: "chatTextArea",
            ref: a,
            "onUpdate:modelValue": Z[0] || (Z[0] = (T) => l.value = T),
            disabled: f.value,
            placeholder: B(i)("inputPlaceholder"),
            onKeydown: wo(z, ["enter"])
          }, null, 40, si), [
            [Ao, l.value]
          ]),
          G("div", ci, [
            d.value ? (S(), P("button", {
              key: 0,
              disabled: h.value,
              class: "chat-input-send-button",
              onClick: K
            }, [
              de(B(xc), {
                height: "24",
                width: "24"
              })
            ], 8, ii)) : se("", !0),
            G("button", {
              disabled: p.value,
              class: "chat-input-send-button",
              onClick: O
            }, [
              de(B(Cc), {
                height: "24",
                width: "24"
              })
            ], 8, ai)
          ])
        ]),
        (_ = c.value) != null && _.length && !u.value ? (S(), P("div", li, [
          (S(!0), P(tn, null, rn(c.value, (T) => (S(), Y(Nr, {
            key: T.name,
            file: T,
            "is-removable": !0,
            onRemove: j
          }, null, 8, ["file"]))), 128))
        ])) : se("", !0)
      ], 36);
    };
  }
}), fi = /* @__PURE__ */ un(ui, [["__scopeId", "data-v-2a7fb1c3"]]), pi = { class: "chat-layout" }, hi = {
  key: 0,
  class: "chat-header"
}, di = {
  key: 2,
  class: "chat-footer"
}, gi = /* @__PURE__ */ ae({
  __name: "Layout",
  setup(n) {
    const e = ee(null);
    function t() {
      const r = e.value;
      r && (r.scrollTop = r.scrollHeight);
    }
    return qe(() => {
      re.on("scrollToBottom", t), window.addEventListener("resize", t);
    }), Co(() => {
      re.off("scrollToBottom", t), window.removeEventListener("resize", t);
    }), (r, o) => (S(), P("main", pi, [
      r.$slots.header ? (S(), P("div", hi, [
        Ae(r.$slots, "header")
      ])) : se("", !0),
      r.$slots.default ? (S(), P("div", {
        key: 1,
        ref_key: "chatBodyRef",
        ref: e,
        class: "chat-body"
      }, [
        Ae(r.$slots, "default")
      ], 512)) : se("", !0),
      r.$slots.footer ? (S(), P("div", di, [
        Ae(r.$slots, "footer")
      ])) : se("", !0)
    ]));
  }
});
function mi(n) {
  const e = n.regex, t = {}, r = {
    begin: /\$\{/,
    end: /\}/,
    contains: [
      "self",
      {
        begin: /:-/,
        contains: [t]
      }
      // default values
    ]
  };
  Object.assign(t, {
    className: "variable",
    variants: [
      { begin: e.concat(
        /\$[\w\d#@][\w\d_]*/,
        // negative look-ahead tries to avoid matching patterns that are not
        // Perl at all like $ident$, @ident@, etc.
        "(?![\\w\\d])(?![$])"
      ) },
      r
    ]
  });
  const o = {
    className: "subst",
    begin: /\$\(/,
    end: /\)/,
    contains: [n.BACKSLASH_ESCAPE]
  }, s = {
    begin: /<<-?\s*(?=\w+)/,
    starts: { contains: [
      n.END_SAME_AS_BEGIN({
        begin: /(\w+)/,
        end: /(\w+)/,
        className: "string"
      })
    ] }
  }, i = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      n.BACKSLASH_ESCAPE,
      t,
      o
    ]
  };
  o.contains.push(i);
  const c = {
    match: /\\"/
  }, a = {
    className: "string",
    begin: /'/,
    end: /'/
  }, l = {
    match: /\\'/
  }, u = {
    begin: /\$?\(\(/,
    end: /\)\)/,
    contains: [
      {
        begin: /\d+#[0-9a-f]+/,
        className: "number"
      },
      n.NUMBER_MODE,
      t
    ]
  }, p = [
    "fish",
    "bash",
    "zsh",
    "sh",
    "csh",
    "ksh",
    "tcsh",
    "dash",
    "scsh"
  ], f = n.SHEBANG({
    binary: `(${p.join("|")})`,
    relevance: 10
  }), h = {
    className: "function",
    begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
    returnBegin: !0,
    contains: [n.inherit(n.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
    relevance: 0
  }, d = [
    "if",
    "then",
    "else",
    "elif",
    "fi",
    "for",
    "while",
    "until",
    "in",
    "do",
    "done",
    "case",
    "esac",
    "function",
    "select"
  ], g = [
    "true",
    "false"
  ], E = { match: /(\/[a-z._-]+)+/ }, x = [
    "break",
    "cd",
    "continue",
    "eval",
    "exec",
    "exit",
    "export",
    "getopts",
    "hash",
    "pwd",
    "readonly",
    "return",
    "shift",
    "test",
    "times",
    "trap",
    "umask",
    "unset"
  ], b = [
    "alias",
    "bind",
    "builtin",
    "caller",
    "command",
    "declare",
    "echo",
    "enable",
    "help",
    "let",
    "local",
    "logout",
    "mapfile",
    "printf",
    "read",
    "readarray",
    "source",
    "type",
    "typeset",
    "ulimit",
    "unalias"
  ], A = [
    "autoload",
    "bg",
    "bindkey",
    "bye",
    "cap",
    "chdir",
    "clone",
    "comparguments",
    "compcall",
    "compctl",
    "compdescribe",
    "compfiles",
    "compgroups",
    "compquote",
    "comptags",
    "comptry",
    "compvalues",
    "dirs",
    "disable",
    "disown",
    "echotc",
    "echoti",
    "emulate",
    "fc",
    "fg",
    "float",
    "functions",
    "getcap",
    "getln",
    "history",
    "integer",
    "jobs",
    "kill",
    "limit",
    "log",
    "noglob",
    "popd",
    "print",
    "pushd",
    "pushln",
    "rehash",
    "sched",
    "setcap",
    "setopt",
    "stat",
    "suspend",
    "ttyctl",
    "unfunction",
    "unhash",
    "unlimit",
    "unsetopt",
    "vared",
    "wait",
    "whence",
    "where",
    "which",
    "zcompile",
    "zformat",
    "zftp",
    "zle",
    "zmodload",
    "zparseopts",
    "zprof",
    "zpty",
    "zregexparse",
    "zsocket",
    "zstyle",
    "ztcp"
  ], D = [
    "chcon",
    "chgrp",
    "chown",
    "chmod",
    "cp",
    "dd",
    "df",
    "dir",
    "dircolors",
    "ln",
    "ls",
    "mkdir",
    "mkfifo",
    "mknod",
    "mktemp",
    "mv",
    "realpath",
    "rm",
    "rmdir",
    "shred",
    "sync",
    "touch",
    "truncate",
    "vdir",
    "b2sum",
    "base32",
    "base64",
    "cat",
    "cksum",
    "comm",
    "csplit",
    "cut",
    "expand",
    "fmt",
    "fold",
    "head",
    "join",
    "md5sum",
    "nl",
    "numfmt",
    "od",
    "paste",
    "ptx",
    "pr",
    "sha1sum",
    "sha224sum",
    "sha256sum",
    "sha384sum",
    "sha512sum",
    "shuf",
    "sort",
    "split",
    "sum",
    "tac",
    "tail",
    "tr",
    "tsort",
    "unexpand",
    "uniq",
    "wc",
    "arch",
    "basename",
    "chroot",
    "date",
    "dirname",
    "du",
    "echo",
    "env",
    "expr",
    "factor",
    // "false", // keyword literal already
    "groups",
    "hostid",
    "id",
    "link",
    "logname",
    "nice",
    "nohup",
    "nproc",
    "pathchk",
    "pinky",
    "printenv",
    "printf",
    "pwd",
    "readlink",
    "runcon",
    "seq",
    "sleep",
    "stat",
    "stdbuf",
    "stty",
    "tee",
    "test",
    "timeout",
    // "true", // keyword literal already
    "tty",
    "uname",
    "unlink",
    "uptime",
    "users",
    "who",
    "whoami",
    "yes"
  ];
  return {
    name: "Bash",
    aliases: ["sh"],
    keywords: {
      $pattern: /\b[a-z][a-z0-9._-]+\b/,
      keyword: d,
      literal: g,
      built_in: [
        ...x,
        ...b,
        // Shell modifiers
        "set",
        "shopt",
        ...A,
        ...D
      ]
    },
    contains: [
      f,
      // to catch known shells and boost relevancy
      n.SHEBANG(),
      // to catch unknown shells but still highlight the shebang
      h,
      u,
      n.HASH_COMMENT_MODE,
      s,
      E,
      i,
      c,
      a,
      l,
      t
    ]
  };
}
function _i(n) {
  const e = n.regex, t = new RegExp("[\\p{XID_Start}_]\\p{XID_Continue}*", "u"), r = [
    "and",
    "as",
    "assert",
    "async",
    "await",
    "break",
    "case",
    "class",
    "continue",
    "def",
    "del",
    "elif",
    "else",
    "except",
    "finally",
    "for",
    "from",
    "global",
    "if",
    "import",
    "in",
    "is",
    "lambda",
    "match",
    "nonlocal|10",
    "not",
    "or",
    "pass",
    "raise",
    "return",
    "try",
    "while",
    "with",
    "yield"
  ], c = {
    $pattern: /[A-Za-z]\w+|__\w+__/,
    keyword: r,
    built_in: [
      "__import__",
      "abs",
      "all",
      "any",
      "ascii",
      "bin",
      "bool",
      "breakpoint",
      "bytearray",
      "bytes",
      "callable",
      "chr",
      "classmethod",
      "compile",
      "complex",
      "delattr",
      "dict",
      "dir",
      "divmod",
      "enumerate",
      "eval",
      "exec",
      "filter",
      "float",
      "format",
      "frozenset",
      "getattr",
      "globals",
      "hasattr",
      "hash",
      "help",
      "hex",
      "id",
      "input",
      "int",
      "isinstance",
      "issubclass",
      "iter",
      "len",
      "list",
      "locals",
      "map",
      "max",
      "memoryview",
      "min",
      "next",
      "object",
      "oct",
      "open",
      "ord",
      "pow",
      "print",
      "property",
      "range",
      "repr",
      "reversed",
      "round",
      "set",
      "setattr",
      "slice",
      "sorted",
      "staticmethod",
      "str",
      "sum",
      "super",
      "tuple",
      "type",
      "vars",
      "zip"
    ],
    literal: [
      "__debug__",
      "Ellipsis",
      "False",
      "None",
      "NotImplemented",
      "True"
    ],
    type: [
      "Any",
      "Callable",
      "Coroutine",
      "Dict",
      "List",
      "Literal",
      "Generic",
      "Optional",
      "Sequence",
      "Set",
      "Tuple",
      "Type",
      "Union"
    ]
  }, a = {
    className: "meta",
    begin: /^(>>>|\.\.\.) /
  }, l = {
    className: "subst",
    begin: /\{/,
    end: /\}/,
    keywords: c,
    illegal: /#/
  }, u = {
    begin: /\{\{/,
    relevance: 0
  }, p = {
    className: "string",
    contains: [n.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
        end: /'''/,
        contains: [
          n.BACKSLASH_ESCAPE,
          a
        ],
        relevance: 10
      },
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
        end: /"""/,
        contains: [
          n.BACKSLASH_ESCAPE,
          a
        ],
        relevance: 10
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'''/,
        end: /'''/,
        contains: [
          n.BACKSLASH_ESCAPE,
          a,
          u,
          l
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"""/,
        end: /"""/,
        contains: [
          n.BACKSLASH_ESCAPE,
          a,
          u,
          l
        ]
      },
      {
        begin: /([uU]|[rR])'/,
        end: /'/,
        relevance: 10
      },
      {
        begin: /([uU]|[rR])"/,
        end: /"/,
        relevance: 10
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])'/,
        end: /'/
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])"/,
        end: /"/
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'/,
        end: /'/,
        contains: [
          n.BACKSLASH_ESCAPE,
          u,
          l
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"/,
        end: /"/,
        contains: [
          n.BACKSLASH_ESCAPE,
          u,
          l
        ]
      },
      n.APOS_STRING_MODE,
      n.QUOTE_STRING_MODE
    ]
  }, f = "[0-9](_?[0-9])*", h = `(\\b(${f}))?\\.(${f})|\\b(${f})\\.`, d = `\\b|${r.join("|")}`, g = {
    className: "number",
    relevance: 0,
    variants: [
      // exponentfloat, pointfloat
      // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals
      // optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      // Note: no leading \b because floats can start with a decimal point
      // and we don't want to mishandle e.g. `fn(.5)`,
      // no trailing \b for pointfloat because it can end with a decimal point
      // and we don't want to mishandle e.g. `0..hex()`; this should be safe
      // because both MUST contain a decimal point and so cannot be confused with
      // the interior part of an identifier
      {
        begin: `(\\b(${f})|(${h}))[eE][+-]?(${f})[jJ]?(?=${d})`
      },
      {
        begin: `(${h})[jJ]?`
      },
      // decinteger, bininteger, octinteger, hexinteger
      // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals
      // optionally "long" in Python 2
      // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals
      // decinteger is optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${d})`
      },
      {
        begin: `\\b0[bB](_?[01])+[lL]?(?=${d})`
      },
      {
        begin: `\\b0[oO](_?[0-7])+[lL]?(?=${d})`
      },
      {
        begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${d})`
      },
      // imagnumber (digitpart-based)
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b(${f})[jJ](?=${d})`
      }
    ]
  }, E = {
    className: "comment",
    begin: e.lookahead(/# type:/),
    end: /$/,
    keywords: c,
    contains: [
      {
        // prevent keywords from coloring `type`
        begin: /# type:/
      },
      // comment within a datatype comment includes no keywords
      {
        begin: /#/,
        end: /\b\B/,
        endsWithParent: !0
      }
    ]
  }, x = {
    className: "params",
    variants: [
      // Exclude params in functions without params
      {
        className: "",
        begin: /\(\s*\)/,
        skip: !0
      },
      {
        begin: /\(/,
        end: /\)/,
        excludeBegin: !0,
        excludeEnd: !0,
        keywords: c,
        contains: [
          "self",
          a,
          g,
          p,
          n.HASH_COMMENT_MODE
        ]
      }
    ]
  };
  return l.contains = [
    p,
    g,
    a
  ], {
    name: "Python",
    aliases: [
      "py",
      "gyp",
      "ipython"
    ],
    unicodeRegex: !0,
    keywords: c,
    illegal: /(<\/|\?)|=>/,
    contains: [
      a,
      g,
      {
        // very common convention
        begin: /\bself\b/
      },
      {
        // eat "if" prior to string so that it won't accidentally be
        // labeled as an f-string
        beginKeywords: "if",
        relevance: 0
      },
      p,
      E,
      n.HASH_COMMENT_MODE,
      {
        match: [
          /\bdef/,
          /\s+/,
          t
        ],
        scope: {
          1: "keyword",
          3: "title.function"
        },
        contains: [x]
      },
      {
        variants: [
          {
            match: [
              /\bclass/,
              /\s+/,
              t,
              /\s*/,
              /\(\s*/,
              t,
              /\s*\)/
            ]
          },
          {
            match: [
              /\bclass/,
              /\s+/,
              t
            ]
          }
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          6: "title.class.inherited"
        }
      },
      {
        className: "meta",
        begin: /^[\t ]*@/,
        end: /(?=#)|$/,
        contains: [
          g,
          x,
          p
        ]
      }
    ]
  };
}
const sn = "[A-Za-z$_][0-9A-Za-z$_]*", qr = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
], Mr = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
], Ir = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
], Or = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
], Fr = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
], Br = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
], Pr = [].concat(
  Fr,
  Ir,
  Or
);
function bi(n) {
  const e = n.regex, t = (k, { after: R }) => {
    const F = "</" + k[0].slice(1);
    return k.input.indexOf(F, R) !== -1;
  }, r = sn, o = {
    begin: "<>",
    end: "</>"
  }, s = /<[A-Za-z0-9\\._:-]+\s*\/>/, i = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (k, R) => {
      const F = k[0].length + k.index, U = k.input[F];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        U === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        U === ","
      ) {
        R.ignoreMatch();
        return;
      }
      U === ">" && (t(k, { after: F }) || R.ignoreMatch());
      let W;
      const ne = k.input.substring(F);
      if (W = ne.match(/^\s*=/)) {
        R.ignoreMatch();
        return;
      }
      if ((W = ne.match(/^\s+extends\s+/)) && W.index === 0) {
        R.ignoreMatch();
        return;
      }
    }
  }, c = {
    $pattern: sn,
    keyword: qr,
    literal: Mr,
    built_in: Pr,
    "variable.language": Br
  }, a = "[0-9](_?[0-9])*", l = `\\.(${a})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", p = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${u})((${l})|\\.)?|(${l}))[eE][+-]?(${a})\\b` },
      { begin: `\\b(${u})\\b((${l})\\b|\\.)?|(${l})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, f = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: c,
    contains: []
    // defined later
  }, h = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "xml"
    }
  }, d = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "css"
    }
  }, g = {
    begin: "gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "graphql"
    }
  }, E = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      n.BACKSLASH_ESCAPE,
      f
    ]
  }, b = {
    className: "comment",
    variants: [
      n.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: r + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      n.C_BLOCK_COMMENT_MODE,
      n.C_LINE_COMMENT_MODE
    ]
  }, A = [
    n.APOS_STRING_MODE,
    n.QUOTE_STRING_MODE,
    h,
    d,
    g,
    E,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    p
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  f.contains = A.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: c,
    contains: [
      "self"
    ].concat(A)
  });
  const D = [].concat(b, f.contains), L = D.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: c,
      contains: ["self"].concat(D)
    }
  ]), v = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: c,
    contains: L
  }, O = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          r,
          /\s+/,
          /extends/,
          /\s+/,
          e.concat(r, "(", e.concat(/\./, r), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          r
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, z = {
    relevance: 0,
    match: e.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...Ir,
        ...Or
      ]
    }
  }, j = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, M = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          r,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [v],
    illegal: /%/
  }, K = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function q(k) {
    return e.concat("(?!", k.join("|"), ")");
  }
  const Z = {
    match: e.concat(
      /\b/,
      q([
        ...Fr,
        "super",
        "import"
      ]),
      r,
      e.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  }, _ = {
    begin: e.concat(/\./, e.lookahead(
      e.concat(r, /(?![0-9A-Za-z$_(])/)
    )),
    end: r,
    excludeBegin: !0,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, T = {
    match: [
      /get|set/,
      /\s+/,
      r,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      v
    ]
  }, w = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + n.UNDERSCORE_IDENT_RE + ")\\s*=>", m = {
    match: [
      /const|var|let/,
      /\s+/,
      r,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      e.lookahead(w)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      v
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: c,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: L, CLASS_REFERENCE: z },
    illegal: /#(?![$_A-z])/,
    contains: [
      n.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      j,
      n.APOS_STRING_MODE,
      n.QUOTE_STRING_MODE,
      h,
      d,
      g,
      E,
      b,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      p,
      z,
      {
        className: "attr",
        begin: r + e.lookahead(":"),
        relevance: 0
      },
      m,
      {
        // "value" container
        begin: "(" + n.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          b,
          n.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: w,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: n.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: c,
                    contains: L
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: o.begin, end: o.end },
              { match: s },
              {
                begin: i.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": i.isTrulyOpeningTag,
                end: i.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: i.begin,
                end: i.end,
                skip: !0,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      M,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + n.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: !0,
        label: "func.def",
        contains: [
          v,
          n.inherit(n.TITLE_MODE, { begin: r, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      _,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + r,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [v]
      },
      Z,
      K,
      O,
      T,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function vi(n) {
  const e = bi(n), t = sn, r = [
    "any",
    "void",
    "number",
    "boolean",
    "string",
    "object",
    "never",
    "symbol",
    "bigint",
    "unknown"
  ], o = {
    beginKeywords: "namespace",
    end: /\{/,
    excludeEnd: !0,
    contains: [e.exports.CLASS_REFERENCE]
  }, s = {
    beginKeywords: "interface",
    end: /\{/,
    excludeEnd: !0,
    keywords: {
      keyword: "interface extends",
      built_in: r
    },
    contains: [e.exports.CLASS_REFERENCE]
  }, i = {
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use strict['"]/
  }, c = [
    "type",
    "namespace",
    "interface",
    "public",
    "private",
    "protected",
    "implements",
    "declare",
    "abstract",
    "readonly",
    "enum",
    "override"
  ], a = {
    $pattern: sn,
    keyword: qr.concat(c),
    literal: Mr,
    built_in: Pr.concat(r),
    "variable.language": Br
  }, l = {
    className: "meta",
    begin: "@" + t
  }, u = (f, h, d) => {
    const g = f.contains.findIndex((E) => E.label === h);
    if (g === -1)
      throw new Error("can not find mode to replace");
    f.contains.splice(g, 1, d);
  };
  Object.assign(e.keywords, a), e.exports.PARAMS_CONTAINS.push(l), e.contains = e.contains.concat([
    l,
    o,
    s
  ]), u(e, "shebang", n.SHEBANG()), u(e, "use_strict", i);
  const p = e.contains.find((f) => f.label === "func.def");
  return p.relevance = 0, Object.assign(e, {
    name: "TypeScript",
    aliases: [
      "ts",
      "tsx",
      "mts",
      "cts"
    ]
  }), e;
}
function ki(n, e) {
  var t, r, o = n.attrs[n.attrIndex("href")][1];
  for (t = 0; t < e.length; ++t) {
    if (r = e[t], typeof r.matcher == "function") {
      if (r.matcher(o, r))
        return r;
      continue;
    }
    return r;
  }
}
function xi(n, e, t) {
  Object.keys(t).forEach(function(r) {
    var o, s = t[r];
    r === "className" && (r = "class"), o = e[n].attrIndex(r), o < 0 ? e[n].attrPush([r, s]) : e[n].attrs[o][1] = s;
  });
}
function $r(n, e) {
  e ? e = Array.isArray(e) ? e : [e] : e = [], Object.freeze(e);
  var t = n.renderer.rules.link_open || this.defaultRender;
  n.renderer.rules.link_open = function(r, o, s, i, c) {
    var a = ki(r[o], e), l = a && a.attrs;
    return l && xi(o, r, l), t(r, o, s, i, c);
  };
}
$r.defaultRender = function(n, e, t, r, o) {
  return o.renderToken(n, e, t);
};
var yi = $r;
const Ei = /* @__PURE__ */ Gn(yi);
var $ = {};
const wi = "Á", Ai = "á", Ci = "Ă", Si = "ă", Di = "∾", Ti = "∿", Ri = "∾̳", Li = "Â", Ni = "â", qi = "´", Mi = "А", Ii = "а", Oi = "Æ", Fi = "æ", Bi = "⁡", Pi = "𝔄", $i = "𝔞", zi = "À", Ui = "à", Hi = "ℵ", Vi = "ℵ", Gi = "Α", ji = "α", Zi = "Ā", Ki = "ā", Wi = "⨿", Yi = "&", Ji = "&", Xi = "⩕", Qi = "⩓", ea = "∧", na = "⩜", ta = "⩘", ra = "⩚", oa = "∠", sa = "⦤", ca = "∠", ia = "⦨", aa = "⦩", la = "⦪", ua = "⦫", fa = "⦬", pa = "⦭", ha = "⦮", da = "⦯", ga = "∡", ma = "∟", _a = "⊾", ba = "⦝", va = "∢", ka = "Å", xa = "⍼", ya = "Ą", Ea = "ą", wa = "𝔸", Aa = "𝕒", Ca = "⩯", Sa = "≈", Da = "⩰", Ta = "≊", Ra = "≋", La = "'", Na = "⁡", qa = "≈", Ma = "≊", Ia = "Å", Oa = "å", Fa = "𝒜", Ba = "𝒶", Pa = "≔", $a = "*", za = "≈", Ua = "≍", Ha = "Ã", Va = "ã", Ga = "Ä", ja = "ä", Za = "∳", Ka = "⨑", Wa = "≌", Ya = "϶", Ja = "‵", Xa = "∽", Qa = "⋍", el = "∖", nl = "⫧", tl = "⊽", rl = "⌅", ol = "⌆", sl = "⌅", cl = "⎵", il = "⎶", al = "≌", ll = "Б", ul = "б", fl = "„", pl = "∵", hl = "∵", dl = "∵", gl = "⦰", ml = "϶", _l = "ℬ", bl = "ℬ", vl = "Β", kl = "β", xl = "ℶ", yl = "≬", El = "𝔅", wl = "𝔟", Al = "⋂", Cl = "◯", Sl = "⋃", Dl = "⨀", Tl = "⨁", Rl = "⨂", Ll = "⨆", Nl = "★", ql = "▽", Ml = "△", Il = "⨄", Ol = "⋁", Fl = "⋀", Bl = "⤍", Pl = "⧫", $l = "▪", zl = "▴", Ul = "▾", Hl = "◂", Vl = "▸", Gl = "␣", jl = "▒", Zl = "░", Kl = "▓", Wl = "█", Yl = "=⃥", Jl = "≡⃥", Xl = "⫭", Ql = "⌐", eu = "𝔹", nu = "𝕓", tu = "⊥", ru = "⊥", ou = "⋈", su = "⧉", cu = "┐", iu = "╕", au = "╖", lu = "╗", uu = "┌", fu = "╒", pu = "╓", hu = "╔", du = "─", gu = "═", mu = "┬", _u = "╤", bu = "╥", vu = "╦", ku = "┴", xu = "╧", yu = "╨", Eu = "╩", wu = "⊟", Au = "⊞", Cu = "⊠", Su = "┘", Du = "╛", Tu = "╜", Ru = "╝", Lu = "└", Nu = "╘", qu = "╙", Mu = "╚", Iu = "│", Ou = "║", Fu = "┼", Bu = "╪", Pu = "╫", $u = "╬", zu = "┤", Uu = "╡", Hu = "╢", Vu = "╣", Gu = "├", ju = "╞", Zu = "╟", Ku = "╠", Wu = "‵", Yu = "˘", Ju = "˘", Xu = "¦", Qu = "𝒷", ef = "ℬ", nf = "⁏", tf = "∽", rf = "⋍", of = "⧅", sf = "\\", cf = "⟈", af = "•", lf = "•", uf = "≎", ff = "⪮", pf = "≏", hf = "≎", df = "≏", gf = "Ć", mf = "ć", _f = "⩄", bf = "⩉", vf = "⩋", kf = "∩", xf = "⋒", yf = "⩇", Ef = "⩀", wf = "ⅅ", Af = "∩︀", Cf = "⁁", Sf = "ˇ", Df = "ℭ", Tf = "⩍", Rf = "Č", Lf = "č", Nf = "Ç", qf = "ç", Mf = "Ĉ", If = "ĉ", Of = "∰", Ff = "⩌", Bf = "⩐", Pf = "Ċ", $f = "ċ", zf = "¸", Uf = "¸", Hf = "⦲", Vf = "¢", Gf = "·", jf = "·", Zf = "𝔠", Kf = "ℭ", Wf = "Ч", Yf = "ч", Jf = "✓", Xf = "✓", Qf = "Χ", ep = "χ", np = "ˆ", tp = "≗", rp = "↺", op = "↻", sp = "⊛", cp = "⊚", ip = "⊝", ap = "⊙", lp = "®", up = "Ⓢ", fp = "⊖", pp = "⊕", hp = "⊗", dp = "○", gp = "⧃", mp = "≗", _p = "⨐", bp = "⫯", vp = "⧂", kp = "∲", xp = "”", yp = "’", Ep = "♣", wp = "♣", Ap = ":", Cp = "∷", Sp = "⩴", Dp = "≔", Tp = "≔", Rp = ",", Lp = "@", Np = "∁", qp = "∘", Mp = "∁", Ip = "ℂ", Op = "≅", Fp = "⩭", Bp = "≡", Pp = "∮", $p = "∯", zp = "∮", Up = "𝕔", Hp = "ℂ", Vp = "∐", Gp = "∐", jp = "©", Zp = "©", Kp = "℗", Wp = "∳", Yp = "↵", Jp = "✗", Xp = "⨯", Qp = "𝒞", eh = "𝒸", nh = "⫏", th = "⫑", rh = "⫐", oh = "⫒", sh = "⋯", ch = "⤸", ih = "⤵", ah = "⋞", lh = "⋟", uh = "↶", fh = "⤽", ph = "⩈", hh = "⩆", dh = "≍", gh = "∪", mh = "⋓", _h = "⩊", bh = "⊍", vh = "⩅", kh = "∪︀", xh = "↷", yh = "⤼", Eh = "⋞", wh = "⋟", Ah = "⋎", Ch = "⋏", Sh = "¤", Dh = "↶", Th = "↷", Rh = "⋎", Lh = "⋏", Nh = "∲", qh = "∱", Mh = "⌭", Ih = "†", Oh = "‡", Fh = "ℸ", Bh = "↓", Ph = "↡", $h = "⇓", zh = "‐", Uh = "⫤", Hh = "⊣", Vh = "⤏", Gh = "˝", jh = "Ď", Zh = "ď", Kh = "Д", Wh = "д", Yh = "‡", Jh = "⇊", Xh = "ⅅ", Qh = "ⅆ", ed = "⤑", nd = "⩷", td = "°", rd = "∇", od = "Δ", sd = "δ", cd = "⦱", id = "⥿", ad = "𝔇", ld = "𝔡", ud = "⥥", fd = "⇃", pd = "⇂", hd = "´", dd = "˙", gd = "˝", md = "`", _d = "˜", bd = "⋄", vd = "⋄", kd = "⋄", xd = "♦", yd = "♦", Ed = "¨", wd = "ⅆ", Ad = "ϝ", Cd = "⋲", Sd = "÷", Dd = "÷", Td = "⋇", Rd = "⋇", Ld = "Ђ", Nd = "ђ", qd = "⌞", Md = "⌍", Id = "$", Od = "𝔻", Fd = "𝕕", Bd = "¨", Pd = "˙", $d = "⃜", zd = "≐", Ud = "≑", Hd = "≐", Vd = "∸", Gd = "∔", jd = "⊡", Zd = "⌆", Kd = "∯", Wd = "¨", Yd = "⇓", Jd = "⇐", Xd = "⇔", Qd = "⫤", eg = "⟸", ng = "⟺", tg = "⟹", rg = "⇒", og = "⊨", sg = "⇑", cg = "⇕", ig = "∥", ag = "⤓", lg = "↓", ug = "↓", fg = "⇓", pg = "⇵", hg = "̑", dg = "⇊", gg = "⇃", mg = "⇂", _g = "⥐", bg = "⥞", vg = "⥖", kg = "↽", xg = "⥟", yg = "⥗", Eg = "⇁", wg = "↧", Ag = "⊤", Cg = "⤐", Sg = "⌟", Dg = "⌌", Tg = "𝒟", Rg = "𝒹", Lg = "Ѕ", Ng = "ѕ", qg = "⧶", Mg = "Đ", Ig = "đ", Og = "⋱", Fg = "▿", Bg = "▾", Pg = "⇵", $g = "⥯", zg = "⦦", Ug = "Џ", Hg = "џ", Vg = "⟿", Gg = "É", jg = "é", Zg = "⩮", Kg = "Ě", Wg = "ě", Yg = "Ê", Jg = "ê", Xg = "≖", Qg = "≕", em = "Э", nm = "э", tm = "⩷", rm = "Ė", om = "ė", sm = "≑", cm = "ⅇ", im = "≒", am = "𝔈", lm = "𝔢", um = "⪚", fm = "È", pm = "è", hm = "⪖", dm = "⪘", gm = "⪙", mm = "∈", _m = "⏧", bm = "ℓ", vm = "⪕", km = "⪗", xm = "Ē", ym = "ē", Em = "∅", wm = "∅", Am = "◻", Cm = "∅", Sm = "▫", Dm = " ", Tm = " ", Rm = " ", Lm = "Ŋ", Nm = "ŋ", qm = " ", Mm = "Ę", Im = "ę", Om = "𝔼", Fm = "𝕖", Bm = "⋕", Pm = "⧣", $m = "⩱", zm = "ε", Um = "Ε", Hm = "ε", Vm = "ϵ", Gm = "≖", jm = "≕", Zm = "≂", Km = "⪖", Wm = "⪕", Ym = "⩵", Jm = "=", Xm = "≂", Qm = "≟", e_ = "⇌", n_ = "≡", t_ = "⩸", r_ = "⧥", o_ = "⥱", s_ = "≓", c_ = "ℯ", i_ = "ℰ", a_ = "≐", l_ = "⩳", u_ = "≂", f_ = "Η", p_ = "η", h_ = "Ð", d_ = "ð", g_ = "Ë", m_ = "ë", __ = "€", b_ = "!", v_ = "∃", k_ = "∃", x_ = "ℰ", y_ = "ⅇ", E_ = "ⅇ", w_ = "≒", A_ = "Ф", C_ = "ф", S_ = "♀", D_ = "ﬃ", T_ = "ﬀ", R_ = "ﬄ", L_ = "𝔉", N_ = "𝔣", q_ = "ﬁ", M_ = "◼", I_ = "▪", O_ = "fj", F_ = "♭", B_ = "ﬂ", P_ = "▱", $_ = "ƒ", z_ = "𝔽", U_ = "𝕗", H_ = "∀", V_ = "∀", G_ = "⋔", j_ = "⫙", Z_ = "ℱ", K_ = "⨍", W_ = "½", Y_ = "⅓", J_ = "¼", X_ = "⅕", Q_ = "⅙", eb = "⅛", nb = "⅔", tb = "⅖", rb = "¾", ob = "⅗", sb = "⅜", cb = "⅘", ib = "⅚", ab = "⅝", lb = "⅞", ub = "⁄", fb = "⌢", pb = "𝒻", hb = "ℱ", db = "ǵ", gb = "Γ", mb = "γ", _b = "Ϝ", bb = "ϝ", vb = "⪆", kb = "Ğ", xb = "ğ", yb = "Ģ", Eb = "Ĝ", wb = "ĝ", Ab = "Г", Cb = "г", Sb = "Ġ", Db = "ġ", Tb = "≥", Rb = "≧", Lb = "⪌", Nb = "⋛", qb = "≥", Mb = "≧", Ib = "⩾", Ob = "⪩", Fb = "⩾", Bb = "⪀", Pb = "⪂", $b = "⪄", zb = "⋛︀", Ub = "⪔", Hb = "𝔊", Vb = "𝔤", Gb = "≫", jb = "⋙", Zb = "⋙", Kb = "ℷ", Wb = "Ѓ", Yb = "ѓ", Jb = "⪥", Xb = "≷", Qb = "⪒", e0 = "⪤", n0 = "⪊", t0 = "⪊", r0 = "⪈", o0 = "≩", s0 = "⪈", c0 = "≩", i0 = "⋧", a0 = "𝔾", l0 = "𝕘", u0 = "`", f0 = "≥", p0 = "⋛", h0 = "≧", d0 = "⪢", g0 = "≷", m0 = "⩾", _0 = "≳", b0 = "𝒢", v0 = "ℊ", k0 = "≳", x0 = "⪎", y0 = "⪐", E0 = "⪧", w0 = "⩺", A0 = ">", C0 = ">", S0 = "≫", D0 = "⋗", T0 = "⦕", R0 = "⩼", L0 = "⪆", N0 = "⥸", q0 = "⋗", M0 = "⋛", I0 = "⪌", O0 = "≷", F0 = "≳", B0 = "≩︀", P0 = "≩︀", $0 = "ˇ", z0 = " ", U0 = "½", H0 = "ℋ", V0 = "Ъ", G0 = "ъ", j0 = "⥈", Z0 = "↔", K0 = "⇔", W0 = "↭", Y0 = "^", J0 = "ℏ", X0 = "Ĥ", Q0 = "ĥ", ev = "♥", nv = "♥", tv = "…", rv = "⊹", ov = "𝔥", sv = "ℌ", cv = "ℋ", iv = "⤥", av = "⤦", lv = "⇿", uv = "∻", fv = "↩", pv = "↪", hv = "𝕙", dv = "ℍ", gv = "―", mv = "─", _v = "𝒽", bv = "ℋ", vv = "ℏ", kv = "Ħ", xv = "ħ", yv = "≎", Ev = "≏", wv = "⁃", Av = "‐", Cv = "Í", Sv = "í", Dv = "⁣", Tv = "Î", Rv = "î", Lv = "И", Nv = "и", qv = "İ", Mv = "Е", Iv = "е", Ov = "¡", Fv = "⇔", Bv = "𝔦", Pv = "ℑ", $v = "Ì", zv = "ì", Uv = "ⅈ", Hv = "⨌", Vv = "∭", Gv = "⧜", jv = "℩", Zv = "Ĳ", Kv = "ĳ", Wv = "Ī", Yv = "ī", Jv = "ℑ", Xv = "ⅈ", Qv = "ℐ", ek = "ℑ", nk = "ı", tk = "ℑ", rk = "⊷", ok = "Ƶ", sk = "⇒", ck = "℅", ik = "∞", ak = "⧝", lk = "ı", uk = "⊺", fk = "∫", pk = "∬", hk = "ℤ", dk = "∫", gk = "⊺", mk = "⋂", _k = "⨗", bk = "⨼", vk = "⁣", kk = "⁢", xk = "Ё", yk = "ё", Ek = "Į", wk = "į", Ak = "𝕀", Ck = "𝕚", Sk = "Ι", Dk = "ι", Tk = "⨼", Rk = "¿", Lk = "𝒾", Nk = "ℐ", qk = "∈", Mk = "⋵", Ik = "⋹", Ok = "⋴", Fk = "⋳", Bk = "∈", Pk = "⁢", $k = "Ĩ", zk = "ĩ", Uk = "І", Hk = "і", Vk = "Ï", Gk = "ï", jk = "Ĵ", Zk = "ĵ", Kk = "Й", Wk = "й", Yk = "𝔍", Jk = "𝔧", Xk = "ȷ", Qk = "𝕁", ex = "𝕛", nx = "𝒥", tx = "𝒿", rx = "Ј", ox = "ј", sx = "Є", cx = "є", ix = "Κ", ax = "κ", lx = "ϰ", ux = "Ķ", fx = "ķ", px = "К", hx = "к", dx = "𝔎", gx = "𝔨", mx = "ĸ", _x = "Х", bx = "х", vx = "Ќ", kx = "ќ", xx = "𝕂", yx = "𝕜", Ex = "𝒦", wx = "𝓀", Ax = "⇚", Cx = "Ĺ", Sx = "ĺ", Dx = "⦴", Tx = "ℒ", Rx = "Λ", Lx = "λ", Nx = "⟨", qx = "⟪", Mx = "⦑", Ix = "⟨", Ox = "⪅", Fx = "ℒ", Bx = "«", Px = "⇤", $x = "⤟", zx = "←", Ux = "↞", Hx = "⇐", Vx = "⤝", Gx = "↩", jx = "↫", Zx = "⤹", Kx = "⥳", Wx = "↢", Yx = "⤙", Jx = "⤛", Xx = "⪫", Qx = "⪭", ey = "⪭︀", ny = "⤌", ty = "⤎", ry = "❲", oy = "{", sy = "[", cy = "⦋", iy = "⦏", ay = "⦍", ly = "Ľ", uy = "ľ", fy = "Ļ", py = "ļ", hy = "⌈", dy = "{", gy = "Л", my = "л", _y = "⤶", by = "“", vy = "„", ky = "⥧", xy = "⥋", yy = "↲", Ey = "≤", wy = "≦", Ay = "⟨", Cy = "⇤", Sy = "←", Dy = "←", Ty = "⇐", Ry = "⇆", Ly = "↢", Ny = "⌈", qy = "⟦", My = "⥡", Iy = "⥙", Oy = "⇃", Fy = "⌊", By = "↽", Py = "↼", $y = "⇇", zy = "↔", Uy = "↔", Hy = "⇔", Vy = "⇆", Gy = "⇋", jy = "↭", Zy = "⥎", Ky = "↤", Wy = "⊣", Yy = "⥚", Jy = "⋋", Xy = "⧏", Qy = "⊲", eE = "⊴", nE = "⥑", tE = "⥠", rE = "⥘", oE = "↿", sE = "⥒", cE = "↼", iE = "⪋", aE = "⋚", lE = "≤", uE = "≦", fE = "⩽", pE = "⪨", hE = "⩽", dE = "⩿", gE = "⪁", mE = "⪃", _E = "⋚︀", bE = "⪓", vE = "⪅", kE = "⋖", xE = "⋚", yE = "⪋", EE = "⋚", wE = "≦", AE = "≶", CE = "≶", SE = "⪡", DE = "≲", TE = "⩽", RE = "≲", LE = "⥼", NE = "⌊", qE = "𝔏", ME = "𝔩", IE = "≶", OE = "⪑", FE = "⥢", BE = "↽", PE = "↼", $E = "⥪", zE = "▄", UE = "Љ", HE = "љ", VE = "⇇", GE = "≪", jE = "⋘", ZE = "⌞", KE = "⇚", WE = "⥫", YE = "◺", JE = "Ŀ", XE = "ŀ", QE = "⎰", ew = "⎰", nw = "⪉", tw = "⪉", rw = "⪇", ow = "≨", sw = "⪇", cw = "≨", iw = "⋦", aw = "⟬", lw = "⇽", uw = "⟦", fw = "⟵", pw = "⟵", hw = "⟸", dw = "⟷", gw = "⟷", mw = "⟺", _w = "⟼", bw = "⟶", vw = "⟶", kw = "⟹", xw = "↫", yw = "↬", Ew = "⦅", ww = "𝕃", Aw = "𝕝", Cw = "⨭", Sw = "⨴", Dw = "∗", Tw = "_", Rw = "↙", Lw = "↘", Nw = "◊", qw = "◊", Mw = "⧫", Iw = "(", Ow = "⦓", Fw = "⇆", Bw = "⌟", Pw = "⇋", $w = "⥭", zw = "‎", Uw = "⊿", Hw = "‹", Vw = "𝓁", Gw = "ℒ", jw = "↰", Zw = "↰", Kw = "≲", Ww = "⪍", Yw = "⪏", Jw = "[", Xw = "‘", Qw = "‚", e1 = "Ł", n1 = "ł", t1 = "⪦", r1 = "⩹", o1 = "<", s1 = "<", c1 = "≪", i1 = "⋖", a1 = "⋋", l1 = "⋉", u1 = "⥶", f1 = "⩻", p1 = "◃", h1 = "⊴", d1 = "◂", g1 = "⦖", m1 = "⥊", _1 = "⥦", b1 = "≨︀", v1 = "≨︀", k1 = "¯", x1 = "♂", y1 = "✠", E1 = "✠", w1 = "↦", A1 = "↦", C1 = "↧", S1 = "↤", D1 = "↥", T1 = "▮", R1 = "⨩", L1 = "М", N1 = "м", q1 = "—", M1 = "∺", I1 = "∡", O1 = " ", F1 = "ℳ", B1 = "𝔐", P1 = "𝔪", $1 = "℧", z1 = "µ", U1 = "*", H1 = "⫰", V1 = "∣", G1 = "·", j1 = "⊟", Z1 = "−", K1 = "∸", W1 = "⨪", Y1 = "∓", J1 = "⫛", X1 = "…", Q1 = "∓", eA = "⊧", nA = "𝕄", tA = "𝕞", rA = "∓", oA = "𝓂", sA = "ℳ", cA = "∾", iA = "Μ", aA = "μ", lA = "⊸", uA = "⊸", fA = "∇", pA = "Ń", hA = "ń", dA = "∠⃒", gA = "≉", mA = "⩰̸", _A = "≋̸", bA = "ŉ", vA = "≉", kA = "♮", xA = "ℕ", yA = "♮", EA = " ", wA = "≎̸", AA = "≏̸", CA = "⩃", SA = "Ň", DA = "ň", TA = "Ņ", RA = "ņ", LA = "≇", NA = "⩭̸", qA = "⩂", MA = "Н", IA = "н", OA = "–", FA = "⤤", BA = "↗", PA = "⇗", $A = "↗", zA = "≠", UA = "≐̸", HA = "​", VA = "​", GA = "​", jA = "​", ZA = "≢", KA = "⤨", WA = "≂̸", YA = "≫", JA = "≪", XA = `
`, QA = "∄", eC = "∄", nC = "𝔑", tC = "𝔫", rC = "≧̸", oC = "≱", sC = "≱", cC = "≧̸", iC = "⩾̸", aC = "⩾̸", lC = "⋙̸", uC = "≵", fC = "≫⃒", pC = "≯", hC = "≯", dC = "≫̸", gC = "↮", mC = "⇎", _C = "⫲", bC = "∋", vC = "⋼", kC = "⋺", xC = "∋", yC = "Њ", EC = "њ", wC = "↚", AC = "⇍", CC = "‥", SC = "≦̸", DC = "≰", TC = "↚", RC = "⇍", LC = "↮", NC = "⇎", qC = "≰", MC = "≦̸", IC = "⩽̸", OC = "⩽̸", FC = "≮", BC = "⋘̸", PC = "≴", $C = "≪⃒", zC = "≮", UC = "⋪", HC = "⋬", VC = "≪̸", GC = "∤", jC = "⁠", ZC = " ", KC = "𝕟", WC = "ℕ", YC = "⫬", JC = "¬", XC = "≢", QC = "≭", eS = "∦", nS = "∉", tS = "≠", rS = "≂̸", oS = "∄", sS = "≯", cS = "≱", iS = "≧̸", aS = "≫̸", lS = "≹", uS = "⩾̸", fS = "≵", pS = "≎̸", hS = "≏̸", dS = "∉", gS = "⋵̸", mS = "⋹̸", _S = "∉", bS = "⋷", vS = "⋶", kS = "⧏̸", xS = "⋪", yS = "⋬", ES = "≮", wS = "≰", AS = "≸", CS = "≪̸", SS = "⩽̸", DS = "≴", TS = "⪢̸", RS = "⪡̸", LS = "∌", NS = "∌", qS = "⋾", MS = "⋽", IS = "⊀", OS = "⪯̸", FS = "⋠", BS = "∌", PS = "⧐̸", $S = "⋫", zS = "⋭", US = "⊏̸", HS = "⋢", VS = "⊐̸", GS = "⋣", jS = "⊂⃒", ZS = "⊈", KS = "⊁", WS = "⪰̸", YS = "⋡", JS = "≿̸", XS = "⊃⃒", QS = "⊉", eD = "≁", nD = "≄", tD = "≇", rD = "≉", oD = "∤", sD = "∦", cD = "∦", iD = "⫽⃥", aD = "∂̸", lD = "⨔", uD = "⊀", fD = "⋠", pD = "⊀", hD = "⪯̸", dD = "⪯̸", gD = "⤳̸", mD = "↛", _D = "⇏", bD = "↝̸", vD = "↛", kD = "⇏", xD = "⋫", yD = "⋭", ED = "⊁", wD = "⋡", AD = "⪰̸", CD = "𝒩", SD = "𝓃", DD = "∤", TD = "∦", RD = "≁", LD = "≄", ND = "≄", qD = "∤", MD = "∦", ID = "⋢", OD = "⋣", FD = "⊄", BD = "⫅̸", PD = "⊈", $D = "⊂⃒", zD = "⊈", UD = "⫅̸", HD = "⊁", VD = "⪰̸", GD = "⊅", jD = "⫆̸", ZD = "⊉", KD = "⊃⃒", WD = "⊉", YD = "⫆̸", JD = "≹", XD = "Ñ", QD = "ñ", eT = "≸", nT = "⋪", tT = "⋬", rT = "⋫", oT = "⋭", sT = "Ν", cT = "ν", iT = "#", aT = "№", lT = " ", uT = "≍⃒", fT = "⊬", pT = "⊭", hT = "⊮", dT = "⊯", gT = "≥⃒", mT = ">⃒", _T = "⤄", bT = "⧞", vT = "⤂", kT = "≤⃒", xT = "<⃒", yT = "⊴⃒", ET = "⤃", wT = "⊵⃒", AT = "∼⃒", CT = "⤣", ST = "↖", DT = "⇖", TT = "↖", RT = "⤧", LT = "Ó", NT = "ó", qT = "⊛", MT = "Ô", IT = "ô", OT = "⊚", FT = "О", BT = "о", PT = "⊝", $T = "Ő", zT = "ő", UT = "⨸", HT = "⊙", VT = "⦼", GT = "Œ", jT = "œ", ZT = "⦿", KT = "𝔒", WT = "𝔬", YT = "˛", JT = "Ò", XT = "ò", QT = "⧁", eR = "⦵", nR = "Ω", tR = "∮", rR = "↺", oR = "⦾", sR = "⦻", cR = "‾", iR = "⧀", aR = "Ō", lR = "ō", uR = "Ω", fR = "ω", pR = "Ο", hR = "ο", dR = "⦶", gR = "⊖", mR = "𝕆", _R = "𝕠", bR = "⦷", vR = "“", kR = "‘", xR = "⦹", yR = "⊕", ER = "↻", wR = "⩔", AR = "∨", CR = "⩝", SR = "ℴ", DR = "ℴ", TR = "ª", RR = "º", LR = "⊶", NR = "⩖", qR = "⩗", MR = "⩛", IR = "Ⓢ", OR = "𝒪", FR = "ℴ", BR = "Ø", PR = "ø", $R = "⊘", zR = "Õ", UR = "õ", HR = "⨶", VR = "⨷", GR = "⊗", jR = "Ö", ZR = "ö", KR = "⌽", WR = "‾", YR = "⏞", JR = "⎴", XR = "⏜", QR = "¶", e2 = "∥", n2 = "∥", t2 = "⫳", r2 = "⫽", o2 = "∂", s2 = "∂", c2 = "П", i2 = "п", a2 = "%", l2 = ".", u2 = "‰", f2 = "⊥", p2 = "‱", h2 = "𝔓", d2 = "𝔭", g2 = "Φ", m2 = "φ", _2 = "ϕ", b2 = "ℳ", v2 = "☎", k2 = "Π", x2 = "π", y2 = "⋔", E2 = "ϖ", w2 = "ℏ", A2 = "ℎ", C2 = "ℏ", S2 = "⨣", D2 = "⊞", T2 = "⨢", R2 = "+", L2 = "∔", N2 = "⨥", q2 = "⩲", M2 = "±", I2 = "±", O2 = "⨦", F2 = "⨧", B2 = "±", P2 = "ℌ", $2 = "⨕", z2 = "𝕡", U2 = "ℙ", H2 = "£", V2 = "⪷", G2 = "⪻", j2 = "≺", Z2 = "≼", K2 = "⪷", W2 = "≺", Y2 = "≼", J2 = "≺", X2 = "⪯", Q2 = "≼", eL = "≾", nL = "⪯", tL = "⪹", rL = "⪵", oL = "⋨", sL = "⪯", cL = "⪳", iL = "≾", aL = "′", lL = "″", uL = "ℙ", fL = "⪹", pL = "⪵", hL = "⋨", dL = "∏", gL = "∏", mL = "⌮", _L = "⌒", bL = "⌓", vL = "∝", kL = "∝", xL = "∷", yL = "∝", EL = "≾", wL = "⊰", AL = "𝒫", CL = "𝓅", SL = "Ψ", DL = "ψ", TL = " ", RL = "𝔔", LL = "𝔮", NL = "⨌", qL = "𝕢", ML = "ℚ", IL = "⁗", OL = "𝒬", FL = "𝓆", BL = "ℍ", PL = "⨖", $L = "?", zL = "≟", UL = '"', HL = '"', VL = "⇛", GL = "∽̱", jL = "Ŕ", ZL = "ŕ", KL = "√", WL = "⦳", YL = "⟩", JL = "⟫", XL = "⦒", QL = "⦥", eN = "⟩", nN = "»", tN = "⥵", rN = "⇥", oN = "⤠", sN = "⤳", cN = "→", iN = "↠", aN = "⇒", lN = "⤞", uN = "↪", fN = "↬", pN = "⥅", hN = "⥴", dN = "⤖", gN = "↣", mN = "↝", _N = "⤚", bN = "⤜", vN = "∶", kN = "ℚ", xN = "⤍", yN = "⤏", EN = "⤐", wN = "❳", AN = "}", CN = "]", SN = "⦌", DN = "⦎", TN = "⦐", RN = "Ř", LN = "ř", NN = "Ŗ", qN = "ŗ", MN = "⌉", IN = "}", ON = "Р", FN = "р", BN = "⤷", PN = "⥩", $N = "”", zN = "”", UN = "↳", HN = "ℜ", VN = "ℛ", GN = "ℜ", jN = "ℝ", ZN = "ℜ", KN = "▭", WN = "®", YN = "®", JN = "∋", XN = "⇋", QN = "⥯", eq = "⥽", nq = "⌋", tq = "𝔯", rq = "ℜ", oq = "⥤", sq = "⇁", cq = "⇀", iq = "⥬", aq = "Ρ", lq = "ρ", uq = "ϱ", fq = "⟩", pq = "⇥", hq = "→", dq = "→", gq = "⇒", mq = "⇄", _q = "↣", bq = "⌉", vq = "⟧", kq = "⥝", xq = "⥕", yq = "⇂", Eq = "⌋", wq = "⇁", Aq = "⇀", Cq = "⇄", Sq = "⇌", Dq = "⇉", Tq = "↝", Rq = "↦", Lq = "⊢", Nq = "⥛", qq = "⋌", Mq = "⧐", Iq = "⊳", Oq = "⊵", Fq = "⥏", Bq = "⥜", Pq = "⥔", $q = "↾", zq = "⥓", Uq = "⇀", Hq = "˚", Vq = "≓", Gq = "⇄", jq = "⇌", Zq = "‏", Kq = "⎱", Wq = "⎱", Yq = "⫮", Jq = "⟭", Xq = "⇾", Qq = "⟧", eM = "⦆", nM = "𝕣", tM = "ℝ", rM = "⨮", oM = "⨵", sM = "⥰", cM = ")", iM = "⦔", aM = "⨒", lM = "⇉", uM = "⇛", fM = "›", pM = "𝓇", hM = "ℛ", dM = "↱", gM = "↱", mM = "]", _M = "’", bM = "’", vM = "⋌", kM = "⋊", xM = "▹", yM = "⊵", EM = "▸", wM = "⧎", AM = "⧴", CM = "⥨", SM = "℞", DM = "Ś", TM = "ś", RM = "‚", LM = "⪸", NM = "Š", qM = "š", MM = "⪼", IM = "≻", OM = "≽", FM = "⪰", BM = "⪴", PM = "Ş", $M = "ş", zM = "Ŝ", UM = "ŝ", HM = "⪺", VM = "⪶", GM = "⋩", jM = "⨓", ZM = "≿", KM = "С", WM = "с", YM = "⊡", JM = "⋅", XM = "⩦", QM = "⤥", eI = "↘", nI = "⇘", tI = "↘", rI = "§", oI = ";", sI = "⤩", cI = "∖", iI = "∖", aI = "✶", lI = "𝔖", uI = "𝔰", fI = "⌢", pI = "♯", hI = "Щ", dI = "щ", gI = "Ш", mI = "ш", _I = "↓", bI = "←", vI = "∣", kI = "∥", xI = "→", yI = "↑", EI = "­", wI = "Σ", AI = "σ", CI = "ς", SI = "ς", DI = "∼", TI = "⩪", RI = "≃", LI = "≃", NI = "⪞", qI = "⪠", MI = "⪝", II = "⪟", OI = "≆", FI = "⨤", BI = "⥲", PI = "←", $I = "∘", zI = "∖", UI = "⨳", HI = "⧤", VI = "∣", GI = "⌣", jI = "⪪", ZI = "⪬", KI = "⪬︀", WI = "Ь", YI = "ь", JI = "⌿", XI = "⧄", QI = "/", eO = "𝕊", nO = "𝕤", tO = "♠", rO = "♠", oO = "∥", sO = "⊓", cO = "⊓︀", iO = "⊔", aO = "⊔︀", lO = "√", uO = "⊏", fO = "⊑", pO = "⊏", hO = "⊑", dO = "⊐", gO = "⊒", mO = "⊐", _O = "⊒", bO = "□", vO = "□", kO = "⊓", xO = "⊏", yO = "⊑", EO = "⊐", wO = "⊒", AO = "⊔", CO = "▪", SO = "□", DO = "▪", TO = "→", RO = "𝒮", LO = "𝓈", NO = "∖", qO = "⌣", MO = "⋆", IO = "⋆", OO = "☆", FO = "★", BO = "ϵ", PO = "ϕ", $O = "¯", zO = "⊂", UO = "⋐", HO = "⪽", VO = "⫅", GO = "⊆", jO = "⫃", ZO = "⫁", KO = "⫋", WO = "⊊", YO = "⪿", JO = "⥹", XO = "⊂", QO = "⋐", eF = "⊆", nF = "⫅", tF = "⊆", rF = "⊊", oF = "⫋", sF = "⫇", cF = "⫕", iF = "⫓", aF = "⪸", lF = "≻", uF = "≽", fF = "≻", pF = "⪰", hF = "≽", dF = "≿", gF = "⪰", mF = "⪺", _F = "⪶", bF = "⋩", vF = "≿", kF = "∋", xF = "∑", yF = "∑", EF = "♪", wF = "¹", AF = "²", CF = "³", SF = "⊃", DF = "⋑", TF = "⪾", RF = "⫘", LF = "⫆", NF = "⊇", qF = "⫄", MF = "⊃", IF = "⊇", OF = "⟉", FF = "⫗", BF = "⥻", PF = "⫂", $F = "⫌", zF = "⊋", UF = "⫀", HF = "⊃", VF = "⋑", GF = "⊇", jF = "⫆", ZF = "⊋", KF = "⫌", WF = "⫈", YF = "⫔", JF = "⫖", XF = "⤦", QF = "↙", eB = "⇙", nB = "↙", tB = "⤪", rB = "ß", oB = "	", sB = "⌖", cB = "Τ", iB = "τ", aB = "⎴", lB = "Ť", uB = "ť", fB = "Ţ", pB = "ţ", hB = "Т", dB = "т", gB = "⃛", mB = "⌕", _B = "𝔗", bB = "𝔱", vB = "∴", kB = "∴", xB = "∴", yB = "Θ", EB = "θ", wB = "ϑ", AB = "ϑ", CB = "≈", SB = "∼", DB = "  ", TB = " ", RB = " ", LB = "≈", NB = "∼", qB = "Þ", MB = "þ", IB = "˜", OB = "∼", FB = "≃", BB = "≅", PB = "≈", $B = "⨱", zB = "⊠", UB = "×", HB = "⨰", VB = "∭", GB = "⤨", jB = "⌶", ZB = "⫱", KB = "⊤", WB = "𝕋", YB = "𝕥", JB = "⫚", XB = "⤩", QB = "‴", eP = "™", nP = "™", tP = "▵", rP = "▿", oP = "◃", sP = "⊴", cP = "≜", iP = "▹", aP = "⊵", lP = "◬", uP = "≜", fP = "⨺", pP = "⃛", hP = "⨹", dP = "⧍", gP = "⨻", mP = "⏢", _P = "𝒯", bP = "𝓉", vP = "Ц", kP = "ц", xP = "Ћ", yP = "ћ", EP = "Ŧ", wP = "ŧ", AP = "≬", CP = "↞", SP = "↠", DP = "Ú", TP = "ú", RP = "↑", LP = "↟", NP = "⇑", qP = "⥉", MP = "Ў", IP = "ў", OP = "Ŭ", FP = "ŭ", BP = "Û", PP = "û", $P = "У", zP = "у", UP = "⇅", HP = "Ű", VP = "ű", GP = "⥮", jP = "⥾", ZP = "𝔘", KP = "𝔲", WP = "Ù", YP = "ù", JP = "⥣", XP = "↿", QP = "↾", e$ = "▀", n$ = "⌜", t$ = "⌜", r$ = "⌏", o$ = "◸", s$ = "Ū", c$ = "ū", i$ = "¨", a$ = "_", l$ = "⏟", u$ = "⎵", f$ = "⏝", p$ = "⋃", h$ = "⊎", d$ = "Ų", g$ = "ų", m$ = "𝕌", _$ = "𝕦", b$ = "⤒", v$ = "↑", k$ = "↑", x$ = "⇑", y$ = "⇅", E$ = "↕", w$ = "↕", A$ = "⇕", C$ = "⥮", S$ = "↿", D$ = "↾", T$ = "⊎", R$ = "↖", L$ = "↗", N$ = "υ", q$ = "ϒ", M$ = "ϒ", I$ = "Υ", O$ = "υ", F$ = "↥", B$ = "⊥", P$ = "⇈", $$ = "⌝", z$ = "⌝", U$ = "⌎", H$ = "Ů", V$ = "ů", G$ = "◹", j$ = "𝒰", Z$ = "𝓊", K$ = "⋰", W$ = "Ũ", Y$ = "ũ", J$ = "▵", X$ = "▴", Q$ = "⇈", ez = "Ü", nz = "ü", tz = "⦧", rz = "⦜", oz = "ϵ", sz = "ϰ", cz = "∅", iz = "ϕ", az = "ϖ", lz = "∝", uz = "↕", fz = "⇕", pz = "ϱ", hz = "ς", dz = "⊊︀", gz = "⫋︀", mz = "⊋︀", _z = "⫌︀", bz = "ϑ", vz = "⊲", kz = "⊳", xz = "⫨", yz = "⫫", Ez = "⫩", wz = "В", Az = "в", Cz = "⊢", Sz = "⊨", Dz = "⊩", Tz = "⊫", Rz = "⫦", Lz = "⊻", Nz = "∨", qz = "⋁", Mz = "≚", Iz = "⋮", Oz = "|", Fz = "‖", Bz = "|", Pz = "‖", $z = "∣", zz = "|", Uz = "❘", Hz = "≀", Vz = " ", Gz = "𝔙", jz = "𝔳", Zz = "⊲", Kz = "⊂⃒", Wz = "⊃⃒", Yz = "𝕍", Jz = "𝕧", Xz = "∝", Qz = "⊳", e3 = "𝒱", n3 = "𝓋", t3 = "⫋︀", r3 = "⊊︀", o3 = "⫌︀", s3 = "⊋︀", c3 = "⊪", i3 = "⦚", a3 = "Ŵ", l3 = "ŵ", u3 = "⩟", f3 = "∧", p3 = "⋀", h3 = "≙", d3 = "℘", g3 = "𝔚", m3 = "𝔴", _3 = "𝕎", b3 = "𝕨", v3 = "℘", k3 = "≀", x3 = "≀", y3 = "𝒲", E3 = "𝓌", w3 = "⋂", A3 = "◯", C3 = "⋃", S3 = "▽", D3 = "𝔛", T3 = "𝔵", R3 = "⟷", L3 = "⟺", N3 = "Ξ", q3 = "ξ", M3 = "⟵", I3 = "⟸", O3 = "⟼", F3 = "⋻", B3 = "⨀", P3 = "𝕏", $3 = "𝕩", z3 = "⨁", U3 = "⨂", H3 = "⟶", V3 = "⟹", G3 = "𝒳", j3 = "𝓍", Z3 = "⨆", K3 = "⨄", W3 = "△", Y3 = "⋁", J3 = "⋀", X3 = "Ý", Q3 = "ý", eU = "Я", nU = "я", tU = "Ŷ", rU = "ŷ", oU = "Ы", sU = "ы", cU = "¥", iU = "𝔜", aU = "𝔶", lU = "Ї", uU = "ї", fU = "𝕐", pU = "𝕪", hU = "𝒴", dU = "𝓎", gU = "Ю", mU = "ю", _U = "ÿ", bU = "Ÿ", vU = "Ź", kU = "ź", xU = "Ž", yU = "ž", EU = "З", wU = "з", AU = "Ż", CU = "ż", SU = "ℨ", DU = "​", TU = "Ζ", RU = "ζ", LU = "𝔷", NU = "ℨ", qU = "Ж", MU = "ж", IU = "⇝", OU = "𝕫", FU = "ℤ", BU = "𝒵", PU = "𝓏", $U = "‍", zU = "‌", UU = {
  Aacute: wi,
  aacute: Ai,
  Abreve: Ci,
  abreve: Si,
  ac: Di,
  acd: Ti,
  acE: Ri,
  Acirc: Li,
  acirc: Ni,
  acute: qi,
  Acy: Mi,
  acy: Ii,
  AElig: Oi,
  aelig: Fi,
  af: Bi,
  Afr: Pi,
  afr: $i,
  Agrave: zi,
  agrave: Ui,
  alefsym: Hi,
  aleph: Vi,
  Alpha: Gi,
  alpha: ji,
  Amacr: Zi,
  amacr: Ki,
  amalg: Wi,
  amp: Yi,
  AMP: Ji,
  andand: Xi,
  And: Qi,
  and: ea,
  andd: na,
  andslope: ta,
  andv: ra,
  ang: oa,
  ange: sa,
  angle: ca,
  angmsdaa: ia,
  angmsdab: aa,
  angmsdac: la,
  angmsdad: ua,
  angmsdae: fa,
  angmsdaf: pa,
  angmsdag: ha,
  angmsdah: da,
  angmsd: ga,
  angrt: ma,
  angrtvb: _a,
  angrtvbd: ba,
  angsph: va,
  angst: ka,
  angzarr: xa,
  Aogon: ya,
  aogon: Ea,
  Aopf: wa,
  aopf: Aa,
  apacir: Ca,
  ap: Sa,
  apE: Da,
  ape: Ta,
  apid: Ra,
  apos: La,
  ApplyFunction: Na,
  approx: qa,
  approxeq: Ma,
  Aring: Ia,
  aring: Oa,
  Ascr: Fa,
  ascr: Ba,
  Assign: Pa,
  ast: $a,
  asymp: za,
  asympeq: Ua,
  Atilde: Ha,
  atilde: Va,
  Auml: Ga,
  auml: ja,
  awconint: Za,
  awint: Ka,
  backcong: Wa,
  backepsilon: Ya,
  backprime: Ja,
  backsim: Xa,
  backsimeq: Qa,
  Backslash: el,
  Barv: nl,
  barvee: tl,
  barwed: rl,
  Barwed: ol,
  barwedge: sl,
  bbrk: cl,
  bbrktbrk: il,
  bcong: al,
  Bcy: ll,
  bcy: ul,
  bdquo: fl,
  becaus: pl,
  because: hl,
  Because: dl,
  bemptyv: gl,
  bepsi: ml,
  bernou: _l,
  Bernoullis: bl,
  Beta: vl,
  beta: kl,
  beth: xl,
  between: yl,
  Bfr: El,
  bfr: wl,
  bigcap: Al,
  bigcirc: Cl,
  bigcup: Sl,
  bigodot: Dl,
  bigoplus: Tl,
  bigotimes: Rl,
  bigsqcup: Ll,
  bigstar: Nl,
  bigtriangledown: ql,
  bigtriangleup: Ml,
  biguplus: Il,
  bigvee: Ol,
  bigwedge: Fl,
  bkarow: Bl,
  blacklozenge: Pl,
  blacksquare: $l,
  blacktriangle: zl,
  blacktriangledown: Ul,
  blacktriangleleft: Hl,
  blacktriangleright: Vl,
  blank: Gl,
  blk12: jl,
  blk14: Zl,
  blk34: Kl,
  block: Wl,
  bne: Yl,
  bnequiv: Jl,
  bNot: Xl,
  bnot: Ql,
  Bopf: eu,
  bopf: nu,
  bot: tu,
  bottom: ru,
  bowtie: ou,
  boxbox: su,
  boxdl: cu,
  boxdL: iu,
  boxDl: au,
  boxDL: lu,
  boxdr: uu,
  boxdR: fu,
  boxDr: pu,
  boxDR: hu,
  boxh: du,
  boxH: gu,
  boxhd: mu,
  boxHd: _u,
  boxhD: bu,
  boxHD: vu,
  boxhu: ku,
  boxHu: xu,
  boxhU: yu,
  boxHU: Eu,
  boxminus: wu,
  boxplus: Au,
  boxtimes: Cu,
  boxul: Su,
  boxuL: Du,
  boxUl: Tu,
  boxUL: Ru,
  boxur: Lu,
  boxuR: Nu,
  boxUr: qu,
  boxUR: Mu,
  boxv: Iu,
  boxV: Ou,
  boxvh: Fu,
  boxvH: Bu,
  boxVh: Pu,
  boxVH: $u,
  boxvl: zu,
  boxvL: Uu,
  boxVl: Hu,
  boxVL: Vu,
  boxvr: Gu,
  boxvR: ju,
  boxVr: Zu,
  boxVR: Ku,
  bprime: Wu,
  breve: Yu,
  Breve: Ju,
  brvbar: Xu,
  bscr: Qu,
  Bscr: ef,
  bsemi: nf,
  bsim: tf,
  bsime: rf,
  bsolb: of,
  bsol: sf,
  bsolhsub: cf,
  bull: af,
  bullet: lf,
  bump: uf,
  bumpE: ff,
  bumpe: pf,
  Bumpeq: hf,
  bumpeq: df,
  Cacute: gf,
  cacute: mf,
  capand: _f,
  capbrcup: bf,
  capcap: vf,
  cap: kf,
  Cap: xf,
  capcup: yf,
  capdot: Ef,
  CapitalDifferentialD: wf,
  caps: Af,
  caret: Cf,
  caron: Sf,
  Cayleys: Df,
  ccaps: Tf,
  Ccaron: Rf,
  ccaron: Lf,
  Ccedil: Nf,
  ccedil: qf,
  Ccirc: Mf,
  ccirc: If,
  Cconint: Of,
  ccups: Ff,
  ccupssm: Bf,
  Cdot: Pf,
  cdot: $f,
  cedil: zf,
  Cedilla: Uf,
  cemptyv: Hf,
  cent: Vf,
  centerdot: Gf,
  CenterDot: jf,
  cfr: Zf,
  Cfr: Kf,
  CHcy: Wf,
  chcy: Yf,
  check: Jf,
  checkmark: Xf,
  Chi: Qf,
  chi: ep,
  circ: np,
  circeq: tp,
  circlearrowleft: rp,
  circlearrowright: op,
  circledast: sp,
  circledcirc: cp,
  circleddash: ip,
  CircleDot: ap,
  circledR: lp,
  circledS: up,
  CircleMinus: fp,
  CirclePlus: pp,
  CircleTimes: hp,
  cir: dp,
  cirE: gp,
  cire: mp,
  cirfnint: _p,
  cirmid: bp,
  cirscir: vp,
  ClockwiseContourIntegral: kp,
  CloseCurlyDoubleQuote: xp,
  CloseCurlyQuote: yp,
  clubs: Ep,
  clubsuit: wp,
  colon: Ap,
  Colon: Cp,
  Colone: Sp,
  colone: Dp,
  coloneq: Tp,
  comma: Rp,
  commat: Lp,
  comp: Np,
  compfn: qp,
  complement: Mp,
  complexes: Ip,
  cong: Op,
  congdot: Fp,
  Congruent: Bp,
  conint: Pp,
  Conint: $p,
  ContourIntegral: zp,
  copf: Up,
  Copf: Hp,
  coprod: Vp,
  Coproduct: Gp,
  copy: jp,
  COPY: Zp,
  copysr: Kp,
  CounterClockwiseContourIntegral: Wp,
  crarr: Yp,
  cross: Jp,
  Cross: Xp,
  Cscr: Qp,
  cscr: eh,
  csub: nh,
  csube: th,
  csup: rh,
  csupe: oh,
  ctdot: sh,
  cudarrl: ch,
  cudarrr: ih,
  cuepr: ah,
  cuesc: lh,
  cularr: uh,
  cularrp: fh,
  cupbrcap: ph,
  cupcap: hh,
  CupCap: dh,
  cup: gh,
  Cup: mh,
  cupcup: _h,
  cupdot: bh,
  cupor: vh,
  cups: kh,
  curarr: xh,
  curarrm: yh,
  curlyeqprec: Eh,
  curlyeqsucc: wh,
  curlyvee: Ah,
  curlywedge: Ch,
  curren: Sh,
  curvearrowleft: Dh,
  curvearrowright: Th,
  cuvee: Rh,
  cuwed: Lh,
  cwconint: Nh,
  cwint: qh,
  cylcty: Mh,
  dagger: Ih,
  Dagger: Oh,
  daleth: Fh,
  darr: Bh,
  Darr: Ph,
  dArr: $h,
  dash: zh,
  Dashv: Uh,
  dashv: Hh,
  dbkarow: Vh,
  dblac: Gh,
  Dcaron: jh,
  dcaron: Zh,
  Dcy: Kh,
  dcy: Wh,
  ddagger: Yh,
  ddarr: Jh,
  DD: Xh,
  dd: Qh,
  DDotrahd: ed,
  ddotseq: nd,
  deg: td,
  Del: rd,
  Delta: od,
  delta: sd,
  demptyv: cd,
  dfisht: id,
  Dfr: ad,
  dfr: ld,
  dHar: ud,
  dharl: fd,
  dharr: pd,
  DiacriticalAcute: hd,
  DiacriticalDot: dd,
  DiacriticalDoubleAcute: gd,
  DiacriticalGrave: md,
  DiacriticalTilde: _d,
  diam: bd,
  diamond: vd,
  Diamond: kd,
  diamondsuit: xd,
  diams: yd,
  die: Ed,
  DifferentialD: wd,
  digamma: Ad,
  disin: Cd,
  div: Sd,
  divide: Dd,
  divideontimes: Td,
  divonx: Rd,
  DJcy: Ld,
  djcy: Nd,
  dlcorn: qd,
  dlcrop: Md,
  dollar: Id,
  Dopf: Od,
  dopf: Fd,
  Dot: Bd,
  dot: Pd,
  DotDot: $d,
  doteq: zd,
  doteqdot: Ud,
  DotEqual: Hd,
  dotminus: Vd,
  dotplus: Gd,
  dotsquare: jd,
  doublebarwedge: Zd,
  DoubleContourIntegral: Kd,
  DoubleDot: Wd,
  DoubleDownArrow: Yd,
  DoubleLeftArrow: Jd,
  DoubleLeftRightArrow: Xd,
  DoubleLeftTee: Qd,
  DoubleLongLeftArrow: eg,
  DoubleLongLeftRightArrow: ng,
  DoubleLongRightArrow: tg,
  DoubleRightArrow: rg,
  DoubleRightTee: og,
  DoubleUpArrow: sg,
  DoubleUpDownArrow: cg,
  DoubleVerticalBar: ig,
  DownArrowBar: ag,
  downarrow: lg,
  DownArrow: ug,
  Downarrow: fg,
  DownArrowUpArrow: pg,
  DownBreve: hg,
  downdownarrows: dg,
  downharpoonleft: gg,
  downharpoonright: mg,
  DownLeftRightVector: _g,
  DownLeftTeeVector: bg,
  DownLeftVectorBar: vg,
  DownLeftVector: kg,
  DownRightTeeVector: xg,
  DownRightVectorBar: yg,
  DownRightVector: Eg,
  DownTeeArrow: wg,
  DownTee: Ag,
  drbkarow: Cg,
  drcorn: Sg,
  drcrop: Dg,
  Dscr: Tg,
  dscr: Rg,
  DScy: Lg,
  dscy: Ng,
  dsol: qg,
  Dstrok: Mg,
  dstrok: Ig,
  dtdot: Og,
  dtri: Fg,
  dtrif: Bg,
  duarr: Pg,
  duhar: $g,
  dwangle: zg,
  DZcy: Ug,
  dzcy: Hg,
  dzigrarr: Vg,
  Eacute: Gg,
  eacute: jg,
  easter: Zg,
  Ecaron: Kg,
  ecaron: Wg,
  Ecirc: Yg,
  ecirc: Jg,
  ecir: Xg,
  ecolon: Qg,
  Ecy: em,
  ecy: nm,
  eDDot: tm,
  Edot: rm,
  edot: om,
  eDot: sm,
  ee: cm,
  efDot: im,
  Efr: am,
  efr: lm,
  eg: um,
  Egrave: fm,
  egrave: pm,
  egs: hm,
  egsdot: dm,
  el: gm,
  Element: mm,
  elinters: _m,
  ell: bm,
  els: vm,
  elsdot: km,
  Emacr: xm,
  emacr: ym,
  empty: Em,
  emptyset: wm,
  EmptySmallSquare: Am,
  emptyv: Cm,
  EmptyVerySmallSquare: Sm,
  emsp13: Dm,
  emsp14: Tm,
  emsp: Rm,
  ENG: Lm,
  eng: Nm,
  ensp: qm,
  Eogon: Mm,
  eogon: Im,
  Eopf: Om,
  eopf: Fm,
  epar: Bm,
  eparsl: Pm,
  eplus: $m,
  epsi: zm,
  Epsilon: Um,
  epsilon: Hm,
  epsiv: Vm,
  eqcirc: Gm,
  eqcolon: jm,
  eqsim: Zm,
  eqslantgtr: Km,
  eqslantless: Wm,
  Equal: Ym,
  equals: Jm,
  EqualTilde: Xm,
  equest: Qm,
  Equilibrium: e_,
  equiv: n_,
  equivDD: t_,
  eqvparsl: r_,
  erarr: o_,
  erDot: s_,
  escr: c_,
  Escr: i_,
  esdot: a_,
  Esim: l_,
  esim: u_,
  Eta: f_,
  eta: p_,
  ETH: h_,
  eth: d_,
  Euml: g_,
  euml: m_,
  euro: __,
  excl: b_,
  exist: v_,
  Exists: k_,
  expectation: x_,
  exponentiale: y_,
  ExponentialE: E_,
  fallingdotseq: w_,
  Fcy: A_,
  fcy: C_,
  female: S_,
  ffilig: D_,
  fflig: T_,
  ffllig: R_,
  Ffr: L_,
  ffr: N_,
  filig: q_,
  FilledSmallSquare: M_,
  FilledVerySmallSquare: I_,
  fjlig: O_,
  flat: F_,
  fllig: B_,
  fltns: P_,
  fnof: $_,
  Fopf: z_,
  fopf: U_,
  forall: H_,
  ForAll: V_,
  fork: G_,
  forkv: j_,
  Fouriertrf: Z_,
  fpartint: K_,
  frac12: W_,
  frac13: Y_,
  frac14: J_,
  frac15: X_,
  frac16: Q_,
  frac18: eb,
  frac23: nb,
  frac25: tb,
  frac34: rb,
  frac35: ob,
  frac38: sb,
  frac45: cb,
  frac56: ib,
  frac58: ab,
  frac78: lb,
  frasl: ub,
  frown: fb,
  fscr: pb,
  Fscr: hb,
  gacute: db,
  Gamma: gb,
  gamma: mb,
  Gammad: _b,
  gammad: bb,
  gap: vb,
  Gbreve: kb,
  gbreve: xb,
  Gcedil: yb,
  Gcirc: Eb,
  gcirc: wb,
  Gcy: Ab,
  gcy: Cb,
  Gdot: Sb,
  gdot: Db,
  ge: Tb,
  gE: Rb,
  gEl: Lb,
  gel: Nb,
  geq: qb,
  geqq: Mb,
  geqslant: Ib,
  gescc: Ob,
  ges: Fb,
  gesdot: Bb,
  gesdoto: Pb,
  gesdotol: $b,
  gesl: zb,
  gesles: Ub,
  Gfr: Hb,
  gfr: Vb,
  gg: Gb,
  Gg: jb,
  ggg: Zb,
  gimel: Kb,
  GJcy: Wb,
  gjcy: Yb,
  gla: Jb,
  gl: Xb,
  glE: Qb,
  glj: e0,
  gnap: n0,
  gnapprox: t0,
  gne: r0,
  gnE: o0,
  gneq: s0,
  gneqq: c0,
  gnsim: i0,
  Gopf: a0,
  gopf: l0,
  grave: u0,
  GreaterEqual: f0,
  GreaterEqualLess: p0,
  GreaterFullEqual: h0,
  GreaterGreater: d0,
  GreaterLess: g0,
  GreaterSlantEqual: m0,
  GreaterTilde: _0,
  Gscr: b0,
  gscr: v0,
  gsim: k0,
  gsime: x0,
  gsiml: y0,
  gtcc: E0,
  gtcir: w0,
  gt: A0,
  GT: C0,
  Gt: S0,
  gtdot: D0,
  gtlPar: T0,
  gtquest: R0,
  gtrapprox: L0,
  gtrarr: N0,
  gtrdot: q0,
  gtreqless: M0,
  gtreqqless: I0,
  gtrless: O0,
  gtrsim: F0,
  gvertneqq: B0,
  gvnE: P0,
  Hacek: $0,
  hairsp: z0,
  half: U0,
  hamilt: H0,
  HARDcy: V0,
  hardcy: G0,
  harrcir: j0,
  harr: Z0,
  hArr: K0,
  harrw: W0,
  Hat: Y0,
  hbar: J0,
  Hcirc: X0,
  hcirc: Q0,
  hearts: ev,
  heartsuit: nv,
  hellip: tv,
  hercon: rv,
  hfr: ov,
  Hfr: sv,
  HilbertSpace: cv,
  hksearow: iv,
  hkswarow: av,
  hoarr: lv,
  homtht: uv,
  hookleftarrow: fv,
  hookrightarrow: pv,
  hopf: hv,
  Hopf: dv,
  horbar: gv,
  HorizontalLine: mv,
  hscr: _v,
  Hscr: bv,
  hslash: vv,
  Hstrok: kv,
  hstrok: xv,
  HumpDownHump: yv,
  HumpEqual: Ev,
  hybull: wv,
  hyphen: Av,
  Iacute: Cv,
  iacute: Sv,
  ic: Dv,
  Icirc: Tv,
  icirc: Rv,
  Icy: Lv,
  icy: Nv,
  Idot: qv,
  IEcy: Mv,
  iecy: Iv,
  iexcl: Ov,
  iff: Fv,
  ifr: Bv,
  Ifr: Pv,
  Igrave: $v,
  igrave: zv,
  ii: Uv,
  iiiint: Hv,
  iiint: Vv,
  iinfin: Gv,
  iiota: jv,
  IJlig: Zv,
  ijlig: Kv,
  Imacr: Wv,
  imacr: Yv,
  image: Jv,
  ImaginaryI: Xv,
  imagline: Qv,
  imagpart: ek,
  imath: nk,
  Im: tk,
  imof: rk,
  imped: ok,
  Implies: sk,
  incare: ck,
  in: "∈",
  infin: ik,
  infintie: ak,
  inodot: lk,
  intcal: uk,
  int: fk,
  Int: pk,
  integers: hk,
  Integral: dk,
  intercal: gk,
  Intersection: mk,
  intlarhk: _k,
  intprod: bk,
  InvisibleComma: vk,
  InvisibleTimes: kk,
  IOcy: xk,
  iocy: yk,
  Iogon: Ek,
  iogon: wk,
  Iopf: Ak,
  iopf: Ck,
  Iota: Sk,
  iota: Dk,
  iprod: Tk,
  iquest: Rk,
  iscr: Lk,
  Iscr: Nk,
  isin: qk,
  isindot: Mk,
  isinE: Ik,
  isins: Ok,
  isinsv: Fk,
  isinv: Bk,
  it: Pk,
  Itilde: $k,
  itilde: zk,
  Iukcy: Uk,
  iukcy: Hk,
  Iuml: Vk,
  iuml: Gk,
  Jcirc: jk,
  jcirc: Zk,
  Jcy: Kk,
  jcy: Wk,
  Jfr: Yk,
  jfr: Jk,
  jmath: Xk,
  Jopf: Qk,
  jopf: ex,
  Jscr: nx,
  jscr: tx,
  Jsercy: rx,
  jsercy: ox,
  Jukcy: sx,
  jukcy: cx,
  Kappa: ix,
  kappa: ax,
  kappav: lx,
  Kcedil: ux,
  kcedil: fx,
  Kcy: px,
  kcy: hx,
  Kfr: dx,
  kfr: gx,
  kgreen: mx,
  KHcy: _x,
  khcy: bx,
  KJcy: vx,
  kjcy: kx,
  Kopf: xx,
  kopf: yx,
  Kscr: Ex,
  kscr: wx,
  lAarr: Ax,
  Lacute: Cx,
  lacute: Sx,
  laemptyv: Dx,
  lagran: Tx,
  Lambda: Rx,
  lambda: Lx,
  lang: Nx,
  Lang: qx,
  langd: Mx,
  langle: Ix,
  lap: Ox,
  Laplacetrf: Fx,
  laquo: Bx,
  larrb: Px,
  larrbfs: $x,
  larr: zx,
  Larr: Ux,
  lArr: Hx,
  larrfs: Vx,
  larrhk: Gx,
  larrlp: jx,
  larrpl: Zx,
  larrsim: Kx,
  larrtl: Wx,
  latail: Yx,
  lAtail: Jx,
  lat: Xx,
  late: Qx,
  lates: ey,
  lbarr: ny,
  lBarr: ty,
  lbbrk: ry,
  lbrace: oy,
  lbrack: sy,
  lbrke: cy,
  lbrksld: iy,
  lbrkslu: ay,
  Lcaron: ly,
  lcaron: uy,
  Lcedil: fy,
  lcedil: py,
  lceil: hy,
  lcub: dy,
  Lcy: gy,
  lcy: my,
  ldca: _y,
  ldquo: by,
  ldquor: vy,
  ldrdhar: ky,
  ldrushar: xy,
  ldsh: yy,
  le: Ey,
  lE: wy,
  LeftAngleBracket: Ay,
  LeftArrowBar: Cy,
  leftarrow: Sy,
  LeftArrow: Dy,
  Leftarrow: Ty,
  LeftArrowRightArrow: Ry,
  leftarrowtail: Ly,
  LeftCeiling: Ny,
  LeftDoubleBracket: qy,
  LeftDownTeeVector: My,
  LeftDownVectorBar: Iy,
  LeftDownVector: Oy,
  LeftFloor: Fy,
  leftharpoondown: By,
  leftharpoonup: Py,
  leftleftarrows: $y,
  leftrightarrow: zy,
  LeftRightArrow: Uy,
  Leftrightarrow: Hy,
  leftrightarrows: Vy,
  leftrightharpoons: Gy,
  leftrightsquigarrow: jy,
  LeftRightVector: Zy,
  LeftTeeArrow: Ky,
  LeftTee: Wy,
  LeftTeeVector: Yy,
  leftthreetimes: Jy,
  LeftTriangleBar: Xy,
  LeftTriangle: Qy,
  LeftTriangleEqual: eE,
  LeftUpDownVector: nE,
  LeftUpTeeVector: tE,
  LeftUpVectorBar: rE,
  LeftUpVector: oE,
  LeftVectorBar: sE,
  LeftVector: cE,
  lEg: iE,
  leg: aE,
  leq: lE,
  leqq: uE,
  leqslant: fE,
  lescc: pE,
  les: hE,
  lesdot: dE,
  lesdoto: gE,
  lesdotor: mE,
  lesg: _E,
  lesges: bE,
  lessapprox: vE,
  lessdot: kE,
  lesseqgtr: xE,
  lesseqqgtr: yE,
  LessEqualGreater: EE,
  LessFullEqual: wE,
  LessGreater: AE,
  lessgtr: CE,
  LessLess: SE,
  lesssim: DE,
  LessSlantEqual: TE,
  LessTilde: RE,
  lfisht: LE,
  lfloor: NE,
  Lfr: qE,
  lfr: ME,
  lg: IE,
  lgE: OE,
  lHar: FE,
  lhard: BE,
  lharu: PE,
  lharul: $E,
  lhblk: zE,
  LJcy: UE,
  ljcy: HE,
  llarr: VE,
  ll: GE,
  Ll: jE,
  llcorner: ZE,
  Lleftarrow: KE,
  llhard: WE,
  lltri: YE,
  Lmidot: JE,
  lmidot: XE,
  lmoustache: QE,
  lmoust: ew,
  lnap: nw,
  lnapprox: tw,
  lne: rw,
  lnE: ow,
  lneq: sw,
  lneqq: cw,
  lnsim: iw,
  loang: aw,
  loarr: lw,
  lobrk: uw,
  longleftarrow: fw,
  LongLeftArrow: pw,
  Longleftarrow: hw,
  longleftrightarrow: dw,
  LongLeftRightArrow: gw,
  Longleftrightarrow: mw,
  longmapsto: _w,
  longrightarrow: bw,
  LongRightArrow: vw,
  Longrightarrow: kw,
  looparrowleft: xw,
  looparrowright: yw,
  lopar: Ew,
  Lopf: ww,
  lopf: Aw,
  loplus: Cw,
  lotimes: Sw,
  lowast: Dw,
  lowbar: Tw,
  LowerLeftArrow: Rw,
  LowerRightArrow: Lw,
  loz: Nw,
  lozenge: qw,
  lozf: Mw,
  lpar: Iw,
  lparlt: Ow,
  lrarr: Fw,
  lrcorner: Bw,
  lrhar: Pw,
  lrhard: $w,
  lrm: zw,
  lrtri: Uw,
  lsaquo: Hw,
  lscr: Vw,
  Lscr: Gw,
  lsh: jw,
  Lsh: Zw,
  lsim: Kw,
  lsime: Ww,
  lsimg: Yw,
  lsqb: Jw,
  lsquo: Xw,
  lsquor: Qw,
  Lstrok: e1,
  lstrok: n1,
  ltcc: t1,
  ltcir: r1,
  lt: o1,
  LT: s1,
  Lt: c1,
  ltdot: i1,
  lthree: a1,
  ltimes: l1,
  ltlarr: u1,
  ltquest: f1,
  ltri: p1,
  ltrie: h1,
  ltrif: d1,
  ltrPar: g1,
  lurdshar: m1,
  luruhar: _1,
  lvertneqq: b1,
  lvnE: v1,
  macr: k1,
  male: x1,
  malt: y1,
  maltese: E1,
  Map: "⤅",
  map: w1,
  mapsto: A1,
  mapstodown: C1,
  mapstoleft: S1,
  mapstoup: D1,
  marker: T1,
  mcomma: R1,
  Mcy: L1,
  mcy: N1,
  mdash: q1,
  mDDot: M1,
  measuredangle: I1,
  MediumSpace: O1,
  Mellintrf: F1,
  Mfr: B1,
  mfr: P1,
  mho: $1,
  micro: z1,
  midast: U1,
  midcir: H1,
  mid: V1,
  middot: G1,
  minusb: j1,
  minus: Z1,
  minusd: K1,
  minusdu: W1,
  MinusPlus: Y1,
  mlcp: J1,
  mldr: X1,
  mnplus: Q1,
  models: eA,
  Mopf: nA,
  mopf: tA,
  mp: rA,
  mscr: oA,
  Mscr: sA,
  mstpos: cA,
  Mu: iA,
  mu: aA,
  multimap: lA,
  mumap: uA,
  nabla: fA,
  Nacute: pA,
  nacute: hA,
  nang: dA,
  nap: gA,
  napE: mA,
  napid: _A,
  napos: bA,
  napprox: vA,
  natural: kA,
  naturals: xA,
  natur: yA,
  nbsp: EA,
  nbump: wA,
  nbumpe: AA,
  ncap: CA,
  Ncaron: SA,
  ncaron: DA,
  Ncedil: TA,
  ncedil: RA,
  ncong: LA,
  ncongdot: NA,
  ncup: qA,
  Ncy: MA,
  ncy: IA,
  ndash: OA,
  nearhk: FA,
  nearr: BA,
  neArr: PA,
  nearrow: $A,
  ne: zA,
  nedot: UA,
  NegativeMediumSpace: HA,
  NegativeThickSpace: VA,
  NegativeThinSpace: GA,
  NegativeVeryThinSpace: jA,
  nequiv: ZA,
  nesear: KA,
  nesim: WA,
  NestedGreaterGreater: YA,
  NestedLessLess: JA,
  NewLine: XA,
  nexist: QA,
  nexists: eC,
  Nfr: nC,
  nfr: tC,
  ngE: rC,
  nge: oC,
  ngeq: sC,
  ngeqq: cC,
  ngeqslant: iC,
  nges: aC,
  nGg: lC,
  ngsim: uC,
  nGt: fC,
  ngt: pC,
  ngtr: hC,
  nGtv: dC,
  nharr: gC,
  nhArr: mC,
  nhpar: _C,
  ni: bC,
  nis: vC,
  nisd: kC,
  niv: xC,
  NJcy: yC,
  njcy: EC,
  nlarr: wC,
  nlArr: AC,
  nldr: CC,
  nlE: SC,
  nle: DC,
  nleftarrow: TC,
  nLeftarrow: RC,
  nleftrightarrow: LC,
  nLeftrightarrow: NC,
  nleq: qC,
  nleqq: MC,
  nleqslant: IC,
  nles: OC,
  nless: FC,
  nLl: BC,
  nlsim: PC,
  nLt: $C,
  nlt: zC,
  nltri: UC,
  nltrie: HC,
  nLtv: VC,
  nmid: GC,
  NoBreak: jC,
  NonBreakingSpace: ZC,
  nopf: KC,
  Nopf: WC,
  Not: YC,
  not: JC,
  NotCongruent: XC,
  NotCupCap: QC,
  NotDoubleVerticalBar: eS,
  NotElement: nS,
  NotEqual: tS,
  NotEqualTilde: rS,
  NotExists: oS,
  NotGreater: sS,
  NotGreaterEqual: cS,
  NotGreaterFullEqual: iS,
  NotGreaterGreater: aS,
  NotGreaterLess: lS,
  NotGreaterSlantEqual: uS,
  NotGreaterTilde: fS,
  NotHumpDownHump: pS,
  NotHumpEqual: hS,
  notin: dS,
  notindot: gS,
  notinE: mS,
  notinva: _S,
  notinvb: bS,
  notinvc: vS,
  NotLeftTriangleBar: kS,
  NotLeftTriangle: xS,
  NotLeftTriangleEqual: yS,
  NotLess: ES,
  NotLessEqual: wS,
  NotLessGreater: AS,
  NotLessLess: CS,
  NotLessSlantEqual: SS,
  NotLessTilde: DS,
  NotNestedGreaterGreater: TS,
  NotNestedLessLess: RS,
  notni: LS,
  notniva: NS,
  notnivb: qS,
  notnivc: MS,
  NotPrecedes: IS,
  NotPrecedesEqual: OS,
  NotPrecedesSlantEqual: FS,
  NotReverseElement: BS,
  NotRightTriangleBar: PS,
  NotRightTriangle: $S,
  NotRightTriangleEqual: zS,
  NotSquareSubset: US,
  NotSquareSubsetEqual: HS,
  NotSquareSuperset: VS,
  NotSquareSupersetEqual: GS,
  NotSubset: jS,
  NotSubsetEqual: ZS,
  NotSucceeds: KS,
  NotSucceedsEqual: WS,
  NotSucceedsSlantEqual: YS,
  NotSucceedsTilde: JS,
  NotSuperset: XS,
  NotSupersetEqual: QS,
  NotTilde: eD,
  NotTildeEqual: nD,
  NotTildeFullEqual: tD,
  NotTildeTilde: rD,
  NotVerticalBar: oD,
  nparallel: sD,
  npar: cD,
  nparsl: iD,
  npart: aD,
  npolint: lD,
  npr: uD,
  nprcue: fD,
  nprec: pD,
  npreceq: hD,
  npre: dD,
  nrarrc: gD,
  nrarr: mD,
  nrArr: _D,
  nrarrw: bD,
  nrightarrow: vD,
  nRightarrow: kD,
  nrtri: xD,
  nrtrie: yD,
  nsc: ED,
  nsccue: wD,
  nsce: AD,
  Nscr: CD,
  nscr: SD,
  nshortmid: DD,
  nshortparallel: TD,
  nsim: RD,
  nsime: LD,
  nsimeq: ND,
  nsmid: qD,
  nspar: MD,
  nsqsube: ID,
  nsqsupe: OD,
  nsub: FD,
  nsubE: BD,
  nsube: PD,
  nsubset: $D,
  nsubseteq: zD,
  nsubseteqq: UD,
  nsucc: HD,
  nsucceq: VD,
  nsup: GD,
  nsupE: jD,
  nsupe: ZD,
  nsupset: KD,
  nsupseteq: WD,
  nsupseteqq: YD,
  ntgl: JD,
  Ntilde: XD,
  ntilde: QD,
  ntlg: eT,
  ntriangleleft: nT,
  ntrianglelefteq: tT,
  ntriangleright: rT,
  ntrianglerighteq: oT,
  Nu: sT,
  nu: cT,
  num: iT,
  numero: aT,
  numsp: lT,
  nvap: uT,
  nvdash: fT,
  nvDash: pT,
  nVdash: hT,
  nVDash: dT,
  nvge: gT,
  nvgt: mT,
  nvHarr: _T,
  nvinfin: bT,
  nvlArr: vT,
  nvle: kT,
  nvlt: xT,
  nvltrie: yT,
  nvrArr: ET,
  nvrtrie: wT,
  nvsim: AT,
  nwarhk: CT,
  nwarr: ST,
  nwArr: DT,
  nwarrow: TT,
  nwnear: RT,
  Oacute: LT,
  oacute: NT,
  oast: qT,
  Ocirc: MT,
  ocirc: IT,
  ocir: OT,
  Ocy: FT,
  ocy: BT,
  odash: PT,
  Odblac: $T,
  odblac: zT,
  odiv: UT,
  odot: HT,
  odsold: VT,
  OElig: GT,
  oelig: jT,
  ofcir: ZT,
  Ofr: KT,
  ofr: WT,
  ogon: YT,
  Ograve: JT,
  ograve: XT,
  ogt: QT,
  ohbar: eR,
  ohm: nR,
  oint: tR,
  olarr: rR,
  olcir: oR,
  olcross: sR,
  oline: cR,
  olt: iR,
  Omacr: aR,
  omacr: lR,
  Omega: uR,
  omega: fR,
  Omicron: pR,
  omicron: hR,
  omid: dR,
  ominus: gR,
  Oopf: mR,
  oopf: _R,
  opar: bR,
  OpenCurlyDoubleQuote: vR,
  OpenCurlyQuote: kR,
  operp: xR,
  oplus: yR,
  orarr: ER,
  Or: wR,
  or: AR,
  ord: CR,
  order: SR,
  orderof: DR,
  ordf: TR,
  ordm: RR,
  origof: LR,
  oror: NR,
  orslope: qR,
  orv: MR,
  oS: IR,
  Oscr: OR,
  oscr: FR,
  Oslash: BR,
  oslash: PR,
  osol: $R,
  Otilde: zR,
  otilde: UR,
  otimesas: HR,
  Otimes: VR,
  otimes: GR,
  Ouml: jR,
  ouml: ZR,
  ovbar: KR,
  OverBar: WR,
  OverBrace: YR,
  OverBracket: JR,
  OverParenthesis: XR,
  para: QR,
  parallel: e2,
  par: n2,
  parsim: t2,
  parsl: r2,
  part: o2,
  PartialD: s2,
  Pcy: c2,
  pcy: i2,
  percnt: a2,
  period: l2,
  permil: u2,
  perp: f2,
  pertenk: p2,
  Pfr: h2,
  pfr: d2,
  Phi: g2,
  phi: m2,
  phiv: _2,
  phmmat: b2,
  phone: v2,
  Pi: k2,
  pi: x2,
  pitchfork: y2,
  piv: E2,
  planck: w2,
  planckh: A2,
  plankv: C2,
  plusacir: S2,
  plusb: D2,
  pluscir: T2,
  plus: R2,
  plusdo: L2,
  plusdu: N2,
  pluse: q2,
  PlusMinus: M2,
  plusmn: I2,
  plussim: O2,
  plustwo: F2,
  pm: B2,
  Poincareplane: P2,
  pointint: $2,
  popf: z2,
  Popf: U2,
  pound: H2,
  prap: V2,
  Pr: G2,
  pr: j2,
  prcue: Z2,
  precapprox: K2,
  prec: W2,
  preccurlyeq: Y2,
  Precedes: J2,
  PrecedesEqual: X2,
  PrecedesSlantEqual: Q2,
  PrecedesTilde: eL,
  preceq: nL,
  precnapprox: tL,
  precneqq: rL,
  precnsim: oL,
  pre: sL,
  prE: cL,
  precsim: iL,
  prime: aL,
  Prime: lL,
  primes: uL,
  prnap: fL,
  prnE: pL,
  prnsim: hL,
  prod: dL,
  Product: gL,
  profalar: mL,
  profline: _L,
  profsurf: bL,
  prop: vL,
  Proportional: kL,
  Proportion: xL,
  propto: yL,
  prsim: EL,
  prurel: wL,
  Pscr: AL,
  pscr: CL,
  Psi: SL,
  psi: DL,
  puncsp: TL,
  Qfr: RL,
  qfr: LL,
  qint: NL,
  qopf: qL,
  Qopf: ML,
  qprime: IL,
  Qscr: OL,
  qscr: FL,
  quaternions: BL,
  quatint: PL,
  quest: $L,
  questeq: zL,
  quot: UL,
  QUOT: HL,
  rAarr: VL,
  race: GL,
  Racute: jL,
  racute: ZL,
  radic: KL,
  raemptyv: WL,
  rang: YL,
  Rang: JL,
  rangd: XL,
  range: QL,
  rangle: eN,
  raquo: nN,
  rarrap: tN,
  rarrb: rN,
  rarrbfs: oN,
  rarrc: sN,
  rarr: cN,
  Rarr: iN,
  rArr: aN,
  rarrfs: lN,
  rarrhk: uN,
  rarrlp: fN,
  rarrpl: pN,
  rarrsim: hN,
  Rarrtl: dN,
  rarrtl: gN,
  rarrw: mN,
  ratail: _N,
  rAtail: bN,
  ratio: vN,
  rationals: kN,
  rbarr: xN,
  rBarr: yN,
  RBarr: EN,
  rbbrk: wN,
  rbrace: AN,
  rbrack: CN,
  rbrke: SN,
  rbrksld: DN,
  rbrkslu: TN,
  Rcaron: RN,
  rcaron: LN,
  Rcedil: NN,
  rcedil: qN,
  rceil: MN,
  rcub: IN,
  Rcy: ON,
  rcy: FN,
  rdca: BN,
  rdldhar: PN,
  rdquo: $N,
  rdquor: zN,
  rdsh: UN,
  real: HN,
  realine: VN,
  realpart: GN,
  reals: jN,
  Re: ZN,
  rect: KN,
  reg: WN,
  REG: YN,
  ReverseElement: JN,
  ReverseEquilibrium: XN,
  ReverseUpEquilibrium: QN,
  rfisht: eq,
  rfloor: nq,
  rfr: tq,
  Rfr: rq,
  rHar: oq,
  rhard: sq,
  rharu: cq,
  rharul: iq,
  Rho: aq,
  rho: lq,
  rhov: uq,
  RightAngleBracket: fq,
  RightArrowBar: pq,
  rightarrow: hq,
  RightArrow: dq,
  Rightarrow: gq,
  RightArrowLeftArrow: mq,
  rightarrowtail: _q,
  RightCeiling: bq,
  RightDoubleBracket: vq,
  RightDownTeeVector: kq,
  RightDownVectorBar: xq,
  RightDownVector: yq,
  RightFloor: Eq,
  rightharpoondown: wq,
  rightharpoonup: Aq,
  rightleftarrows: Cq,
  rightleftharpoons: Sq,
  rightrightarrows: Dq,
  rightsquigarrow: Tq,
  RightTeeArrow: Rq,
  RightTee: Lq,
  RightTeeVector: Nq,
  rightthreetimes: qq,
  RightTriangleBar: Mq,
  RightTriangle: Iq,
  RightTriangleEqual: Oq,
  RightUpDownVector: Fq,
  RightUpTeeVector: Bq,
  RightUpVectorBar: Pq,
  RightUpVector: $q,
  RightVectorBar: zq,
  RightVector: Uq,
  ring: Hq,
  risingdotseq: Vq,
  rlarr: Gq,
  rlhar: jq,
  rlm: Zq,
  rmoustache: Kq,
  rmoust: Wq,
  rnmid: Yq,
  roang: Jq,
  roarr: Xq,
  robrk: Qq,
  ropar: eM,
  ropf: nM,
  Ropf: tM,
  roplus: rM,
  rotimes: oM,
  RoundImplies: sM,
  rpar: cM,
  rpargt: iM,
  rppolint: aM,
  rrarr: lM,
  Rrightarrow: uM,
  rsaquo: fM,
  rscr: pM,
  Rscr: hM,
  rsh: dM,
  Rsh: gM,
  rsqb: mM,
  rsquo: _M,
  rsquor: bM,
  rthree: vM,
  rtimes: kM,
  rtri: xM,
  rtrie: yM,
  rtrif: EM,
  rtriltri: wM,
  RuleDelayed: AM,
  ruluhar: CM,
  rx: SM,
  Sacute: DM,
  sacute: TM,
  sbquo: RM,
  scap: LM,
  Scaron: NM,
  scaron: qM,
  Sc: MM,
  sc: IM,
  sccue: OM,
  sce: FM,
  scE: BM,
  Scedil: PM,
  scedil: $M,
  Scirc: zM,
  scirc: UM,
  scnap: HM,
  scnE: VM,
  scnsim: GM,
  scpolint: jM,
  scsim: ZM,
  Scy: KM,
  scy: WM,
  sdotb: YM,
  sdot: JM,
  sdote: XM,
  searhk: QM,
  searr: eI,
  seArr: nI,
  searrow: tI,
  sect: rI,
  semi: oI,
  seswar: sI,
  setminus: cI,
  setmn: iI,
  sext: aI,
  Sfr: lI,
  sfr: uI,
  sfrown: fI,
  sharp: pI,
  SHCHcy: hI,
  shchcy: dI,
  SHcy: gI,
  shcy: mI,
  ShortDownArrow: _I,
  ShortLeftArrow: bI,
  shortmid: vI,
  shortparallel: kI,
  ShortRightArrow: xI,
  ShortUpArrow: yI,
  shy: EI,
  Sigma: wI,
  sigma: AI,
  sigmaf: CI,
  sigmav: SI,
  sim: DI,
  simdot: TI,
  sime: RI,
  simeq: LI,
  simg: NI,
  simgE: qI,
  siml: MI,
  simlE: II,
  simne: OI,
  simplus: FI,
  simrarr: BI,
  slarr: PI,
  SmallCircle: $I,
  smallsetminus: zI,
  smashp: UI,
  smeparsl: HI,
  smid: VI,
  smile: GI,
  smt: jI,
  smte: ZI,
  smtes: KI,
  SOFTcy: WI,
  softcy: YI,
  solbar: JI,
  solb: XI,
  sol: QI,
  Sopf: eO,
  sopf: nO,
  spades: tO,
  spadesuit: rO,
  spar: oO,
  sqcap: sO,
  sqcaps: cO,
  sqcup: iO,
  sqcups: aO,
  Sqrt: lO,
  sqsub: uO,
  sqsube: fO,
  sqsubset: pO,
  sqsubseteq: hO,
  sqsup: dO,
  sqsupe: gO,
  sqsupset: mO,
  sqsupseteq: _O,
  square: bO,
  Square: vO,
  SquareIntersection: kO,
  SquareSubset: xO,
  SquareSubsetEqual: yO,
  SquareSuperset: EO,
  SquareSupersetEqual: wO,
  SquareUnion: AO,
  squarf: CO,
  squ: SO,
  squf: DO,
  srarr: TO,
  Sscr: RO,
  sscr: LO,
  ssetmn: NO,
  ssmile: qO,
  sstarf: MO,
  Star: IO,
  star: OO,
  starf: FO,
  straightepsilon: BO,
  straightphi: PO,
  strns: $O,
  sub: zO,
  Sub: UO,
  subdot: HO,
  subE: VO,
  sube: GO,
  subedot: jO,
  submult: ZO,
  subnE: KO,
  subne: WO,
  subplus: YO,
  subrarr: JO,
  subset: XO,
  Subset: QO,
  subseteq: eF,
  subseteqq: nF,
  SubsetEqual: tF,
  subsetneq: rF,
  subsetneqq: oF,
  subsim: sF,
  subsub: cF,
  subsup: iF,
  succapprox: aF,
  succ: lF,
  succcurlyeq: uF,
  Succeeds: fF,
  SucceedsEqual: pF,
  SucceedsSlantEqual: hF,
  SucceedsTilde: dF,
  succeq: gF,
  succnapprox: mF,
  succneqq: _F,
  succnsim: bF,
  succsim: vF,
  SuchThat: kF,
  sum: xF,
  Sum: yF,
  sung: EF,
  sup1: wF,
  sup2: AF,
  sup3: CF,
  sup: SF,
  Sup: DF,
  supdot: TF,
  supdsub: RF,
  supE: LF,
  supe: NF,
  supedot: qF,
  Superset: MF,
  SupersetEqual: IF,
  suphsol: OF,
  suphsub: FF,
  suplarr: BF,
  supmult: PF,
  supnE: $F,
  supne: zF,
  supplus: UF,
  supset: HF,
  Supset: VF,
  supseteq: GF,
  supseteqq: jF,
  supsetneq: ZF,
  supsetneqq: KF,
  supsim: WF,
  supsub: YF,
  supsup: JF,
  swarhk: XF,
  swarr: QF,
  swArr: eB,
  swarrow: nB,
  swnwar: tB,
  szlig: rB,
  Tab: oB,
  target: sB,
  Tau: cB,
  tau: iB,
  tbrk: aB,
  Tcaron: lB,
  tcaron: uB,
  Tcedil: fB,
  tcedil: pB,
  Tcy: hB,
  tcy: dB,
  tdot: gB,
  telrec: mB,
  Tfr: _B,
  tfr: bB,
  there4: vB,
  therefore: kB,
  Therefore: xB,
  Theta: yB,
  theta: EB,
  thetasym: wB,
  thetav: AB,
  thickapprox: CB,
  thicksim: SB,
  ThickSpace: DB,
  ThinSpace: TB,
  thinsp: RB,
  thkap: LB,
  thksim: NB,
  THORN: qB,
  thorn: MB,
  tilde: IB,
  Tilde: OB,
  TildeEqual: FB,
  TildeFullEqual: BB,
  TildeTilde: PB,
  timesbar: $B,
  timesb: zB,
  times: UB,
  timesd: HB,
  tint: VB,
  toea: GB,
  topbot: jB,
  topcir: ZB,
  top: KB,
  Topf: WB,
  topf: YB,
  topfork: JB,
  tosa: XB,
  tprime: QB,
  trade: eP,
  TRADE: nP,
  triangle: tP,
  triangledown: rP,
  triangleleft: oP,
  trianglelefteq: sP,
  triangleq: cP,
  triangleright: iP,
  trianglerighteq: aP,
  tridot: lP,
  trie: uP,
  triminus: fP,
  TripleDot: pP,
  triplus: hP,
  trisb: dP,
  tritime: gP,
  trpezium: mP,
  Tscr: _P,
  tscr: bP,
  TScy: vP,
  tscy: kP,
  TSHcy: xP,
  tshcy: yP,
  Tstrok: EP,
  tstrok: wP,
  twixt: AP,
  twoheadleftarrow: CP,
  twoheadrightarrow: SP,
  Uacute: DP,
  uacute: TP,
  uarr: RP,
  Uarr: LP,
  uArr: NP,
  Uarrocir: qP,
  Ubrcy: MP,
  ubrcy: IP,
  Ubreve: OP,
  ubreve: FP,
  Ucirc: BP,
  ucirc: PP,
  Ucy: $P,
  ucy: zP,
  udarr: UP,
  Udblac: HP,
  udblac: VP,
  udhar: GP,
  ufisht: jP,
  Ufr: ZP,
  ufr: KP,
  Ugrave: WP,
  ugrave: YP,
  uHar: JP,
  uharl: XP,
  uharr: QP,
  uhblk: e$,
  ulcorn: n$,
  ulcorner: t$,
  ulcrop: r$,
  ultri: o$,
  Umacr: s$,
  umacr: c$,
  uml: i$,
  UnderBar: a$,
  UnderBrace: l$,
  UnderBracket: u$,
  UnderParenthesis: f$,
  Union: p$,
  UnionPlus: h$,
  Uogon: d$,
  uogon: g$,
  Uopf: m$,
  uopf: _$,
  UpArrowBar: b$,
  uparrow: v$,
  UpArrow: k$,
  Uparrow: x$,
  UpArrowDownArrow: y$,
  updownarrow: E$,
  UpDownArrow: w$,
  Updownarrow: A$,
  UpEquilibrium: C$,
  upharpoonleft: S$,
  upharpoonright: D$,
  uplus: T$,
  UpperLeftArrow: R$,
  UpperRightArrow: L$,
  upsi: N$,
  Upsi: q$,
  upsih: M$,
  Upsilon: I$,
  upsilon: O$,
  UpTeeArrow: F$,
  UpTee: B$,
  upuparrows: P$,
  urcorn: $$,
  urcorner: z$,
  urcrop: U$,
  Uring: H$,
  uring: V$,
  urtri: G$,
  Uscr: j$,
  uscr: Z$,
  utdot: K$,
  Utilde: W$,
  utilde: Y$,
  utri: J$,
  utrif: X$,
  uuarr: Q$,
  Uuml: ez,
  uuml: nz,
  uwangle: tz,
  vangrt: rz,
  varepsilon: oz,
  varkappa: sz,
  varnothing: cz,
  varphi: iz,
  varpi: az,
  varpropto: lz,
  varr: uz,
  vArr: fz,
  varrho: pz,
  varsigma: hz,
  varsubsetneq: dz,
  varsubsetneqq: gz,
  varsupsetneq: mz,
  varsupsetneqq: _z,
  vartheta: bz,
  vartriangleleft: vz,
  vartriangleright: kz,
  vBar: xz,
  Vbar: yz,
  vBarv: Ez,
  Vcy: wz,
  vcy: Az,
  vdash: Cz,
  vDash: Sz,
  Vdash: Dz,
  VDash: Tz,
  Vdashl: Rz,
  veebar: Lz,
  vee: Nz,
  Vee: qz,
  veeeq: Mz,
  vellip: Iz,
  verbar: Oz,
  Verbar: Fz,
  vert: Bz,
  Vert: Pz,
  VerticalBar: $z,
  VerticalLine: zz,
  VerticalSeparator: Uz,
  VerticalTilde: Hz,
  VeryThinSpace: Vz,
  Vfr: Gz,
  vfr: jz,
  vltri: Zz,
  vnsub: Kz,
  vnsup: Wz,
  Vopf: Yz,
  vopf: Jz,
  vprop: Xz,
  vrtri: Qz,
  Vscr: e3,
  vscr: n3,
  vsubnE: t3,
  vsubne: r3,
  vsupnE: o3,
  vsupne: s3,
  Vvdash: c3,
  vzigzag: i3,
  Wcirc: a3,
  wcirc: l3,
  wedbar: u3,
  wedge: f3,
  Wedge: p3,
  wedgeq: h3,
  weierp: d3,
  Wfr: g3,
  wfr: m3,
  Wopf: _3,
  wopf: b3,
  wp: v3,
  wr: k3,
  wreath: x3,
  Wscr: y3,
  wscr: E3,
  xcap: w3,
  xcirc: A3,
  xcup: C3,
  xdtri: S3,
  Xfr: D3,
  xfr: T3,
  xharr: R3,
  xhArr: L3,
  Xi: N3,
  xi: q3,
  xlarr: M3,
  xlArr: I3,
  xmap: O3,
  xnis: F3,
  xodot: B3,
  Xopf: P3,
  xopf: $3,
  xoplus: z3,
  xotime: U3,
  xrarr: H3,
  xrArr: V3,
  Xscr: G3,
  xscr: j3,
  xsqcup: Z3,
  xuplus: K3,
  xutri: W3,
  xvee: Y3,
  xwedge: J3,
  Yacute: X3,
  yacute: Q3,
  YAcy: eU,
  yacy: nU,
  Ycirc: tU,
  ycirc: rU,
  Ycy: oU,
  ycy: sU,
  yen: cU,
  Yfr: iU,
  yfr: aU,
  YIcy: lU,
  yicy: uU,
  Yopf: fU,
  yopf: pU,
  Yscr: hU,
  yscr: dU,
  YUcy: gU,
  yucy: mU,
  yuml: _U,
  Yuml: bU,
  Zacute: vU,
  zacute: kU,
  Zcaron: xU,
  zcaron: yU,
  Zcy: EU,
  zcy: wU,
  Zdot: AU,
  zdot: CU,
  zeetrf: SU,
  ZeroWidthSpace: DU,
  Zeta: TU,
  zeta: RU,
  zfr: LU,
  Zfr: NU,
  ZHcy: qU,
  zhcy: MU,
  zigrarr: IU,
  zopf: OU,
  Zopf: FU,
  Zscr: BU,
  zscr: PU,
  zwj: $U,
  zwnj: zU
};
var zr = UU, Jn = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/, Me = {}, wt = {};
function HU(n) {
  var e, t, r = wt[n];
  if (r)
    return r;
  for (r = wt[n] = [], e = 0; e < 128; e++)
    t = String.fromCharCode(e), /^[0-9a-z]$/i.test(t) ? r.push(t) : r.push("%" + ("0" + e.toString(16).toUpperCase()).slice(-2));
  for (e = 0; e < n.length; e++)
    r[n.charCodeAt(e)] = n[e];
  return r;
}
function pn(n, e, t) {
  var r, o, s, i, c, a = "";
  for (typeof e != "string" && (t = e, e = pn.defaultChars), typeof t > "u" && (t = !0), c = HU(e), r = 0, o = n.length; r < o; r++) {
    if (s = n.charCodeAt(r), t && s === 37 && r + 2 < o && /^[0-9a-f]{2}$/i.test(n.slice(r + 1, r + 3))) {
      a += n.slice(r, r + 3), r += 2;
      continue;
    }
    if (s < 128) {
      a += c[s];
      continue;
    }
    if (s >= 55296 && s <= 57343) {
      if (s >= 55296 && s <= 56319 && r + 1 < o && (i = n.charCodeAt(r + 1), i >= 56320 && i <= 57343)) {
        a += encodeURIComponent(n[r] + n[r + 1]), r++;
        continue;
      }
      a += "%EF%BF%BD";
      continue;
    }
    a += encodeURIComponent(n[r]);
  }
  return a;
}
pn.defaultChars = ";/?:@&=+$,-_.!~*'()#";
pn.componentChars = "-_.!~*'()";
var VU = pn, At = {};
function GU(n) {
  var e, t, r = At[n];
  if (r)
    return r;
  for (r = At[n] = [], e = 0; e < 128; e++)
    t = String.fromCharCode(e), r.push(t);
  for (e = 0; e < n.length; e++)
    t = n.charCodeAt(e), r[t] = "%" + ("0" + t.toString(16).toUpperCase()).slice(-2);
  return r;
}
function hn(n, e) {
  var t;
  return typeof e != "string" && (e = hn.defaultChars), t = GU(e), n.replace(/(%[a-f0-9]{2})+/gi, function(r) {
    var o, s, i, c, a, l, u, p = "";
    for (o = 0, s = r.length; o < s; o += 3) {
      if (i = parseInt(r.slice(o + 1, o + 3), 16), i < 128) {
        p += t[i];
        continue;
      }
      if ((i & 224) === 192 && o + 3 < s && (c = parseInt(r.slice(o + 4, o + 6), 16), (c & 192) === 128)) {
        u = i << 6 & 1984 | c & 63, u < 128 ? p += "��" : p += String.fromCharCode(u), o += 3;
        continue;
      }
      if ((i & 240) === 224 && o + 6 < s && (c = parseInt(r.slice(o + 4, o + 6), 16), a = parseInt(r.slice(o + 7, o + 9), 16), (c & 192) === 128 && (a & 192) === 128)) {
        u = i << 12 & 61440 | c << 6 & 4032 | a & 63, u < 2048 || u >= 55296 && u <= 57343 ? p += "���" : p += String.fromCharCode(u), o += 6;
        continue;
      }
      if ((i & 248) === 240 && o + 9 < s && (c = parseInt(r.slice(o + 4, o + 6), 16), a = parseInt(r.slice(o + 7, o + 9), 16), l = parseInt(r.slice(o + 10, o + 12), 16), (c & 192) === 128 && (a & 192) === 128 && (l & 192) === 128)) {
        u = i << 18 & 1835008 | c << 12 & 258048 | a << 6 & 4032 | l & 63, u < 65536 || u > 1114111 ? p += "����" : (u -= 65536, p += String.fromCharCode(55296 + (u >> 10), 56320 + (u & 1023))), o += 9;
        continue;
      }
      p += "�";
    }
    return p;
  });
}
hn.defaultChars = ";/?:@&=+$,#";
hn.componentChars = "";
var jU = hn, ZU = function(e) {
  var t = "";
  return t += e.protocol || "", t += e.slashes ? "//" : "", t += e.auth ? e.auth + "@" : "", e.hostname && e.hostname.indexOf(":") !== -1 ? t += "[" + e.hostname + "]" : t += e.hostname || "", t += e.port ? ":" + e.port : "", t += e.pathname || "", t += e.search || "", t += e.hash || "", t;
};
function cn() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
var KU = /^([a-z0-9.+-]+:)/i, WU = /:[0-9]*$/, YU = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, JU = ["<", ">", '"', "`", " ", "\r", `
`, "	"], XU = ["{", "}", "|", "\\", "^", "`"].concat(JU), QU = ["'"].concat(XU), Ct = ["%", "/", "?", ";", "#"].concat(QU), St = ["/", "?", "#"], e9 = 255, Dt = /^[+a-z0-9A-Z_-]{0,63}$/, n9 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, Tt = {
  javascript: !0,
  "javascript:": !0
}, Rt = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
};
function t9(n, e) {
  if (n && n instanceof cn)
    return n;
  var t = new cn();
  return t.parse(n, e), t;
}
cn.prototype.parse = function(n, e) {
  var t, r, o, s, i, c = n;
  if (c = c.trim(), !e && n.split("#").length === 1) {
    var a = YU.exec(c);
    if (a)
      return this.pathname = a[1], a[2] && (this.search = a[2]), this;
  }
  var l = KU.exec(c);
  if (l && (l = l[0], o = l.toLowerCase(), this.protocol = l, c = c.substr(l.length)), (e || l || c.match(/^\/\/[^@\/]+@[^@\/]+/)) && (i = c.substr(0, 2) === "//", i && !(l && Tt[l]) && (c = c.substr(2), this.slashes = !0)), !Tt[l] && (i || l && !Rt[l])) {
    var u = -1;
    for (t = 0; t < St.length; t++)
      s = c.indexOf(St[t]), s !== -1 && (u === -1 || s < u) && (u = s);
    var p, f;
    for (u === -1 ? f = c.lastIndexOf("@") : f = c.lastIndexOf("@", u), f !== -1 && (p = c.slice(0, f), c = c.slice(f + 1), this.auth = p), u = -1, t = 0; t < Ct.length; t++)
      s = c.indexOf(Ct[t]), s !== -1 && (u === -1 || s < u) && (u = s);
    u === -1 && (u = c.length), c[u - 1] === ":" && u--;
    var h = c.slice(0, u);
    c = c.slice(u), this.parseHost(h), this.hostname = this.hostname || "";
    var d = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!d) {
      var g = this.hostname.split(/\./);
      for (t = 0, r = g.length; t < r; t++) {
        var E = g[t];
        if (E && !E.match(Dt)) {
          for (var x = "", b = 0, A = E.length; b < A; b++)
            E.charCodeAt(b) > 127 ? x += "x" : x += E[b];
          if (!x.match(Dt)) {
            var D = g.slice(0, t), L = g.slice(t + 1), v = E.match(n9);
            v && (D.push(v[1]), L.unshift(v[2])), L.length && (c = L.join(".") + c), this.hostname = D.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > e9 && (this.hostname = ""), d && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  var O = c.indexOf("#");
  O !== -1 && (this.hash = c.substr(O), c = c.slice(0, O));
  var z = c.indexOf("?");
  return z !== -1 && (this.search = c.substr(z), c = c.slice(0, z)), c && (this.pathname = c), Rt[o] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
cn.prototype.parseHost = function(n) {
  var e = WU.exec(n);
  e && (e = e[0], e !== ":" && (this.port = e.substr(1)), n = n.substr(0, n.length - e.length)), n && (this.hostname = n);
};
var r9 = t9;
Me.encode = VU;
Me.decode = jU;
Me.format = ZU;
Me.parse = r9;
var Ee = {}, Cn, Lt;
function Ur() {
  return Lt || (Lt = 1, Cn = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/), Cn;
}
var Sn, Nt;
function Hr() {
  return Nt || (Nt = 1, Sn = /[\0-\x1F\x7F-\x9F]/), Sn;
}
var Dn, qt;
function o9() {
  return qt || (qt = 1, Dn = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/), Dn;
}
var Tn, Mt;
function Vr() {
  return Mt || (Mt = 1, Tn = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/), Tn;
}
var It;
function s9() {
  return It || (It = 1, Ee.Any = Ur(), Ee.Cc = Hr(), Ee.Cf = o9(), Ee.P = Jn, Ee.Z = Vr()), Ee;
}
(function(n) {
  function e(_) {
    return Object.prototype.toString.call(_);
  }
  function t(_) {
    return e(_) === "[object String]";
  }
  var r = Object.prototype.hasOwnProperty;
  function o(_, T) {
    return r.call(_, T);
  }
  function s(_) {
    var T = Array.prototype.slice.call(arguments, 1);
    return T.forEach(function(w) {
      if (w) {
        if (typeof w != "object")
          throw new TypeError(w + "must be object");
        Object.keys(w).forEach(function(m) {
          _[m] = w[m];
        });
      }
    }), _;
  }
  function i(_, T, w) {
    return [].concat(_.slice(0, T), w, _.slice(T + 1));
  }
  function c(_) {
    return !(_ >= 55296 && _ <= 57343 || _ >= 64976 && _ <= 65007 || (_ & 65535) === 65535 || (_ & 65535) === 65534 || _ >= 0 && _ <= 8 || _ === 11 || _ >= 14 && _ <= 31 || _ >= 127 && _ <= 159 || _ > 1114111);
  }
  function a(_) {
    if (_ > 65535) {
      _ -= 65536;
      var T = 55296 + (_ >> 10), w = 56320 + (_ & 1023);
      return String.fromCharCode(T, w);
    }
    return String.fromCharCode(_);
  }
  var l = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g, u = /&([a-z#][a-z0-9]{1,31});/gi, p = new RegExp(l.source + "|" + u.source, "gi"), f = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i, h = zr;
  function d(_, T) {
    var w;
    return o(h, T) ? h[T] : T.charCodeAt(0) === 35 && f.test(T) && (w = T[1].toLowerCase() === "x" ? parseInt(T.slice(2), 16) : parseInt(T.slice(1), 10), c(w)) ? a(w) : _;
  }
  function g(_) {
    return _.indexOf("\\") < 0 ? _ : _.replace(l, "$1");
  }
  function E(_) {
    return _.indexOf("\\") < 0 && _.indexOf("&") < 0 ? _ : _.replace(p, function(T, w, m) {
      return w || d(T, m);
    });
  }
  var x = /[&<>"]/, b = /[&<>"]/g, A = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;"
  };
  function D(_) {
    return A[_];
  }
  function L(_) {
    return x.test(_) ? _.replace(b, D) : _;
  }
  var v = /[.?*+^$[\]\\(){}|-]/g;
  function O(_) {
    return _.replace(v, "\\$&");
  }
  function z(_) {
    switch (_) {
      case 9:
      case 32:
        return !0;
    }
    return !1;
  }
  function j(_) {
    if (_ >= 8192 && _ <= 8202)
      return !0;
    switch (_) {
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 32:
      case 160:
      case 5760:
      case 8239:
      case 8287:
      case 12288:
        return !0;
    }
    return !1;
  }
  var M = Jn;
  function K(_) {
    return M.test(_);
  }
  function q(_) {
    switch (_) {
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 124:
      case 125:
      case 126:
        return !0;
      default:
        return !1;
    }
  }
  function Z(_) {
    return _ = _.trim().replace(/\s+/g, " "), "ẞ".toLowerCase() === "Ṿ" && (_ = _.replace(/ẞ/g, "ß")), _.toLowerCase().toUpperCase();
  }
  n.lib = {}, n.lib.mdurl = Me, n.lib.ucmicro = s9(), n.assign = s, n.isString = t, n.has = o, n.unescapeMd = g, n.unescapeAll = E, n.isValidEntityCode = c, n.fromCodePoint = a, n.escapeHtml = L, n.arrayReplaceAt = i, n.isSpace = z, n.isWhiteSpace = j, n.isMdAsciiPunct = q, n.isPunctChar = K, n.escapeRE = O, n.normalizeReference = Z;
})($);
var dn = {}, c9 = function(e, t, r) {
  var o, s, i, c, a = -1, l = e.posMax, u = e.pos;
  for (e.pos = t + 1, o = 1; e.pos < l; ) {
    if (i = e.src.charCodeAt(e.pos), i === 93 && (o--, o === 0)) {
      s = !0;
      break;
    }
    if (c = e.pos, e.md.inline.skipToken(e), i === 91) {
      if (c === e.pos - 1)
        o++;
      else if (r)
        return e.pos = u, -1;
    }
  }
  return s && (a = e.pos), e.pos = u, a;
}, Ot = $.unescapeAll, i9 = function(e, t, r) {
  var o, s, i = t, c = {
    ok: !1,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (e.charCodeAt(i) === 60) {
    for (i++; i < r; ) {
      if (o = e.charCodeAt(i), o === 10 || o === 60)
        return c;
      if (o === 62)
        return c.pos = i + 1, c.str = Ot(e.slice(t + 1, i)), c.ok = !0, c;
      if (o === 92 && i + 1 < r) {
        i += 2;
        continue;
      }
      i++;
    }
    return c;
  }
  for (s = 0; i < r && (o = e.charCodeAt(i), !(o === 32 || o < 32 || o === 127)); ) {
    if (o === 92 && i + 1 < r) {
      if (e.charCodeAt(i + 1) === 32)
        break;
      i += 2;
      continue;
    }
    if (o === 40 && (s++, s > 32))
      return c;
    if (o === 41) {
      if (s === 0)
        break;
      s--;
    }
    i++;
  }
  return t === i || s !== 0 || (c.str = Ot(e.slice(t, i)), c.pos = i, c.ok = !0), c;
}, a9 = $.unescapeAll, l9 = function(e, t, r) {
  var o, s, i = 0, c = t, a = {
    ok: !1,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (c >= r || (s = e.charCodeAt(c), s !== 34 && s !== 39 && s !== 40))
    return a;
  for (c++, s === 40 && (s = 41); c < r; ) {
    if (o = e.charCodeAt(c), o === s)
      return a.pos = c + 1, a.lines = i, a.str = a9(e.slice(t + 1, c)), a.ok = !0, a;
    if (o === 40 && s === 41)
      return a;
    o === 10 ? i++ : o === 92 && c + 1 < r && (c++, e.charCodeAt(c) === 10 && i++), c++;
  }
  return a;
};
dn.parseLinkLabel = c9;
dn.parseLinkDestination = i9;
dn.parseLinkTitle = l9;
var u9 = $.assign, f9 = $.unescapeAll, Se = $.escapeHtml, ge = {};
ge.code_inline = function(n, e, t, r, o) {
  var s = n[e];
  return "<code" + o.renderAttrs(s) + ">" + Se(s.content) + "</code>";
};
ge.code_block = function(n, e, t, r, o) {
  var s = n[e];
  return "<pre" + o.renderAttrs(s) + "><code>" + Se(n[e].content) + `</code></pre>
`;
};
ge.fence = function(n, e, t, r, o) {
  var s = n[e], i = s.info ? f9(s.info).trim() : "", c = "", a = "", l, u, p, f, h;
  return i && (p = i.split(/(\s+)/g), c = p[0], a = p.slice(2).join("")), t.highlight ? l = t.highlight(s.content, c, a) || Se(s.content) : l = Se(s.content), l.indexOf("<pre") === 0 ? l + `
` : i ? (u = s.attrIndex("class"), f = s.attrs ? s.attrs.slice() : [], u < 0 ? f.push(["class", t.langPrefix + c]) : (f[u] = f[u].slice(), f[u][1] += " " + t.langPrefix + c), h = {
    attrs: f
  }, "<pre><code" + o.renderAttrs(h) + ">" + l + `</code></pre>
`) : "<pre><code" + o.renderAttrs(s) + ">" + l + `</code></pre>
`;
};
ge.image = function(n, e, t, r, o) {
  var s = n[e];
  return s.attrs[s.attrIndex("alt")][1] = o.renderInlineAsText(s.children, t, r), o.renderToken(n, e, t);
};
ge.hardbreak = function(n, e, t) {
  return t.xhtmlOut ? `<br />
` : `<br>
`;
};
ge.softbreak = function(n, e, t) {
  return t.breaks ? t.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
ge.text = function(n, e) {
  return Se(n[e].content);
};
ge.html_block = function(n, e) {
  return n[e].content;
};
ge.html_inline = function(n, e) {
  return n[e].content;
};
function Ie() {
  this.rules = u9({}, ge);
}
Ie.prototype.renderAttrs = function(e) {
  var t, r, o;
  if (!e.attrs)
    return "";
  for (o = "", t = 0, r = e.attrs.length; t < r; t++)
    o += " " + Se(e.attrs[t][0]) + '="' + Se(e.attrs[t][1]) + '"';
  return o;
};
Ie.prototype.renderToken = function(e, t, r) {
  var o, s = "", i = !1, c = e[t];
  return c.hidden ? "" : (c.block && c.nesting !== -1 && t && e[t - 1].hidden && (s += `
`), s += (c.nesting === -1 ? "</" : "<") + c.tag, s += this.renderAttrs(c), c.nesting === 0 && r.xhtmlOut && (s += " /"), c.block && (i = !0, c.nesting === 1 && t + 1 < e.length && (o = e[t + 1], (o.type === "inline" || o.hidden || o.nesting === -1 && o.tag === c.tag) && (i = !1))), s += i ? `>
` : ">", s);
};
Ie.prototype.renderInline = function(n, e, t) {
  for (var r, o = "", s = this.rules, i = 0, c = n.length; i < c; i++)
    r = n[i].type, typeof s[r] < "u" ? o += s[r](n, i, e, t, this) : o += this.renderToken(n, i, e);
  return o;
};
Ie.prototype.renderInlineAsText = function(n, e, t) {
  for (var r = "", o = 0, s = n.length; o < s; o++)
    n[o].type === "text" ? r += n[o].content : n[o].type === "image" ? r += this.renderInlineAsText(n[o].children, e, t) : n[o].type === "softbreak" && (r += `
`);
  return r;
};
Ie.prototype.render = function(n, e, t) {
  var r, o, s, i = "", c = this.rules;
  for (r = 0, o = n.length; r < o; r++)
    s = n[r].type, s === "inline" ? i += this.renderInline(n[r].children, e, t) : typeof c[s] < "u" ? i += c[s](n, r, e, t, this) : i += this.renderToken(n, r, e, t);
  return i;
};
var p9 = Ie;
function le() {
  this.__rules__ = [], this.__cache__ = null;
}
le.prototype.__find__ = function(n) {
  for (var e = 0; e < this.__rules__.length; e++)
    if (this.__rules__[e].name === n)
      return e;
  return -1;
};
le.prototype.__compile__ = function() {
  var n = this, e = [""];
  n.__rules__.forEach(function(t) {
    t.enabled && t.alt.forEach(function(r) {
      e.indexOf(r) < 0 && e.push(r);
    });
  }), n.__cache__ = {}, e.forEach(function(t) {
    n.__cache__[t] = [], n.__rules__.forEach(function(r) {
      r.enabled && (t && r.alt.indexOf(t) < 0 || n.__cache__[t].push(r.fn));
    });
  });
};
le.prototype.at = function(n, e, t) {
  var r = this.__find__(n), o = t || {};
  if (r === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__[r].fn = e, this.__rules__[r].alt = o.alt || [], this.__cache__ = null;
};
le.prototype.before = function(n, e, t, r) {
  var o = this.__find__(n), s = r || {};
  if (o === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__.splice(o, 0, {
    name: e,
    enabled: !0,
    fn: t,
    alt: s.alt || []
  }), this.__cache__ = null;
};
le.prototype.after = function(n, e, t, r) {
  var o = this.__find__(n), s = r || {};
  if (o === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__.splice(o + 1, 0, {
    name: e,
    enabled: !0,
    fn: t,
    alt: s.alt || []
  }), this.__cache__ = null;
};
le.prototype.push = function(n, e, t) {
  var r = t || {};
  this.__rules__.push({
    name: n,
    enabled: !0,
    fn: e,
    alt: r.alt || []
  }), this.__cache__ = null;
};
le.prototype.enable = function(n, e) {
  Array.isArray(n) || (n = [n]);
  var t = [];
  return n.forEach(function(r) {
    var o = this.__find__(r);
    if (o < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + r);
    }
    this.__rules__[o].enabled = !0, t.push(r);
  }, this), this.__cache__ = null, t;
};
le.prototype.enableOnly = function(n, e) {
  Array.isArray(n) || (n = [n]), this.__rules__.forEach(function(t) {
    t.enabled = !1;
  }), this.enable(n, e);
};
le.prototype.disable = function(n, e) {
  Array.isArray(n) || (n = [n]);
  var t = [];
  return n.forEach(function(r) {
    var o = this.__find__(r);
    if (o < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + r);
    }
    this.__rules__[o].enabled = !1, t.push(r);
  }, this), this.__cache__ = null, t;
};
le.prototype.getRules = function(n) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[n] || [];
};
var Xn = le, h9 = /\r\n?|\n/g, d9 = /\0/g, g9 = function(e) {
  var t;
  t = e.src.replace(h9, `
`), t = t.replace(d9, "�"), e.src = t;
}, m9 = function(e) {
  var t;
  e.inlineMode ? (t = new e.Token("inline", "", 0), t.content = e.src, t.map = [0, 1], t.children = [], e.tokens.push(t)) : e.md.block.parse(e.src, e.md, e.env, e.tokens);
}, _9 = function(e) {
  var t = e.tokens, r, o, s;
  for (o = 0, s = t.length; o < s; o++)
    r = t[o], r.type === "inline" && e.md.inline.parse(r.content, e.md, e.env, r.children);
}, b9 = $.arrayReplaceAt;
function v9(n) {
  return /^<a[>\s]/i.test(n);
}
function k9(n) {
  return /^<\/a\s*>/i.test(n);
}
var x9 = function(e) {
  var t, r, o, s, i, c, a, l, u, p, f, h, d, g, E, x, b = e.tokens, A;
  if (e.md.options.linkify) {
    for (r = 0, o = b.length; r < o; r++)
      if (!(b[r].type !== "inline" || !e.md.linkify.pretest(b[r].content)))
        for (s = b[r].children, d = 0, t = s.length - 1; t >= 0; t--) {
          if (c = s[t], c.type === "link_close") {
            for (t--; s[t].level !== c.level && s[t].type !== "link_open"; )
              t--;
            continue;
          }
          if (c.type === "html_inline" && (v9(c.content) && d > 0 && d--, k9(c.content) && d++), !(d > 0) && c.type === "text" && e.md.linkify.test(c.content)) {
            for (u = c.content, A = e.md.linkify.match(u), a = [], h = c.level, f = 0, A.length > 0 && A[0].index === 0 && t > 0 && s[t - 1].type === "text_special" && (A = A.slice(1)), l = 0; l < A.length; l++)
              g = A[l].url, E = e.md.normalizeLink(g), e.md.validateLink(E) && (x = A[l].text, A[l].schema ? A[l].schema === "mailto:" && !/^mailto:/i.test(x) ? x = e.md.normalizeLinkText("mailto:" + x).replace(/^mailto:/, "") : x = e.md.normalizeLinkText(x) : x = e.md.normalizeLinkText("http://" + x).replace(/^http:\/\//, ""), p = A[l].index, p > f && (i = new e.Token("text", "", 0), i.content = u.slice(f, p), i.level = h, a.push(i)), i = new e.Token("link_open", "a", 1), i.attrs = [["href", E]], i.level = h++, i.markup = "linkify", i.info = "auto", a.push(i), i = new e.Token("text", "", 0), i.content = x, i.level = h, a.push(i), i = new e.Token("link_close", "a", -1), i.level = --h, i.markup = "linkify", i.info = "auto", a.push(i), f = A[l].lastIndex);
            f < u.length && (i = new e.Token("text", "", 0), i.content = u.slice(f), i.level = h, a.push(i)), b[r].children = s = b9(s, t, a);
          }
        }
  }
}, Gr = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/, y9 = /\((c|tm|r)\)/i, E9 = /\((c|tm|r)\)/ig, w9 = {
  c: "©",
  r: "®",
  tm: "™"
};
function A9(n, e) {
  return w9[e.toLowerCase()];
}
function C9(n) {
  var e, t, r = 0;
  for (e = n.length - 1; e >= 0; e--)
    t = n[e], t.type === "text" && !r && (t.content = t.content.replace(E9, A9)), t.type === "link_open" && t.info === "auto" && r--, t.type === "link_close" && t.info === "auto" && r++;
}
function S9(n) {
  var e, t, r = 0;
  for (e = n.length - 1; e >= 0; e--)
    t = n[e], t.type === "text" && !r && Gr.test(t.content) && (t.content = t.content.replace(/\+-/g, "±").replace(/\.{2,}/g, "…").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1—").replace(/(^|\s)--(?=\s|$)/mg, "$1–").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1–")), t.type === "link_open" && t.info === "auto" && r--, t.type === "link_close" && t.info === "auto" && r++;
}
var D9 = function(e) {
  var t;
  if (e.md.options.typographer)
    for (t = e.tokens.length - 1; t >= 0; t--)
      e.tokens[t].type === "inline" && (y9.test(e.tokens[t].content) && C9(e.tokens[t].children), Gr.test(e.tokens[t].content) && S9(e.tokens[t].children));
}, Ft = $.isWhiteSpace, Bt = $.isPunctChar, Pt = $.isMdAsciiPunct, T9 = /['"]/, $t = /['"]/g, zt = "’";
function Qe(n, e, t) {
  return n.slice(0, e) + t + n.slice(e + 1);
}
function R9(n, e) {
  var t, r, o, s, i, c, a, l, u, p, f, h, d, g, E, x, b, A, D, L, v;
  for (D = [], t = 0; t < n.length; t++) {
    for (r = n[t], a = n[t].level, b = D.length - 1; b >= 0 && !(D[b].level <= a); b--)
      ;
    if (D.length = b + 1, r.type === "text") {
      o = r.content, i = 0, c = o.length;
      e:
        for (; i < c && ($t.lastIndex = i, s = $t.exec(o), !!s); ) {
          if (E = x = !0, i = s.index + 1, A = s[0] === "'", u = 32, s.index - 1 >= 0)
            u = o.charCodeAt(s.index - 1);
          else
            for (b = t - 1; b >= 0 && !(n[b].type === "softbreak" || n[b].type === "hardbreak"); b--)
              if (n[b].content) {
                u = n[b].content.charCodeAt(n[b].content.length - 1);
                break;
              }
          if (p = 32, i < c)
            p = o.charCodeAt(i);
          else
            for (b = t + 1; b < n.length && !(n[b].type === "softbreak" || n[b].type === "hardbreak"); b++)
              if (n[b].content) {
                p = n[b].content.charCodeAt(0);
                break;
              }
          if (f = Pt(u) || Bt(String.fromCharCode(u)), h = Pt(p) || Bt(String.fromCharCode(p)), d = Ft(u), g = Ft(p), g ? E = !1 : h && (d || f || (E = !1)), d ? x = !1 : f && (g || h || (x = !1)), p === 34 && s[0] === '"' && u >= 48 && u <= 57 && (x = E = !1), E && x && (E = f, x = h), !E && !x) {
            A && (r.content = Qe(r.content, s.index, zt));
            continue;
          }
          if (x) {
            for (b = D.length - 1; b >= 0 && (l = D[b], !(D[b].level < a)); b--)
              if (l.single === A && D[b].level === a) {
                l = D[b], A ? (L = e.md.options.quotes[2], v = e.md.options.quotes[3]) : (L = e.md.options.quotes[0], v = e.md.options.quotes[1]), r.content = Qe(r.content, s.index, v), n[l.token].content = Qe(
                  n[l.token].content,
                  l.pos,
                  L
                ), i += v.length - 1, l.token === t && (i += L.length - 1), o = r.content, c = o.length, D.length = b;
                continue e;
              }
          }
          E ? D.push({
            token: t,
            pos: s.index,
            single: A,
            level: a
          }) : x && A && (r.content = Qe(r.content, s.index, zt));
        }
    }
  }
}
var L9 = function(e) {
  var t;
  if (e.md.options.typographer)
    for (t = e.tokens.length - 1; t >= 0; t--)
      e.tokens[t].type !== "inline" || !T9.test(e.tokens[t].content) || R9(e.tokens[t].children, e);
}, N9 = function(e) {
  var t, r, o, s, i, c, a = e.tokens;
  for (t = 0, r = a.length; t < r; t++)
    if (a[t].type === "inline") {
      for (o = a[t].children, i = o.length, s = 0; s < i; s++)
        o[s].type === "text_special" && (o[s].type = "text");
      for (s = c = 0; s < i; s++)
        o[s].type === "text" && s + 1 < i && o[s + 1].type === "text" ? o[s + 1].content = o[s].content + o[s + 1].content : (s !== c && (o[c] = o[s]), c++);
      s !== c && (o.length = c);
    }
};
function Oe(n, e, t) {
  this.type = n, this.tag = e, this.attrs = null, this.map = null, this.nesting = t, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = !1, this.hidden = !1;
}
Oe.prototype.attrIndex = function(e) {
  var t, r, o;
  if (!this.attrs)
    return -1;
  for (t = this.attrs, r = 0, o = t.length; r < o; r++)
    if (t[r][0] === e)
      return r;
  return -1;
};
Oe.prototype.attrPush = function(e) {
  this.attrs ? this.attrs.push(e) : this.attrs = [e];
};
Oe.prototype.attrSet = function(e, t) {
  var r = this.attrIndex(e), o = [e, t];
  r < 0 ? this.attrPush(o) : this.attrs[r] = o;
};
Oe.prototype.attrGet = function(e) {
  var t = this.attrIndex(e), r = null;
  return t >= 0 && (r = this.attrs[t][1]), r;
};
Oe.prototype.attrJoin = function(e, t) {
  var r = this.attrIndex(e);
  r < 0 ? this.attrPush([e, t]) : this.attrs[r][1] = this.attrs[r][1] + " " + t;
};
var Qn = Oe, q9 = Qn;
function jr(n, e, t) {
  this.src = n, this.env = t, this.tokens = [], this.inlineMode = !1, this.md = e;
}
jr.prototype.Token = q9;
var M9 = jr, I9 = Xn, Rn = [
  ["normalize", g9],
  ["block", m9],
  ["inline", _9],
  ["linkify", x9],
  ["replacements", D9],
  ["smartquotes", L9],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", N9]
];
function et() {
  this.ruler = new I9();
  for (var n = 0; n < Rn.length; n++)
    this.ruler.push(Rn[n][0], Rn[n][1]);
}
et.prototype.process = function(n) {
  var e, t, r;
  for (r = this.ruler.getRules(""), e = 0, t = r.length; e < t; e++)
    r[e](n);
};
et.prototype.State = M9;
var O9 = et, Ln = $.isSpace;
function Nn(n, e) {
  var t = n.bMarks[e] + n.tShift[e], r = n.eMarks[e];
  return n.src.slice(t, r);
}
function Ut(n) {
  var e = [], t = 0, r = n.length, o, s = !1, i = 0, c = "";
  for (o = n.charCodeAt(t); t < r; )
    o === 124 && (s ? (c += n.substring(i, t - 1), i = t) : (e.push(c + n.substring(i, t)), c = "", i = t + 1)), s = o === 92, t++, o = n.charCodeAt(t);
  return e.push(c + n.substring(i)), e;
}
var F9 = function(e, t, r, o) {
  var s, i, c, a, l, u, p, f, h, d, g, E, x, b, A, D, L, v;
  if (t + 2 > r || (u = t + 1, e.sCount[u] < e.blkIndent) || e.sCount[u] - e.blkIndent >= 4 || (c = e.bMarks[u] + e.tShift[u], c >= e.eMarks[u]) || (L = e.src.charCodeAt(c++), L !== 124 && L !== 45 && L !== 58) || c >= e.eMarks[u] || (v = e.src.charCodeAt(c++), v !== 124 && v !== 45 && v !== 58 && !Ln(v)) || L === 45 && Ln(v))
    return !1;
  for (; c < e.eMarks[u]; ) {
    if (s = e.src.charCodeAt(c), s !== 124 && s !== 45 && s !== 58 && !Ln(s))
      return !1;
    c++;
  }
  for (i = Nn(e, t + 1), p = i.split("|"), d = [], a = 0; a < p.length; a++) {
    if (g = p[a].trim(), !g) {
      if (a === 0 || a === p.length - 1)
        continue;
      return !1;
    }
    if (!/^:?-+:?$/.test(g))
      return !1;
    g.charCodeAt(g.length - 1) === 58 ? d.push(g.charCodeAt(0) === 58 ? "center" : "right") : g.charCodeAt(0) === 58 ? d.push("left") : d.push("");
  }
  if (i = Nn(e, t).trim(), i.indexOf("|") === -1 || e.sCount[t] - e.blkIndent >= 4 || (p = Ut(i), p.length && p[0] === "" && p.shift(), p.length && p[p.length - 1] === "" && p.pop(), f = p.length, f === 0 || f !== d.length))
    return !1;
  if (o)
    return !0;
  for (b = e.parentType, e.parentType = "table", D = e.md.block.ruler.getRules("blockquote"), h = e.push("table_open", "table", 1), h.map = E = [t, 0], h = e.push("thead_open", "thead", 1), h.map = [t, t + 1], h = e.push("tr_open", "tr", 1), h.map = [t, t + 1], a = 0; a < p.length; a++)
    h = e.push("th_open", "th", 1), d[a] && (h.attrs = [["style", "text-align:" + d[a]]]), h = e.push("inline", "", 0), h.content = p[a].trim(), h.children = [], h = e.push("th_close", "th", -1);
  for (h = e.push("tr_close", "tr", -1), h = e.push("thead_close", "thead", -1), u = t + 2; u < r && !(e.sCount[u] < e.blkIndent); u++) {
    for (A = !1, a = 0, l = D.length; a < l; a++)
      if (D[a](e, u, r, !0)) {
        A = !0;
        break;
      }
    if (A || (i = Nn(e, u).trim(), !i) || e.sCount[u] - e.blkIndent >= 4)
      break;
    for (p = Ut(i), p.length && p[0] === "" && p.shift(), p.length && p[p.length - 1] === "" && p.pop(), u === t + 2 && (h = e.push("tbody_open", "tbody", 1), h.map = x = [t + 2, 0]), h = e.push("tr_open", "tr", 1), h.map = [u, u + 1], a = 0; a < f; a++)
      h = e.push("td_open", "td", 1), d[a] && (h.attrs = [["style", "text-align:" + d[a]]]), h = e.push("inline", "", 0), h.content = p[a] ? p[a].trim() : "", h.children = [], h = e.push("td_close", "td", -1);
    h = e.push("tr_close", "tr", -1);
  }
  return x && (h = e.push("tbody_close", "tbody", -1), x[1] = u), h = e.push("table_close", "table", -1), E[1] = u, e.parentType = b, e.line = u, !0;
}, B9 = function(e, t, r) {
  var o, s, i;
  if (e.sCount[t] - e.blkIndent < 4)
    return !1;
  for (s = o = t + 1; o < r; ) {
    if (e.isEmpty(o)) {
      o++;
      continue;
    }
    if (e.sCount[o] - e.blkIndent >= 4) {
      o++, s = o;
      continue;
    }
    break;
  }
  return e.line = s, i = e.push("code_block", "code", 0), i.content = e.getLines(t, s, 4 + e.blkIndent, !1) + `
`, i.map = [t, e.line], !0;
}, P9 = function(e, t, r, o) {
  var s, i, c, a, l, u, p, f = !1, h = e.bMarks[t] + e.tShift[t], d = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || h + 3 > d || (s = e.src.charCodeAt(h), s !== 126 && s !== 96) || (l = h, h = e.skipChars(h, s), i = h - l, i < 3) || (p = e.src.slice(l, h), c = e.src.slice(h, d), s === 96 && c.indexOf(String.fromCharCode(s)) >= 0))
    return !1;
  if (o)
    return !0;
  for (a = t; a++, !(a >= r || (h = l = e.bMarks[a] + e.tShift[a], d = e.eMarks[a], h < d && e.sCount[a] < e.blkIndent)); )
    if (e.src.charCodeAt(h) === s && !(e.sCount[a] - e.blkIndent >= 4) && (h = e.skipChars(h, s), !(h - l < i) && (h = e.skipSpaces(h), !(h < d)))) {
      f = !0;
      break;
    }
  return i = e.sCount[t], e.line = a + (f ? 1 : 0), u = e.push("fence", "code", 0), u.info = c, u.content = e.getLines(t + 1, a, i, !0), u.markup = p, u.map = [t, e.line], !0;
}, $9 = $.isSpace, z9 = function(e, t, r, o) {
  var s, i, c, a, l, u, p, f, h, d, g, E, x, b, A, D, L, v, O, z, j = e.lineMax, M = e.bMarks[t] + e.tShift[t], K = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || e.src.charCodeAt(M) !== 62)
    return !1;
  if (o)
    return !0;
  for (d = [], g = [], b = [], A = [], v = e.md.block.ruler.getRules("blockquote"), x = e.parentType, e.parentType = "blockquote", f = t; f < r && (z = e.sCount[f] < e.blkIndent, M = e.bMarks[f] + e.tShift[f], K = e.eMarks[f], !(M >= K)); f++) {
    if (e.src.charCodeAt(M++) === 62 && !z) {
      for (a = e.sCount[f] + 1, e.src.charCodeAt(M) === 32 ? (M++, a++, s = !1, D = !0) : e.src.charCodeAt(M) === 9 ? (D = !0, (e.bsCount[f] + a) % 4 === 3 ? (M++, a++, s = !1) : s = !0) : D = !1, h = a, d.push(e.bMarks[f]), e.bMarks[f] = M; M < K && (i = e.src.charCodeAt(M), $9(i)); ) {
        i === 9 ? h += 4 - (h + e.bsCount[f] + (s ? 1 : 0)) % 4 : h++;
        M++;
      }
      u = M >= K, g.push(e.bsCount[f]), e.bsCount[f] = e.sCount[f] + 1 + (D ? 1 : 0), b.push(e.sCount[f]), e.sCount[f] = h - a, A.push(e.tShift[f]), e.tShift[f] = M - e.bMarks[f];
      continue;
    }
    if (u)
      break;
    for (L = !1, c = 0, l = v.length; c < l; c++)
      if (v[c](e, f, r, !0)) {
        L = !0;
        break;
      }
    if (L) {
      e.lineMax = f, e.blkIndent !== 0 && (d.push(e.bMarks[f]), g.push(e.bsCount[f]), A.push(e.tShift[f]), b.push(e.sCount[f]), e.sCount[f] -= e.blkIndent);
      break;
    }
    d.push(e.bMarks[f]), g.push(e.bsCount[f]), A.push(e.tShift[f]), b.push(e.sCount[f]), e.sCount[f] = -1;
  }
  for (E = e.blkIndent, e.blkIndent = 0, O = e.push("blockquote_open", "blockquote", 1), O.markup = ">", O.map = p = [t, 0], e.md.block.tokenize(e, t, f), O = e.push("blockquote_close", "blockquote", -1), O.markup = ">", e.lineMax = j, e.parentType = x, p[1] = e.line, c = 0; c < A.length; c++)
    e.bMarks[c + t] = d[c], e.tShift[c + t] = A[c], e.sCount[c + t] = b[c], e.bsCount[c + t] = g[c];
  return e.blkIndent = E, !0;
}, U9 = $.isSpace, H9 = function(e, t, r, o) {
  var s, i, c, a, l = e.bMarks[t] + e.tShift[t], u = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || (s = e.src.charCodeAt(l++), s !== 42 && s !== 45 && s !== 95))
    return !1;
  for (i = 1; l < u; ) {
    if (c = e.src.charCodeAt(l++), c !== s && !U9(c))
      return !1;
    c === s && i++;
  }
  return i < 3 ? !1 : (o || (e.line = t + 1, a = e.push("hr", "hr", 0), a.map = [t, e.line], a.markup = Array(i + 1).join(String.fromCharCode(s))), !0);
}, Zr = $.isSpace;
function Ht(n, e) {
  var t, r, o, s;
  return r = n.bMarks[e] + n.tShift[e], o = n.eMarks[e], t = n.src.charCodeAt(r++), t !== 42 && t !== 45 && t !== 43 || r < o && (s = n.src.charCodeAt(r), !Zr(s)) ? -1 : r;
}
function Vt(n, e) {
  var t, r = n.bMarks[e] + n.tShift[e], o = r, s = n.eMarks[e];
  if (o + 1 >= s || (t = n.src.charCodeAt(o++), t < 48 || t > 57))
    return -1;
  for (; ; ) {
    if (o >= s)
      return -1;
    if (t = n.src.charCodeAt(o++), t >= 48 && t <= 57) {
      if (o - r >= 10)
        return -1;
      continue;
    }
    if (t === 41 || t === 46)
      break;
    return -1;
  }
  return o < s && (t = n.src.charCodeAt(o), !Zr(t)) ? -1 : o;
}
function V9(n, e) {
  var t, r, o = n.level + 2;
  for (t = e + 2, r = n.tokens.length - 2; t < r; t++)
    n.tokens[t].level === o && n.tokens[t].type === "paragraph_open" && (n.tokens[t + 2].hidden = !0, n.tokens[t].hidden = !0, t += 2);
}
var G9 = function(e, t, r, o) {
  var s, i, c, a, l, u, p, f, h, d, g, E, x, b, A, D, L, v, O, z, j, M, K, q, Z, _, T, w = t, m = !1, k = !0;
  if (e.sCount[w] - e.blkIndent >= 4 || e.listIndent >= 0 && e.sCount[w] - e.listIndent >= 4 && e.sCount[w] < e.blkIndent)
    return !1;
  if (o && e.parentType === "paragraph" && e.sCount[w] >= e.blkIndent && (m = !0), (M = Vt(e, w)) >= 0) {
    if (p = !0, q = e.bMarks[w] + e.tShift[w], x = Number(e.src.slice(q, M - 1)), m && x !== 1)
      return !1;
  } else if ((M = Ht(e, w)) >= 0)
    p = !1;
  else
    return !1;
  if (m && e.skipSpaces(M) >= e.eMarks[w])
    return !1;
  if (o)
    return !0;
  for (E = e.src.charCodeAt(M - 1), g = e.tokens.length, p ? (T = e.push("ordered_list_open", "ol", 1), x !== 1 && (T.attrs = [["start", x]])) : T = e.push("bullet_list_open", "ul", 1), T.map = d = [w, 0], T.markup = String.fromCharCode(E), K = !1, _ = e.md.block.ruler.getRules("list"), L = e.parentType, e.parentType = "list"; w < r; ) {
    for (j = M, b = e.eMarks[w], u = A = e.sCount[w] + M - (e.bMarks[w] + e.tShift[w]); j < b; ) {
      if (s = e.src.charCodeAt(j), s === 9)
        A += 4 - (A + e.bsCount[w]) % 4;
      else if (s === 32)
        A++;
      else
        break;
      j++;
    }
    if (i = j, i >= b ? l = 1 : l = A - u, l > 4 && (l = 1), a = u + l, T = e.push("list_item_open", "li", 1), T.markup = String.fromCharCode(E), T.map = f = [w, 0], p && (T.info = e.src.slice(q, M - 1)), z = e.tight, O = e.tShift[w], v = e.sCount[w], D = e.listIndent, e.listIndent = e.blkIndent, e.blkIndent = a, e.tight = !0, e.tShift[w] = i - e.bMarks[w], e.sCount[w] = A, i >= b && e.isEmpty(w + 1) ? e.line = Math.min(e.line + 2, r) : e.md.block.tokenize(e, w, r, !0), (!e.tight || K) && (k = !1), K = e.line - w > 1 && e.isEmpty(e.line - 1), e.blkIndent = e.listIndent, e.listIndent = D, e.tShift[w] = O, e.sCount[w] = v, e.tight = z, T = e.push("list_item_close", "li", -1), T.markup = String.fromCharCode(E), w = e.line, f[1] = w, w >= r || e.sCount[w] < e.blkIndent || e.sCount[w] - e.blkIndent >= 4)
      break;
    for (Z = !1, c = 0, h = _.length; c < h; c++)
      if (_[c](e, w, r, !0)) {
        Z = !0;
        break;
      }
    if (Z)
      break;
    if (p) {
      if (M = Vt(e, w), M < 0)
        break;
      q = e.bMarks[w] + e.tShift[w];
    } else if (M = Ht(e, w), M < 0)
      break;
    if (E !== e.src.charCodeAt(M - 1))
      break;
  }
  return p ? T = e.push("ordered_list_close", "ol", -1) : T = e.push("bullet_list_close", "ul", -1), T.markup = String.fromCharCode(E), d[1] = w, e.line = w, e.parentType = L, k && V9(e, g), !0;
}, j9 = $.normalizeReference, en = $.isSpace, Z9 = function(e, t, r, o) {
  var s, i, c, a, l, u, p, f, h, d, g, E, x, b, A, D, L = 0, v = e.bMarks[t] + e.tShift[t], O = e.eMarks[t], z = t + 1;
  if (e.sCount[t] - e.blkIndent >= 4 || e.src.charCodeAt(v) !== 91)
    return !1;
  for (; ++v < O; )
    if (e.src.charCodeAt(v) === 93 && e.src.charCodeAt(v - 1) !== 92) {
      if (v + 1 === O || e.src.charCodeAt(v + 1) !== 58)
        return !1;
      break;
    }
  for (a = e.lineMax, A = e.md.block.ruler.getRules("reference"), d = e.parentType, e.parentType = "reference"; z < a && !e.isEmpty(z); z++)
    if (!(e.sCount[z] - e.blkIndent > 3) && !(e.sCount[z] < 0)) {
      for (b = !1, u = 0, p = A.length; u < p; u++)
        if (A[u](e, z, a, !0)) {
          b = !0;
          break;
        }
      if (b)
        break;
    }
  for (x = e.getLines(t, z, e.blkIndent, !1).trim(), O = x.length, v = 1; v < O; v++) {
    if (s = x.charCodeAt(v), s === 91)
      return !1;
    if (s === 93) {
      h = v;
      break;
    } else
      s === 10 ? L++ : s === 92 && (v++, v < O && x.charCodeAt(v) === 10 && L++);
  }
  if (h < 0 || x.charCodeAt(h + 1) !== 58)
    return !1;
  for (v = h + 2; v < O; v++)
    if (s = x.charCodeAt(v), s === 10)
      L++;
    else if (!en(s))
      break;
  if (g = e.md.helpers.parseLinkDestination(x, v, O), !g.ok || (l = e.md.normalizeLink(g.str), !e.md.validateLink(l)))
    return !1;
  for (v = g.pos, L += g.lines, i = v, c = L, E = v; v < O; v++)
    if (s = x.charCodeAt(v), s === 10)
      L++;
    else if (!en(s))
      break;
  for (g = e.md.helpers.parseLinkTitle(x, v, O), v < O && E !== v && g.ok ? (D = g.str, v = g.pos, L += g.lines) : (D = "", v = i, L = c); v < O && (s = x.charCodeAt(v), !!en(s)); )
    v++;
  if (v < O && x.charCodeAt(v) !== 10 && D)
    for (D = "", v = i, L = c; v < O && (s = x.charCodeAt(v), !!en(s)); )
      v++;
  return v < O && x.charCodeAt(v) !== 10 || (f = j9(x.slice(1, h)), !f) ? !1 : (o || (typeof e.env.references > "u" && (e.env.references = {}), typeof e.env.references[f] > "u" && (e.env.references[f] = { title: D, href: l }), e.parentType = d, e.line = t + L + 1), !0);
}, K9 = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "source",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], gn = {}, W9 = "[a-zA-Z_:][a-zA-Z0-9:._-]*", Y9 = "[^\"'=<>`\\x00-\\x20]+", J9 = "'[^']*'", X9 = '"[^"]*"', Q9 = "(?:" + Y9 + "|" + J9 + "|" + X9 + ")", e4 = "(?:\\s+" + W9 + "(?:\\s*=\\s*" + Q9 + ")?)", Kr = "<[A-Za-z][A-Za-z0-9\\-]*" + e4 + "*\\s*\\/?>", Wr = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", n4 = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->", t4 = "<[?][\\s\\S]*?[?]>", r4 = "<![A-Z]+\\s+[^>]*>", o4 = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", s4 = new RegExp("^(?:" + Kr + "|" + Wr + "|" + n4 + "|" + t4 + "|" + r4 + "|" + o4 + ")"), c4 = new RegExp("^(?:" + Kr + "|" + Wr + ")");
gn.HTML_TAG_RE = s4;
gn.HTML_OPEN_CLOSE_TAG_RE = c4;
var i4 = K9, a4 = gn.HTML_OPEN_CLOSE_TAG_RE, Re = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, !0],
  [/^<!--/, /-->/, !0],
  [/^<\?/, /\?>/, !0],
  [/^<![A-Z]/, />/, !0],
  [/^<!\[CDATA\[/, /\]\]>/, !0],
  [new RegExp("^</?(" + i4.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, !0],
  [new RegExp(a4.source + "\\s*$"), /^$/, !1]
], l4 = function(e, t, r, o) {
  var s, i, c, a, l = e.bMarks[t] + e.tShift[t], u = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || !e.md.options.html || e.src.charCodeAt(l) !== 60)
    return !1;
  for (a = e.src.slice(l, u), s = 0; s < Re.length && !Re[s][0].test(a); s++)
    ;
  if (s === Re.length)
    return !1;
  if (o)
    return Re[s][2];
  if (i = t + 1, !Re[s][1].test(a)) {
    for (; i < r && !(e.sCount[i] < e.blkIndent); i++)
      if (l = e.bMarks[i] + e.tShift[i], u = e.eMarks[i], a = e.src.slice(l, u), Re[s][1].test(a)) {
        a.length !== 0 && i++;
        break;
      }
  }
  return e.line = i, c = e.push("html_block", "", 0), c.map = [t, i], c.content = e.getLines(t, i, e.blkIndent, !0), !0;
}, Gt = $.isSpace, u4 = function(e, t, r, o) {
  var s, i, c, a, l = e.bMarks[t] + e.tShift[t], u = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || (s = e.src.charCodeAt(l), s !== 35 || l >= u))
    return !1;
  for (i = 1, s = e.src.charCodeAt(++l); s === 35 && l < u && i <= 6; )
    i++, s = e.src.charCodeAt(++l);
  return i > 6 || l < u && !Gt(s) ? !1 : (o || (u = e.skipSpacesBack(u, l), c = e.skipCharsBack(u, 35, l), c > l && Gt(e.src.charCodeAt(c - 1)) && (u = c), e.line = t + 1, a = e.push("heading_open", "h" + String(i), 1), a.markup = "########".slice(0, i), a.map = [t, e.line], a = e.push("inline", "", 0), a.content = e.src.slice(l, u).trim(), a.map = [t, e.line], a.children = [], a = e.push("heading_close", "h" + String(i), -1), a.markup = "########".slice(0, i)), !0);
}, f4 = function(e, t, r) {
  var o, s, i, c, a, l, u, p, f, h = t + 1, d, g = e.md.block.ruler.getRules("paragraph");
  if (e.sCount[t] - e.blkIndent >= 4)
    return !1;
  for (d = e.parentType, e.parentType = "paragraph"; h < r && !e.isEmpty(h); h++)
    if (!(e.sCount[h] - e.blkIndent > 3)) {
      if (e.sCount[h] >= e.blkIndent && (l = e.bMarks[h] + e.tShift[h], u = e.eMarks[h], l < u && (f = e.src.charCodeAt(l), (f === 45 || f === 61) && (l = e.skipChars(l, f), l = e.skipSpaces(l), l >= u)))) {
        p = f === 61 ? 1 : 2;
        break;
      }
      if (!(e.sCount[h] < 0)) {
        for (s = !1, i = 0, c = g.length; i < c; i++)
          if (g[i](e, h, r, !0)) {
            s = !0;
            break;
          }
        if (s)
          break;
      }
    }
  return p ? (o = e.getLines(t, h, e.blkIndent, !1).trim(), e.line = h + 1, a = e.push("heading_open", "h" + String(p), 1), a.markup = String.fromCharCode(f), a.map = [t, e.line], a = e.push("inline", "", 0), a.content = o, a.map = [t, e.line - 1], a.children = [], a = e.push("heading_close", "h" + String(p), -1), a.markup = String.fromCharCode(f), e.parentType = d, !0) : !1;
}, p4 = function(e, t, r) {
  var o, s, i, c, a, l, u = t + 1, p = e.md.block.ruler.getRules("paragraph");
  for (l = e.parentType, e.parentType = "paragraph"; u < r && !e.isEmpty(u); u++)
    if (!(e.sCount[u] - e.blkIndent > 3) && !(e.sCount[u] < 0)) {
      for (s = !1, i = 0, c = p.length; i < c; i++)
        if (p[i](e, u, r, !0)) {
          s = !0;
          break;
        }
      if (s)
        break;
    }
  return o = e.getLines(t, u, e.blkIndent, !1).trim(), e.line = u, a = e.push("paragraph_open", "p", 1), a.map = [t, e.line], a = e.push("inline", "", 0), a.content = o, a.map = [t, e.line], a.children = [], a = e.push("paragraph_close", "p", -1), e.parentType = l, !0;
}, Yr = Qn, mn = $.isSpace;
function me(n, e, t, r) {
  var o, s, i, c, a, l, u, p;
  for (this.src = n, this.md = e, this.env = t, this.tokens = r, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = !1, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0, this.result = "", s = this.src, p = !1, i = c = l = u = 0, a = s.length; c < a; c++) {
    if (o = s.charCodeAt(c), !p)
      if (mn(o)) {
        l++, o === 9 ? u += 4 - u % 4 : u++;
        continue;
      } else
        p = !0;
    (o === 10 || c === a - 1) && (o !== 10 && c++, this.bMarks.push(i), this.eMarks.push(c), this.tShift.push(l), this.sCount.push(u), this.bsCount.push(0), p = !1, l = 0, u = 0, i = c + 1);
  }
  this.bMarks.push(s.length), this.eMarks.push(s.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
me.prototype.push = function(n, e, t) {
  var r = new Yr(n, e, t);
  return r.block = !0, t < 0 && this.level--, r.level = this.level, t > 0 && this.level++, this.tokens.push(r), r;
};
me.prototype.isEmpty = function(e) {
  return this.bMarks[e] + this.tShift[e] >= this.eMarks[e];
};
me.prototype.skipEmptyLines = function(e) {
  for (var t = this.lineMax; e < t && !(this.bMarks[e] + this.tShift[e] < this.eMarks[e]); e++)
    ;
  return e;
};
me.prototype.skipSpaces = function(e) {
  for (var t, r = this.src.length; e < r && (t = this.src.charCodeAt(e), !!mn(t)); e++)
    ;
  return e;
};
me.prototype.skipSpacesBack = function(e, t) {
  if (e <= t)
    return e;
  for (; e > t; )
    if (!mn(this.src.charCodeAt(--e)))
      return e + 1;
  return e;
};
me.prototype.skipChars = function(e, t) {
  for (var r = this.src.length; e < r && this.src.charCodeAt(e) === t; e++)
    ;
  return e;
};
me.prototype.skipCharsBack = function(e, t, r) {
  if (e <= r)
    return e;
  for (; e > r; )
    if (t !== this.src.charCodeAt(--e))
      return e + 1;
  return e;
};
me.prototype.getLines = function(e, t, r, o) {
  var s, i, c, a, l, u, p, f = e;
  if (e >= t)
    return "";
  for (u = new Array(t - e), s = 0; f < t; f++, s++) {
    for (i = 0, p = a = this.bMarks[f], f + 1 < t || o ? l = this.eMarks[f] + 1 : l = this.eMarks[f]; a < l && i < r; ) {
      if (c = this.src.charCodeAt(a), mn(c))
        c === 9 ? i += 4 - (i + this.bsCount[f]) % 4 : i++;
      else if (a - p < this.tShift[f])
        i++;
      else
        break;
      a++;
    }
    i > r ? u[s] = new Array(i - r + 1).join(" ") + this.src.slice(a, l) : u[s] = this.src.slice(a, l);
  }
  return u.join("");
};
me.prototype.Token = Yr;
var h4 = me, d4 = Xn, nn = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", F9, ["paragraph", "reference"]],
  ["code", B9],
  ["fence", P9, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", z9, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", H9, ["paragraph", "reference", "blockquote", "list"]],
  ["list", G9, ["paragraph", "reference", "blockquote"]],
  ["reference", Z9],
  ["html_block", l4, ["paragraph", "reference", "blockquote"]],
  ["heading", u4, ["paragraph", "reference", "blockquote"]],
  ["lheading", f4],
  ["paragraph", p4]
];
function _n() {
  this.ruler = new d4();
  for (var n = 0; n < nn.length; n++)
    this.ruler.push(nn[n][0], nn[n][1], { alt: (nn[n][2] || []).slice() });
}
_n.prototype.tokenize = function(n, e, t) {
  for (var r, o, s, i = this.ruler.getRules(""), c = i.length, a = e, l = !1, u = n.md.options.maxNesting; a < t && (n.line = a = n.skipEmptyLines(a), !(a >= t || n.sCount[a] < n.blkIndent)); ) {
    if (n.level >= u) {
      n.line = t;
      break;
    }
    for (s = n.line, o = 0; o < c; o++)
      if (r = i[o](n, a, t, !1), r) {
        if (s >= n.line)
          throw new Error("block rule didn't increment state.line");
        break;
      }
    if (!r)
      throw new Error("none of the block rules matched");
    n.tight = !l, n.isEmpty(n.line - 1) && (l = !0), a = n.line, a < t && n.isEmpty(a) && (l = !0, a++, n.line = a);
  }
};
_n.prototype.parse = function(n, e, t, r) {
  var o;
  n && (o = new this.State(n, e, t, r), this.tokenize(o, o.line, o.lineMax));
};
_n.prototype.State = h4;
var g4 = _n;
function m4(n) {
  switch (n) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return !0;
    default:
      return !1;
  }
}
var _4 = function(e, t) {
  for (var r = e.pos; r < e.posMax && !m4(e.src.charCodeAt(r)); )
    r++;
  return r === e.pos ? !1 : (t || (e.pending += e.src.slice(e.pos, r)), e.pos = r, !0);
}, b4 = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i, v4 = function(e, t) {
  var r, o, s, i, c, a, l, u;
  return !e.md.options.linkify || e.linkLevel > 0 || (r = e.pos, o = e.posMax, r + 3 > o) || e.src.charCodeAt(r) !== 58 || e.src.charCodeAt(r + 1) !== 47 || e.src.charCodeAt(r + 2) !== 47 || (s = e.pending.match(b4), !s) || (i = s[1], c = e.md.linkify.matchAtStart(e.src.slice(r - i.length)), !c) || (a = c.url, a.length <= i.length) || (a = a.replace(/\*+$/, ""), l = e.md.normalizeLink(a), !e.md.validateLink(l)) ? !1 : (t || (e.pending = e.pending.slice(0, -i.length), u = e.push("link_open", "a", 1), u.attrs = [["href", l]], u.markup = "linkify", u.info = "auto", u = e.push("text", "", 0), u.content = e.md.normalizeLinkText(a), u = e.push("link_close", "a", -1), u.markup = "linkify", u.info = "auto"), e.pos += a.length - i.length, !0);
}, k4 = $.isSpace, x4 = function(e, t) {
  var r, o, s, i = e.pos;
  if (e.src.charCodeAt(i) !== 10)
    return !1;
  if (r = e.pending.length - 1, o = e.posMax, !t)
    if (r >= 0 && e.pending.charCodeAt(r) === 32)
      if (r >= 1 && e.pending.charCodeAt(r - 1) === 32) {
        for (s = r - 1; s >= 1 && e.pending.charCodeAt(s - 1) === 32; )
          s--;
        e.pending = e.pending.slice(0, s), e.push("hardbreak", "br", 0);
      } else
        e.pending = e.pending.slice(0, -1), e.push("softbreak", "br", 0);
    else
      e.push("softbreak", "br", 0);
  for (i++; i < o && k4(e.src.charCodeAt(i)); )
    i++;
  return e.pos = i, !0;
}, y4 = $.isSpace, nt = [];
for (var jt = 0; jt < 256; jt++)
  nt.push(0);
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(n) {
  nt[n.charCodeAt(0)] = 1;
});
var E4 = function(e, t) {
  var r, o, s, i, c, a = e.pos, l = e.posMax;
  if (e.src.charCodeAt(a) !== 92 || (a++, a >= l))
    return !1;
  if (r = e.src.charCodeAt(a), r === 10) {
    for (t || e.push("hardbreak", "br", 0), a++; a < l && (r = e.src.charCodeAt(a), !!y4(r)); )
      a++;
    return e.pos = a, !0;
  }
  return i = e.src[a], r >= 55296 && r <= 56319 && a + 1 < l && (o = e.src.charCodeAt(a + 1), o >= 56320 && o <= 57343 && (i += e.src[a + 1], a++)), s = "\\" + i, t || (c = e.push("text_special", "", 0), r < 256 && nt[r] !== 0 ? c.content = i : c.content = s, c.markup = s, c.info = "escape"), e.pos = a + 1, !0;
}, w4 = function(e, t) {
  var r, o, s, i, c, a, l, u, p = e.pos, f = e.src.charCodeAt(p);
  if (f !== 96)
    return !1;
  for (r = p, p++, o = e.posMax; p < o && e.src.charCodeAt(p) === 96; )
    p++;
  if (s = e.src.slice(r, p), l = s.length, e.backticksScanned && (e.backticks[l] || 0) <= r)
    return t || (e.pending += s), e.pos += l, !0;
  for (a = p; (c = e.src.indexOf("`", a)) !== -1; ) {
    for (a = c + 1; a < o && e.src.charCodeAt(a) === 96; )
      a++;
    if (u = a - c, u === l)
      return t || (i = e.push("code_inline", "code", 0), i.markup = s, i.content = e.src.slice(p, c).replace(/\n/g, " ").replace(/^ (.+) $/, "$1")), e.pos = a, !0;
    e.backticks[u] = c;
  }
  return e.backticksScanned = !0, t || (e.pending += s), e.pos += l, !0;
}, bn = {};
bn.tokenize = function(e, t) {
  var r, o, s, i, c, a = e.pos, l = e.src.charCodeAt(a);
  if (t || l !== 126 || (o = e.scanDelims(e.pos, !0), i = o.length, c = String.fromCharCode(l), i < 2))
    return !1;
  for (i % 2 && (s = e.push("text", "", 0), s.content = c, i--), r = 0; r < i; r += 2)
    s = e.push("text", "", 0), s.content = c + c, e.delimiters.push({
      marker: l,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: e.tokens.length - 1,
      end: -1,
      open: o.can_open,
      close: o.can_close
    });
  return e.pos += o.length, !0;
};
function Zt(n, e) {
  var t, r, o, s, i, c = [], a = e.length;
  for (t = 0; t < a; t++)
    o = e[t], o.marker === 126 && o.end !== -1 && (s = e[o.end], i = n.tokens[o.token], i.type = "s_open", i.tag = "s", i.nesting = 1, i.markup = "~~", i.content = "", i = n.tokens[s.token], i.type = "s_close", i.tag = "s", i.nesting = -1, i.markup = "~~", i.content = "", n.tokens[s.token - 1].type === "text" && n.tokens[s.token - 1].content === "~" && c.push(s.token - 1));
  for (; c.length; ) {
    for (t = c.pop(), r = t + 1; r < n.tokens.length && n.tokens[r].type === "s_close"; )
      r++;
    r--, t !== r && (i = n.tokens[r], n.tokens[r] = n.tokens[t], n.tokens[t] = i);
  }
}
bn.postProcess = function(e) {
  var t, r = e.tokens_meta, o = e.tokens_meta.length;
  for (Zt(e, e.delimiters), t = 0; t < o; t++)
    r[t] && r[t].delimiters && Zt(e, r[t].delimiters);
};
var vn = {};
vn.tokenize = function(e, t) {
  var r, o, s, i = e.pos, c = e.src.charCodeAt(i);
  if (t || c !== 95 && c !== 42)
    return !1;
  for (o = e.scanDelims(e.pos, c === 42), r = 0; r < o.length; r++)
    s = e.push("text", "", 0), s.content = String.fromCharCode(c), e.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: c,
      // Total length of these series of delimiters.
      //
      length: o.length,
      // A position of the token this delimiter corresponds to.
      //
      token: e.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: o.can_open,
      close: o.can_close
    });
  return e.pos += o.length, !0;
};
function Kt(n, e) {
  var t, r, o, s, i, c, a = e.length;
  for (t = a - 1; t >= 0; t--)
    r = e[t], !(r.marker !== 95 && r.marker !== 42) && r.end !== -1 && (o = e[r.end], c = t > 0 && e[t - 1].end === r.end + 1 && // check that first two markers match and adjacent
    e[t - 1].marker === r.marker && e[t - 1].token === r.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    e[r.end + 1].token === o.token + 1, i = String.fromCharCode(r.marker), s = n.tokens[r.token], s.type = c ? "strong_open" : "em_open", s.tag = c ? "strong" : "em", s.nesting = 1, s.markup = c ? i + i : i, s.content = "", s = n.tokens[o.token], s.type = c ? "strong_close" : "em_close", s.tag = c ? "strong" : "em", s.nesting = -1, s.markup = c ? i + i : i, s.content = "", c && (n.tokens[e[t - 1].token].content = "", n.tokens[e[r.end + 1].token].content = "", t--));
}
vn.postProcess = function(e) {
  var t, r = e.tokens_meta, o = e.tokens_meta.length;
  for (Kt(e, e.delimiters), t = 0; t < o; t++)
    r[t] && r[t].delimiters && Kt(e, r[t].delimiters);
};
var A4 = $.normalizeReference, qn = $.isSpace, C4 = function(e, t) {
  var r, o, s, i, c, a, l, u, p, f = "", h = "", d = e.pos, g = e.posMax, E = e.pos, x = !0;
  if (e.src.charCodeAt(e.pos) !== 91 || (c = e.pos + 1, i = e.md.helpers.parseLinkLabel(e, e.pos, !0), i < 0))
    return !1;
  if (a = i + 1, a < g && e.src.charCodeAt(a) === 40) {
    for (x = !1, a++; a < g && (o = e.src.charCodeAt(a), !(!qn(o) && o !== 10)); a++)
      ;
    if (a >= g)
      return !1;
    if (E = a, l = e.md.helpers.parseLinkDestination(e.src, a, e.posMax), l.ok) {
      for (f = e.md.normalizeLink(l.str), e.md.validateLink(f) ? a = l.pos : f = "", E = a; a < g && (o = e.src.charCodeAt(a), !(!qn(o) && o !== 10)); a++)
        ;
      if (l = e.md.helpers.parseLinkTitle(e.src, a, e.posMax), a < g && E !== a && l.ok)
        for (h = l.str, a = l.pos; a < g && (o = e.src.charCodeAt(a), !(!qn(o) && o !== 10)); a++)
          ;
    }
    (a >= g || e.src.charCodeAt(a) !== 41) && (x = !0), a++;
  }
  if (x) {
    if (typeof e.env.references > "u")
      return !1;
    if (a < g && e.src.charCodeAt(a) === 91 ? (E = a + 1, a = e.md.helpers.parseLinkLabel(e, a), a >= 0 ? s = e.src.slice(E, a++) : a = i + 1) : a = i + 1, s || (s = e.src.slice(c, i)), u = e.env.references[A4(s)], !u)
      return e.pos = d, !1;
    f = u.href, h = u.title;
  }
  return t || (e.pos = c, e.posMax = i, p = e.push("link_open", "a", 1), p.attrs = r = [["href", f]], h && r.push(["title", h]), e.linkLevel++, e.md.inline.tokenize(e), e.linkLevel--, p = e.push("link_close", "a", -1)), e.pos = a, e.posMax = g, !0;
}, S4 = $.normalizeReference, Mn = $.isSpace, D4 = function(e, t) {
  var r, o, s, i, c, a, l, u, p, f, h, d, g, E = "", x = e.pos, b = e.posMax;
  if (e.src.charCodeAt(e.pos) !== 33 || e.src.charCodeAt(e.pos + 1) !== 91 || (a = e.pos + 2, c = e.md.helpers.parseLinkLabel(e, e.pos + 1, !1), c < 0))
    return !1;
  if (l = c + 1, l < b && e.src.charCodeAt(l) === 40) {
    for (l++; l < b && (o = e.src.charCodeAt(l), !(!Mn(o) && o !== 10)); l++)
      ;
    if (l >= b)
      return !1;
    for (g = l, p = e.md.helpers.parseLinkDestination(e.src, l, e.posMax), p.ok && (E = e.md.normalizeLink(p.str), e.md.validateLink(E) ? l = p.pos : E = ""), g = l; l < b && (o = e.src.charCodeAt(l), !(!Mn(o) && o !== 10)); l++)
      ;
    if (p = e.md.helpers.parseLinkTitle(e.src, l, e.posMax), l < b && g !== l && p.ok)
      for (f = p.str, l = p.pos; l < b && (o = e.src.charCodeAt(l), !(!Mn(o) && o !== 10)); l++)
        ;
    else
      f = "";
    if (l >= b || e.src.charCodeAt(l) !== 41)
      return e.pos = x, !1;
    l++;
  } else {
    if (typeof e.env.references > "u")
      return !1;
    if (l < b && e.src.charCodeAt(l) === 91 ? (g = l + 1, l = e.md.helpers.parseLinkLabel(e, l), l >= 0 ? i = e.src.slice(g, l++) : l = c + 1) : l = c + 1, i || (i = e.src.slice(a, c)), u = e.env.references[S4(i)], !u)
      return e.pos = x, !1;
    E = u.href, f = u.title;
  }
  return t || (s = e.src.slice(a, c), e.md.inline.parse(
    s,
    e.md,
    e.env,
    d = []
  ), h = e.push("image", "img", 0), h.attrs = r = [["src", E], ["alt", ""]], h.children = d, h.content = s, f && r.push(["title", f])), e.pos = l, e.posMax = b, !0;
}, T4 = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/, R4 = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/, L4 = function(e, t) {
  var r, o, s, i, c, a, l = e.pos;
  if (e.src.charCodeAt(l) !== 60)
    return !1;
  for (c = e.pos, a = e.posMax; ; ) {
    if (++l >= a || (i = e.src.charCodeAt(l), i === 60))
      return !1;
    if (i === 62)
      break;
  }
  return r = e.src.slice(c + 1, l), R4.test(r) ? (o = e.md.normalizeLink(r), e.md.validateLink(o) ? (t || (s = e.push("link_open", "a", 1), s.attrs = [["href", o]], s.markup = "autolink", s.info = "auto", s = e.push("text", "", 0), s.content = e.md.normalizeLinkText(r), s = e.push("link_close", "a", -1), s.markup = "autolink", s.info = "auto"), e.pos += r.length + 2, !0) : !1) : T4.test(r) ? (o = e.md.normalizeLink("mailto:" + r), e.md.validateLink(o) ? (t || (s = e.push("link_open", "a", 1), s.attrs = [["href", o]], s.markup = "autolink", s.info = "auto", s = e.push("text", "", 0), s.content = e.md.normalizeLinkText(r), s = e.push("link_close", "a", -1), s.markup = "autolink", s.info = "auto"), e.pos += r.length + 2, !0) : !1) : !1;
}, N4 = gn.HTML_TAG_RE;
function q4(n) {
  return /^<a[>\s]/i.test(n);
}
function M4(n) {
  return /^<\/a\s*>/i.test(n);
}
function I4(n) {
  var e = n | 32;
  return e >= 97 && e <= 122;
}
var O4 = function(e, t) {
  var r, o, s, i, c = e.pos;
  return !e.md.options.html || (s = e.posMax, e.src.charCodeAt(c) !== 60 || c + 2 >= s) || (r = e.src.charCodeAt(c + 1), r !== 33 && r !== 63 && r !== 47 && !I4(r)) || (o = e.src.slice(c).match(N4), !o) ? !1 : (t || (i = e.push("html_inline", "", 0), i.content = o[0], q4(i.content) && e.linkLevel++, M4(i.content) && e.linkLevel--), e.pos += o[0].length, !0);
}, Wt = zr, F4 = $.has, B4 = $.isValidEntityCode, Yt = $.fromCodePoint, P4 = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i, $4 = /^&([a-z][a-z0-9]{1,31});/i, z4 = function(e, t) {
  var r, o, s, i, c = e.pos, a = e.posMax;
  if (e.src.charCodeAt(c) !== 38 || c + 1 >= a)
    return !1;
  if (r = e.src.charCodeAt(c + 1), r === 35) {
    if (s = e.src.slice(c).match(P4), s)
      return t || (o = s[1][0].toLowerCase() === "x" ? parseInt(s[1].slice(1), 16) : parseInt(s[1], 10), i = e.push("text_special", "", 0), i.content = B4(o) ? Yt(o) : Yt(65533), i.markup = s[0], i.info = "entity"), e.pos += s[0].length, !0;
  } else if (s = e.src.slice(c).match($4), s && F4(Wt, s[1]))
    return t || (i = e.push("text_special", "", 0), i.content = Wt[s[1]], i.markup = s[0], i.info = "entity"), e.pos += s[0].length, !0;
  return !1;
};
function Jt(n) {
  var e, t, r, o, s, i, c, a, l = {}, u = n.length;
  if (u) {
    var p = 0, f = -2, h = [];
    for (e = 0; e < u; e++)
      if (r = n[e], h.push(0), (n[p].marker !== r.marker || f !== r.token - 1) && (p = e), f = r.token, r.length = r.length || 0, !!r.close) {
        for (l.hasOwnProperty(r.marker) || (l[r.marker] = [-1, -1, -1, -1, -1, -1]), s = l[r.marker][(r.open ? 3 : 0) + r.length % 3], t = p - h[p] - 1, i = t; t > s; t -= h[t] + 1)
          if (o = n[t], o.marker === r.marker && o.open && o.end < 0 && (c = !1, (o.close || r.open) && (o.length + r.length) % 3 === 0 && (o.length % 3 !== 0 || r.length % 3 !== 0) && (c = !0), !c)) {
            a = t > 0 && !n[t - 1].open ? h[t - 1] + 1 : 0, h[e] = e - t + a, h[t] = a, r.open = !1, o.end = e, o.close = !1, i = -1, f = -2;
            break;
          }
        i !== -1 && (l[r.marker][(r.open ? 3 : 0) + (r.length || 0) % 3] = i);
      }
  }
}
var U4 = function(e) {
  var t, r = e.tokens_meta, o = e.tokens_meta.length;
  for (Jt(e.delimiters), t = 0; t < o; t++)
    r[t] && r[t].delimiters && Jt(r[t].delimiters);
}, H4 = function(e) {
  var t, r, o = 0, s = e.tokens, i = e.tokens.length;
  for (t = r = 0; t < i; t++)
    s[t].nesting < 0 && o--, s[t].level = o, s[t].nesting > 0 && o++, s[t].type === "text" && t + 1 < i && s[t + 1].type === "text" ? s[t + 1].content = s[t].content + s[t + 1].content : (t !== r && (s[r] = s[t]), r++);
  t !== r && (s.length = r);
}, tt = Qn, Xt = $.isWhiteSpace, Qt = $.isPunctChar, er = $.isMdAsciiPunct;
function je(n, e, t, r) {
  this.src = n, this.env = t, this.md = e, this.tokens = r, this.tokens_meta = Array(r.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = !1, this.linkLevel = 0;
}
je.prototype.pushPending = function() {
  var n = new tt("text", "", 0);
  return n.content = this.pending, n.level = this.pendingLevel, this.tokens.push(n), this.pending = "", n;
};
je.prototype.push = function(n, e, t) {
  this.pending && this.pushPending();
  var r = new tt(n, e, t), o = null;
  return t < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), r.level = this.level, t > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], o = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(r), this.tokens_meta.push(o), r;
};
je.prototype.scanDelims = function(n, e) {
  var t = n, r, o, s, i, c, a, l, u, p, f = !0, h = !0, d = this.posMax, g = this.src.charCodeAt(n);
  for (r = n > 0 ? this.src.charCodeAt(n - 1) : 32; t < d && this.src.charCodeAt(t) === g; )
    t++;
  return s = t - n, o = t < d ? this.src.charCodeAt(t) : 32, l = er(r) || Qt(String.fromCharCode(r)), p = er(o) || Qt(String.fromCharCode(o)), a = Xt(r), u = Xt(o), u ? f = !1 : p && (a || l || (f = !1)), a ? h = !1 : l && (u || p || (h = !1)), e ? (i = f, c = h) : (i = f && (!h || l), c = h && (!f || p)), {
    can_open: i,
    can_close: c,
    length: s
  };
};
je.prototype.Token = tt;
var V4 = je, nr = Xn, In = [
  ["text", _4],
  ["linkify", v4],
  ["newline", x4],
  ["escape", E4],
  ["backticks", w4],
  ["strikethrough", bn.tokenize],
  ["emphasis", vn.tokenize],
  ["link", C4],
  ["image", D4],
  ["autolink", L4],
  ["html_inline", O4],
  ["entity", z4]
], On = [
  ["balance_pairs", U4],
  ["strikethrough", bn.postProcess],
  ["emphasis", vn.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", H4]
];
function Ze() {
  var n;
  for (this.ruler = new nr(), n = 0; n < In.length; n++)
    this.ruler.push(In[n][0], In[n][1]);
  for (this.ruler2 = new nr(), n = 0; n < On.length; n++)
    this.ruler2.push(On[n][0], On[n][1]);
}
Ze.prototype.skipToken = function(n) {
  var e, t, r = n.pos, o = this.ruler.getRules(""), s = o.length, i = n.md.options.maxNesting, c = n.cache;
  if (typeof c[r] < "u") {
    n.pos = c[r];
    return;
  }
  if (n.level < i) {
    for (t = 0; t < s; t++)
      if (n.level++, e = o[t](n, !0), n.level--, e) {
        if (r >= n.pos)
          throw new Error("inline rule didn't increment state.pos");
        break;
      }
  } else
    n.pos = n.posMax;
  e || n.pos++, c[r] = n.pos;
};
Ze.prototype.tokenize = function(n) {
  for (var e, t, r, o = this.ruler.getRules(""), s = o.length, i = n.posMax, c = n.md.options.maxNesting; n.pos < i; ) {
    if (r = n.pos, n.level < c) {
      for (t = 0; t < s; t++)
        if (e = o[t](n, !1), e) {
          if (r >= n.pos)
            throw new Error("inline rule didn't increment state.pos");
          break;
        }
    }
    if (e) {
      if (n.pos >= i)
        break;
      continue;
    }
    n.pending += n.src[n.pos++];
  }
  n.pending && n.pushPending();
};
Ze.prototype.parse = function(n, e, t, r) {
  var o, s, i, c = new this.State(n, e, t, r);
  for (this.tokenize(c), s = this.ruler2.getRules(""), i = s.length, o = 0; o < i; o++)
    s[o](c);
};
Ze.prototype.State = V4;
var G4 = Ze, Fn, tr;
function j4() {
  return tr || (tr = 1, Fn = function(n) {
    var e = {};
    n = n || {}, e.src_Any = Ur().source, e.src_Cc = Hr().source, e.src_Z = Vr().source, e.src_P = Jn.source, e.src_ZPCc = [e.src_Z, e.src_P, e.src_Cc].join("|"), e.src_ZCc = [e.src_Z, e.src_Cc].join("|");
    var t = "[><｜]";
    return e.src_pseudo_letter = "(?:(?!" + t + "|" + e.src_ZPCc + ")" + e.src_Any + ")", e.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", e.src_auth = "(?:(?:(?!" + e.src_ZCc + "|[@/\\[\\]()]).)+@)?", e.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", e.src_host_terminator = "(?=$|" + t + "|" + e.src_ZPCc + ")(?!" + (n["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + e.src_ZPCc + "))", e.src_path = "(?:[/?#](?:(?!" + e.src_ZCc + "|" + t + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + e.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + e.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + e.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + e.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + e.src_ZCc + "|[']).)+\\'|\\'(?=" + e.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + e.src_ZCc + "|[.]|$)|" + (n["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + e.src_ZCc + "|$)|;(?!" + e.src_ZCc + "|$)|\\!+(?!" + e.src_ZCc + "|[!]|$)|\\?(?!" + e.src_ZCc + "|[?]|$))+|\\/)?", e.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', e.src_xn = "xn--[a-z0-9\\-]{1,59}", e.src_domain_root = // Allow letters & digits (http://test1)
    "(?:" + e.src_xn + "|" + e.src_pseudo_letter + "{1,63})", e.src_domain = "(?:" + e.src_xn + "|(?:" + e.src_pseudo_letter + ")|(?:" + e.src_pseudo_letter + "(?:-|" + e.src_pseudo_letter + "){0,61}" + e.src_pseudo_letter + "))", e.src_host = "(?:(?:(?:(?:" + e.src_domain + ")\\.)*" + e.src_domain + "))", e.tpl_host_fuzzy = "(?:" + e.src_ip4 + "|(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%)))", e.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%))", e.src_host_strict = e.src_host + e.src_host_terminator, e.tpl_host_fuzzy_strict = e.tpl_host_fuzzy + e.src_host_terminator, e.src_host_port_strict = e.src_host + e.src_port + e.src_host_terminator, e.tpl_host_port_fuzzy_strict = e.tpl_host_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_port_no_ip_fuzzy_strict = e.tpl_host_no_ip_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + e.src_ZPCc + "|>|$))", e.tpl_email_fuzzy = "(^|" + t + '|"|\\(|' + e.src_ZCc + ")(" + e.src_email_name + "@" + e.tpl_host_fuzzy_strict + ")", e.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + e.src_ZPCc + "))((?![$+<=>^`|｜])" + e.tpl_host_port_fuzzy_strict + e.src_path + ")", e.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + e.src_ZPCc + "))((?![$+<=>^`|｜])" + e.tpl_host_port_no_ip_fuzzy_strict + e.src_path + ")", e;
  }), Fn;
}
function zn(n) {
  var e = Array.prototype.slice.call(arguments, 1);
  return e.forEach(function(t) {
    t && Object.keys(t).forEach(function(r) {
      n[r] = t[r];
    });
  }), n;
}
function kn(n) {
  return Object.prototype.toString.call(n);
}
function Z4(n) {
  return kn(n) === "[object String]";
}
function K4(n) {
  return kn(n) === "[object Object]";
}
function W4(n) {
  return kn(n) === "[object RegExp]";
}
function rr(n) {
  return kn(n) === "[object Function]";
}
function Y4(n) {
  return n.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var Jr = {
  fuzzyLink: !0,
  fuzzyEmail: !0,
  fuzzyIP: !1
};
function J4(n) {
  return Object.keys(n || {}).reduce(function(e, t) {
    return e || Jr.hasOwnProperty(t);
  }, !1);
}
var X4 = {
  "http:": {
    validate: function(n, e, t) {
      var r = n.slice(e);
      return t.re.http || (t.re.http = new RegExp(
        "^\\/\\/" + t.re.src_auth + t.re.src_host_port_strict + t.re.src_path,
        "i"
      )), t.re.http.test(r) ? r.match(t.re.http)[0].length : 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(n, e, t) {
      var r = n.slice(e);
      return t.re.no_http || (t.re.no_http = new RegExp(
        "^" + t.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        "(?:localhost|(?:(?:" + t.re.src_domain + ")\\.)+" + t.re.src_domain_root + ")" + t.re.src_port + t.re.src_host_terminator + t.re.src_path,
        "i"
      )), t.re.no_http.test(r) ? e >= 3 && n[e - 3] === ":" || e >= 3 && n[e - 3] === "/" ? 0 : r.match(t.re.no_http)[0].length : 0;
    }
  },
  "mailto:": {
    validate: function(n, e, t) {
      var r = n.slice(e);
      return t.re.mailto || (t.re.mailto = new RegExp(
        "^" + t.re.src_email_name + "@" + t.re.src_host_strict,
        "i"
      )), t.re.mailto.test(r) ? r.match(t.re.mailto)[0].length : 0;
    }
  }
}, Q4 = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]", e8 = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split("|");
function n8(n) {
  n.__index__ = -1, n.__text_cache__ = "";
}
function t8(n) {
  return function(e, t) {
    var r = e.slice(t);
    return n.test(r) ? r.match(n)[0].length : 0;
  };
}
function or() {
  return function(n, e) {
    e.normalize(n);
  };
}
function an(n) {
  var e = n.re = j4()(n.__opts__), t = n.__tlds__.slice();
  n.onCompile(), n.__tlds_replaced__ || t.push(Q4), t.push(e.src_xn), e.src_tlds = t.join("|");
  function r(c) {
    return c.replace("%TLDS%", e.src_tlds);
  }
  e.email_fuzzy = RegExp(r(e.tpl_email_fuzzy), "i"), e.link_fuzzy = RegExp(r(e.tpl_link_fuzzy), "i"), e.link_no_ip_fuzzy = RegExp(r(e.tpl_link_no_ip_fuzzy), "i"), e.host_fuzzy_test = RegExp(r(e.tpl_host_fuzzy_test), "i");
  var o = [];
  n.__compiled__ = {};
  function s(c, a) {
    throw new Error('(LinkifyIt) Invalid schema "' + c + '": ' + a);
  }
  Object.keys(n.__schemas__).forEach(function(c) {
    var a = n.__schemas__[c];
    if (a !== null) {
      var l = { validate: null, link: null };
      if (n.__compiled__[c] = l, K4(a)) {
        W4(a.validate) ? l.validate = t8(a.validate) : rr(a.validate) ? l.validate = a.validate : s(c, a), rr(a.normalize) ? l.normalize = a.normalize : a.normalize ? s(c, a) : l.normalize = or();
        return;
      }
      if (Z4(a)) {
        o.push(c);
        return;
      }
      s(c, a);
    }
  }), o.forEach(function(c) {
    n.__compiled__[n.__schemas__[c]] && (n.__compiled__[c].validate = n.__compiled__[n.__schemas__[c]].validate, n.__compiled__[c].normalize = n.__compiled__[n.__schemas__[c]].normalize);
  }), n.__compiled__[""] = { validate: null, normalize: or() };
  var i = Object.keys(n.__compiled__).filter(function(c) {
    return c.length > 0 && n.__compiled__[c];
  }).map(Y4).join("|");
  n.re.schema_test = RegExp("(^|(?!_)(?:[><｜]|" + e.src_ZPCc + "))(" + i + ")", "i"), n.re.schema_search = RegExp("(^|(?!_)(?:[><｜]|" + e.src_ZPCc + "))(" + i + ")", "ig"), n.re.schema_at_start = RegExp("^" + n.re.schema_search.source, "i"), n.re.pretest = RegExp(
    "(" + n.re.schema_test.source + ")|(" + n.re.host_fuzzy_test.source + ")|@",
    "i"
  ), n8(n);
}
function r8(n, e) {
  var t = n.__index__, r = n.__last_index__, o = n.__text_cache__.slice(t, r);
  this.schema = n.__schema__.toLowerCase(), this.index = t + e, this.lastIndex = r + e, this.raw = o, this.text = o, this.url = o;
}
function Un(n, e) {
  var t = new r8(n, e);
  return n.__compiled__[t.schema].normalize(t, n), t;
}
function ce(n, e) {
  if (!(this instanceof ce))
    return new ce(n, e);
  e || J4(n) && (e = n, n = {}), this.__opts__ = zn({}, Jr, e), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = zn({}, X4, n), this.__compiled__ = {}, this.__tlds__ = e8, this.__tlds_replaced__ = !1, this.re = {}, an(this);
}
ce.prototype.add = function(e, t) {
  return this.__schemas__[e] = t, an(this), this;
};
ce.prototype.set = function(e) {
  return this.__opts__ = zn(this.__opts__, e), this;
};
ce.prototype.test = function(e) {
  if (this.__text_cache__ = e, this.__index__ = -1, !e.length)
    return !1;
  var t, r, o, s, i, c, a, l, u;
  if (this.re.schema_test.test(e)) {
    for (a = this.re.schema_search, a.lastIndex = 0; (t = a.exec(e)) !== null; )
      if (s = this.testSchemaAt(e, t[2], a.lastIndex), s) {
        this.__schema__ = t[2], this.__index__ = t.index + t[1].length, this.__last_index__ = t.index + t[0].length + s;
        break;
      }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (l = e.search(this.re.host_fuzzy_test), l >= 0 && (this.__index__ < 0 || l < this.__index__) && (r = e.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (i = r.index + r[1].length, (this.__index__ < 0 || i < this.__index__) && (this.__schema__ = "", this.__index__ = i, this.__last_index__ = r.index + r[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (u = e.indexOf("@"), u >= 0 && (o = e.match(this.re.email_fuzzy)) !== null && (i = o.index + o[1].length, c = o.index + o[0].length, (this.__index__ < 0 || i < this.__index__ || i === this.__index__ && c > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = i, this.__last_index__ = c))), this.__index__ >= 0;
};
ce.prototype.pretest = function(e) {
  return this.re.pretest.test(e);
};
ce.prototype.testSchemaAt = function(e, t, r) {
  return this.__compiled__[t.toLowerCase()] ? this.__compiled__[t.toLowerCase()].validate(e, r, this) : 0;
};
ce.prototype.match = function(e) {
  var t = 0, r = [];
  this.__index__ >= 0 && this.__text_cache__ === e && (r.push(Un(this, t)), t = this.__last_index__);
  for (var o = t ? e.slice(t) : e; this.test(o); )
    r.push(Un(this, t)), o = o.slice(this.__last_index__), t += this.__last_index__;
  return r.length ? r : null;
};
ce.prototype.matchAtStart = function(e) {
  if (this.__text_cache__ = e, this.__index__ = -1, !e.length)
    return null;
  var t = this.re.schema_at_start.exec(e);
  if (!t)
    return null;
  var r = this.testSchemaAt(e, t[2], t[0].length);
  return r ? (this.__schema__ = t[2], this.__index__ = t.index + t[1].length, this.__last_index__ = t.index + t[0].length + r, Un(this, 0)) : null;
};
ce.prototype.tlds = function(e, t) {
  return e = Array.isArray(e) ? e : [e], t ? (this.__tlds__ = this.__tlds__.concat(e).sort().filter(function(r, o, s) {
    return r !== s[o - 1];
  }).reverse(), an(this), this) : (this.__tlds__ = e.slice(), this.__tlds_replaced__ = !0, an(this), this);
};
ce.prototype.normalize = function(e) {
  e.schema || (e.url = "http://" + e.url), e.schema === "mailto:" && !/^mailto:/i.test(e.url) && (e.url = "mailto:" + e.url);
};
ce.prototype.onCompile = function() {
};
var o8 = ce;
const Le = 2147483647, pe = 36, rt = 1, Ve = 26, s8 = 38, c8 = 700, Xr = 72, Qr = 128, eo = "-", i8 = /^xn--/, a8 = /[^\0-\x7F]/, l8 = /[\x2E\u3002\uFF0E\uFF61]/g, u8 = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
}, Bn = pe - rt, he = Math.floor, Pn = String.fromCharCode;
function ve(n) {
  throw new RangeError(u8[n]);
}
function f8(n, e) {
  const t = [];
  let r = n.length;
  for (; r--; )
    t[r] = e(n[r]);
  return t;
}
function no(n, e) {
  const t = n.split("@");
  let r = "";
  t.length > 1 && (r = t[0] + "@", n = t[1]), n = n.replace(l8, ".");
  const o = n.split("."), s = f8(o, e).join(".");
  return r + s;
}
function ot(n) {
  const e = [];
  let t = 0;
  const r = n.length;
  for (; t < r; ) {
    const o = n.charCodeAt(t++);
    if (o >= 55296 && o <= 56319 && t < r) {
      const s = n.charCodeAt(t++);
      (s & 64512) == 56320 ? e.push(((o & 1023) << 10) + (s & 1023) + 65536) : (e.push(o), t--);
    } else
      e.push(o);
  }
  return e;
}
const to = (n) => String.fromCodePoint(...n), p8 = function(n) {
  return n >= 48 && n < 58 ? 26 + (n - 48) : n >= 65 && n < 91 ? n - 65 : n >= 97 && n < 123 ? n - 97 : pe;
}, sr = function(n, e) {
  return n + 22 + 75 * (n < 26) - ((e != 0) << 5);
}, ro = function(n, e, t) {
  let r = 0;
  for (n = t ? he(n / c8) : n >> 1, n += he(n / e); n > Bn * Ve >> 1; r += pe)
    n = he(n / Bn);
  return he(r + (Bn + 1) * n / (n + s8));
}, st = function(n) {
  const e = [], t = n.length;
  let r = 0, o = Qr, s = Xr, i = n.lastIndexOf(eo);
  i < 0 && (i = 0);
  for (let c = 0; c < i; ++c)
    n.charCodeAt(c) >= 128 && ve("not-basic"), e.push(n.charCodeAt(c));
  for (let c = i > 0 ? i + 1 : 0; c < t; ) {
    const a = r;
    for (let u = 1, p = pe; ; p += pe) {
      c >= t && ve("invalid-input");
      const f = p8(n.charCodeAt(c++));
      f >= pe && ve("invalid-input"), f > he((Le - r) / u) && ve("overflow"), r += f * u;
      const h = p <= s ? rt : p >= s + Ve ? Ve : p - s;
      if (f < h)
        break;
      const d = pe - h;
      u > he(Le / d) && ve("overflow"), u *= d;
    }
    const l = e.length + 1;
    s = ro(r - a, l, a == 0), he(r / l) > Le - o && ve("overflow"), o += he(r / l), r %= l, e.splice(r++, 0, o);
  }
  return String.fromCodePoint(...e);
}, ct = function(n) {
  const e = [];
  n = ot(n);
  const t = n.length;
  let r = Qr, o = 0, s = Xr;
  for (const a of n)
    a < 128 && e.push(Pn(a));
  const i = e.length;
  let c = i;
  for (i && e.push(eo); c < t; ) {
    let a = Le;
    for (const u of n)
      u >= r && u < a && (a = u);
    const l = c + 1;
    a - r > he((Le - o) / l) && ve("overflow"), o += (a - r) * l, r = a;
    for (const u of n)
      if (u < r && ++o > Le && ve("overflow"), u === r) {
        let p = o;
        for (let f = pe; ; f += pe) {
          const h = f <= s ? rt : f >= s + Ve ? Ve : f - s;
          if (p < h)
            break;
          const d = p - h, g = pe - h;
          e.push(
            Pn(sr(h + d % g, 0))
          ), p = he(d / g);
        }
        e.push(Pn(sr(p, 0))), s = ro(o, l, c === i), o = 0, ++c;
      }
    ++o, ++r;
  }
  return e.join("");
}, oo = function(n) {
  return no(n, function(e) {
    return i8.test(e) ? st(e.slice(4).toLowerCase()) : e;
  });
}, so = function(n) {
  return no(n, function(e) {
    return a8.test(e) ? "xn--" + ct(e) : e;
  });
}, h8 = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  version: "2.3.1",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  ucs2: {
    decode: ot,
    encode: to
  },
  decode: st,
  encode: ct,
  toASCII: so,
  toUnicode: oo
}, d8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: st,
  default: h8,
  encode: ct,
  toASCII: so,
  toUnicode: oo,
  ucs2decode: ot,
  ucs2encode: to
}, Symbol.toStringTag, { value: "Module" })), g8 = /* @__PURE__ */ Zo(d8);
var m8 = {
  options: {
    html: !1,
    // Enable HTML tags in source
    xhtmlOut: !1,
    // Use '/' to close single tags (<br />)
    breaks: !1,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: !1,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 100
    // Internal protection, recursion limit
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
}, _8 = {
  options: {
    html: !1,
    // Enable HTML tags in source
    xhtmlOut: !1,
    // Use '/' to close single tags (<br />)
    breaks: !1,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: !1,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20
    // Internal protection, recursion limit
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
}, b8 = {
  options: {
    html: !0,
    // Enable HTML tags in source
    xhtmlOut: !0,
    // Use '/' to close single tags (<br />)
    breaks: !1,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: !1,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20
    // Internal protection, recursion limit
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
}, Pe = $, v8 = dn, k8 = p9, x8 = O9, y8 = g4, E8 = G4, w8 = o8, we = Me, co = g8, A8 = {
  default: m8,
  zero: _8,
  commonmark: b8
}, C8 = /^(vbscript|javascript|file|data):/, S8 = /^data:image\/(gif|png|jpeg|webp);/;
function D8(n) {
  var e = n.trim().toLowerCase();
  return C8.test(e) ? !!S8.test(e) : !0;
}
var io = ["http:", "https:", "mailto:"];
function T8(n) {
  var e = we.parse(n, !0);
  if (e.hostname && (!e.protocol || io.indexOf(e.protocol) >= 0))
    try {
      e.hostname = co.toASCII(e.hostname);
    } catch {
    }
  return we.encode(we.format(e));
}
function R8(n) {
  var e = we.parse(n, !0);
  if (e.hostname && (!e.protocol || io.indexOf(e.protocol) >= 0))
    try {
      e.hostname = co.toUnicode(e.hostname);
    } catch {
    }
  return we.decode(we.format(e), we.decode.defaultChars + "%");
}
function ie(n, e) {
  if (!(this instanceof ie))
    return new ie(n, e);
  e || Pe.isString(n) || (e = n || {}, n = "default"), this.inline = new E8(), this.block = new y8(), this.core = new x8(), this.renderer = new k8(), this.linkify = new w8(), this.validateLink = D8, this.normalizeLink = T8, this.normalizeLinkText = R8, this.utils = Pe, this.helpers = Pe.assign({}, v8), this.options = {}, this.configure(n), e && this.set(e);
}
ie.prototype.set = function(n) {
  return Pe.assign(this.options, n), this;
};
ie.prototype.configure = function(n) {
  var e = this, t;
  if (Pe.isString(n) && (t = n, n = A8[t], !n))
    throw new Error('Wrong `markdown-it` preset "' + t + '", check name');
  if (!n)
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  return n.options && e.set(n.options), n.components && Object.keys(n.components).forEach(function(r) {
    n.components[r].rules && e[r].ruler.enableOnly(n.components[r].rules), n.components[r].rules2 && e[r].ruler2.enableOnly(n.components[r].rules2);
  }), this;
};
ie.prototype.enable = function(n, e) {
  var t = [];
  Array.isArray(n) || (n = [n]), ["core", "block", "inline"].forEach(function(o) {
    t = t.concat(this[o].ruler.enable(n, !0));
  }, this), t = t.concat(this.inline.ruler2.enable(n, !0));
  var r = n.filter(function(o) {
    return t.indexOf(o) < 0;
  });
  if (r.length && !e)
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + r);
  return this;
};
ie.prototype.disable = function(n, e) {
  var t = [];
  Array.isArray(n) || (n = [n]), ["core", "block", "inline"].forEach(function(o) {
    t = t.concat(this[o].ruler.disable(n, !0));
  }, this), t = t.concat(this.inline.ruler2.disable(n, !0));
  var r = n.filter(function(o) {
    return t.indexOf(o) < 0;
  });
  if (r.length && !e)
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + r);
  return this;
};
ie.prototype.use = function(n) {
  var e = [this].concat(Array.prototype.slice.call(arguments, 1));
  return n.apply(n, e), this;
};
ie.prototype.parse = function(n, e) {
  if (typeof n != "string")
    throw new Error("Input data should be a String");
  var t = new this.core.State(n, this, e);
  return this.core.process(t), t.tokens;
};
ie.prototype.render = function(n, e) {
  return e = e || {}, this.renderer.render(this.parse(n, e), this.options, e);
};
ie.prototype.parseInline = function(n, e) {
  var t = new this.core.State(n, this, e);
  return t.inlineMode = !0, this.core.process(t), t.tokens;
};
ie.prototype.renderInline = function(n, e) {
  return e = e || {}, this.renderer.render(this.parseInline(n, e), this.options, e);
};
var L8 = ie, N8 = L8;
const q8 = /* @__PURE__ */ Gn(N8), M8 = ae({
  name: "VueMarkdown",
  props: {
    source: {
      type: String,
      required: !0
    },
    options: {
      type: Object,
      required: !1
    },
    plugins: {
      type: Array,
      required: !1
    }
  },
  setup(n) {
    const e = ee(new q8(n.options ?? {}));
    for (const r of n.plugins ?? [])
      e.value.use(r);
    const t = te(() => e.value.render(n.source));
    return () => So("div", { innerHTML: t.value });
  }
}), I8 = {
  key: 0,
  class: "chat-message-actions"
}, O8 = {
  key: 2,
  class: "chat-message-files"
}, Hn = /* @__PURE__ */ ae({
  __name: "Message",
  props: {
    message: {}
  },
  setup(n, { expose: e }) {
    const t = n;
    be.registerLanguage("javascript", Rr), be.registerLanguage("typescript", vi), be.registerLanguage("python", _i), be.registerLanguage("xml", Lr), be.registerLanguage("bash", mi);
    const { message: r } = Do(t), { options: o } = Ge(), s = ee(null), i = ee({}), c = te(() => r.value.text || "&lt;Empty response&gt;"), a = te(() => ({
      "chat-message-from-user": r.value.sender === "user",
      "chat-message-from-bot": r.value.sender === "bot",
      "chat-message-transparent": r.value.transparent === !0
    })), l = (d) => {
      d.use(Ei, {
        attrs: {
          target: "_blank",
          rel: "noopener"
        }
      });
    }, u = () => {
      var d;
      (d = s.value) != null && d.scrollIntoView && s.value.scrollIntoView({
        block: "center"
      });
    }, p = {
      highlight(d, g) {
        if (g && be.getLanguage(g))
          try {
            return be.highlight(d, { language: g }).value;
          } catch {
          }
        return "";
      }
    }, f = { ...(o == null ? void 0 : o.messageComponents) ?? {} };
    e({ scrollToView: u });
    const h = async (d) => await new Promise((g, E) => {
      const x = new FileReader();
      x.onload = () => g(x.result), x.onerror = E, x.readAsDataURL(d);
    });
    return qe(async () => {
      if (r.value.files)
        for (const d of r.value.files)
          try {
            const g = await h(d);
            i.value[d.name] = g;
          } catch (g) {
            console.error("Error reading file:", g);
          }
    }), (d, g) => (S(), P("div", {
      ref_key: "messageContainer",
      ref: s,
      class: lr(["chat-message", a.value])
    }, [
      d.$slots.beforeMessage ? (S(), P("div", I8, [
        Ae(d.$slots, "beforeMessage", $n(ur({ message: B(r) })))
      ])) : se("", !0),
      Ae(d.$slots, "default", {}, () => [
        B(r).type === "component" && f[B(r).key] ? (S(), Y(To(f[B(r).key]), $n(Ro({ key: 0 }, B(r).arguments)), null, 16)) : (S(), Y(B(M8), {
          key: 1,
          class: "chat-message-markdown",
          source: c.value,
          options: p,
          plugins: [l]
        }, null, 8, ["source", "plugins"])),
        (B(r).files ?? []).length > 0 ? (S(), P("div", O8, [
          (S(!0), P(tn, null, rn(B(r).files ?? [], (E) => (S(), P("div", {
            key: E.name,
            class: "chat-message-file"
          }, [
            de(Nr, {
              file: E,
              "is-removable": !1,
              "is-previewable": !0
            }, null, 8, ["file"])
          ]))), 128))
        ])) : se("", !0)
      ])
    ], 2));
  }
}), F8 = /* @__PURE__ */ G("div", { class: "chat-message-typing-body" }, [
  /* @__PURE__ */ G("span", { class: "chat-message-typing-circle" }),
  /* @__PURE__ */ G("span", { class: "chat-message-typing-circle" }),
  /* @__PURE__ */ G("span", { class: "chat-message-typing-circle" })
], -1), B8 = /* @__PURE__ */ ae({
  __name: "MessageTyping",
  props: {
    animation: { default: "bouncing" }
  },
  setup(n) {
    const e = n, t = {
      id: "typing",
      text: "",
      sender: "bot",
      createdAt: ""
    }, r = ee(), o = te(() => ({
      // eslint-disable-next-line @typescript-eslint/naming-convention
      "chat-message-typing": !0,
      [`chat-message-typing-animation-${e.animation}`]: !0
    }));
    return qe(() => {
      var s;
      (s = r.value) == null || s.scrollToView();
    }), (s, i) => (S(), Y(B(Hn), {
      ref_key: "messageContainer",
      ref: r,
      class: lr(o.value),
      message: t
    }, {
      default: xe(() => [
        F8
      ]),
      _: 1
    }, 8, ["class"]));
  }
}), P8 = { class: "chat-messages-list" }, $8 = /* @__PURE__ */ ae({
  __name: "MessagesList",
  props: {
    messages: {}
  },
  setup(n) {
    const e = Yn(), t = ee([]), { initialMessages: r, waitingForResponse: o } = e;
    return Lo(
      () => t.value.length,
      () => {
        const s = t.value[t.value.length - 1];
        s && s.scrollToView();
      }
    ), (s, i) => (S(), P("div", P8, [
      (S(!0), P(tn, null, rn(B(r), (c) => (S(), Y(Hn, {
        key: c.id,
        message: c
      }, null, 8, ["message"]))), 128)),
      (S(!0), P(tn, null, rn(s.messages, (c) => (S(), Y(Hn, {
        key: c.id,
        ref_for: !0,
        ref_key: "messageComponents",
        ref: t,
        message: c
      }, {
        beforeMessage: xe(({ message: a }) => [
          Ae(s.$slots, "beforeMessage", $n(ur({ message: a })))
        ]),
        _: 2
      }, 1032, ["message"]))), 128)),
      B(o) ? (S(), Y(B8, { key: 0 })) : se("", !0)
    ]));
  }
}), z8 = { class: "chat-heading" }, U8 = ["title"], H8 = { key: 0 }, ao = /* @__PURE__ */ ae({
  __name: "Chat",
  setup(n) {
    const { t: e } = fn(), t = Yn(), { messages: r, currentSessionId: o } = t, { options: s } = Ge(), i = te(() => s.mode === "window" && s.showWindowCloseButton);
    async function c() {
      t.startNewSession && (t.startNewSession(), $e(() => {
        re.emit("scrollToBottom");
      }));
    }
    async function a() {
      t.loadPreviousSession && (await t.loadPreviousSession(), $e(() => {
        re.emit("scrollToBottom");
      }));
    }
    function l() {
      re.emit("close");
    }
    return qe(async () => {
      await a(), !s.showWelcomeScreen && !o.value && await c();
    }), (u, p) => (S(), Y(gi, { class: "chat-wrapper" }, {
      header: xe(() => [
        G("div", z8, [
          G("h1", null, ze(B(e)("title")), 1),
          i.value ? (S(), P("button", {
            key: 0,
            class: "chat-close-button",
            title: B(e)("closeButtonTooltip"),
            onClick: l
          }, [
            de(B(Qs), {
              height: "18",
              width: "18"
            })
          ], 8, U8)) : se("", !0)
        ]),
        B(e)("subtitle") ? (S(), P("p", H8, ze(B(e)("subtitle")), 1)) : se("", !0)
      ]),
      footer: xe(() => [
        B(o) ? (S(), Y(fi, { key: 0 })) : (S(), Y(lc, { key: 1 }))
      ]),
      default: xe(() => [
        !B(o) && B(s).showWelcomeScreen ? (S(), Y(nc, {
          key: 0,
          "onClick:button": c
        })) : (S(), Y($8, {
          key: 1,
          messages: B(r)
        }, null, 8, ["messages"]))
      ]),
      _: 1
    }));
  }
}), V8 = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, G8 = /* @__PURE__ */ G("path", {
  fill: "currentColor",
  d: "M12 3c5.5 0 10 3.58 10 8s-4.5 8-10 8c-1.24 0-2.43-.18-3.53-.5C5.55 21 2 21 2 21c2.33-2.33 2.7-3.9 2.75-4.5C3.05 15.07 2 13.13 2 11c0-4.42 4.5-8 10-8"
}, null, -1), j8 = [
  G8
];
function Z8(n, e) {
  return S(), P("svg", V8, [...j8]);
}
const K8 = { name: "mdi-chat", render: Z8 }, W8 = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Y8 = /* @__PURE__ */ G("path", {
  fill: "currentColor",
  d: "M7.41 8.58L12 13.17l4.59-4.59L18 10l-6 6l-6-6z"
}, null, -1), J8 = [
  Y8
];
function X8(n, e) {
  return S(), P("svg", W8, [...J8]);
}
const Q8 = { name: "mdi-chevron-down", render: X8 }, eH = { class: "chat-window-wrapper" }, nH = { class: "chat-window" }, tH = /* @__PURE__ */ ae({
  __name: "ChatWindow",
  setup(n) {
    const e = ee(!1);
    function t() {
      e.value = !e.value, e.value && $e(() => {
        re.emit("scrollToBottom");
      });
    }
    return (r, o) => (S(), P("div", eH, [
      de(pt, { name: "chat-window-transition" }, {
        default: xe(() => [
          ar(G("div", nH, [
            de(ao)
          ], 512), [
            [No, e.value]
          ])
        ]),
        _: 1
      }),
      G("div", {
        class: "chat-window-toggle",
        onClick: t
      }, [
        de(pt, {
          name: "chat-window-toggle-transition",
          mode: "out-in"
        }, {
          default: xe(() => [
            e.value ? (S(), Y(B(Q8), {
              key: 1,
              height: "32",
              width: "32"
            })) : (S(), Y(B(K8), {
              key: 0,
              height: "32",
              width: "32"
            }))
          ]),
          _: 1
        })
      ])
    ]));
  }
}), rH = /* @__PURE__ */ ae({
  __name: "App",
  props: {},
  setup(n) {
    const { options: e } = Ge(), t = te(() => e.mode === "fullscreen");
    return qe(() => {
      be.registerLanguage("xml", Lr), be.registerLanguage("javascript", Rr);
    }), (r, o) => t.value ? (S(), Y(B(ao), {
      key: 0,
      class: "n8n-chat"
    })) : (S(), Y(B(tH), {
      key: 1,
      class: "n8n-chat"
    }));
  }
});
function sH(n) {
  var o, s;
  const e = {
    ...Fe,
    ...n,
    webhookConfig: {
      ...Fe.webhookConfig,
      ...n == null ? void 0 : n.webhookConfig
    },
    i18n: {
      ...Fe.i18n,
      ...n == null ? void 0 : n.i18n,
      en: {
        ...(o = Fe.i18n) == null ? void 0 : o.en,
        ...(s = n == null ? void 0 : n.i18n) == null ? void 0 : s.en
      }
    },
    theme: {
      ...Fe.theme,
      ...n == null ? void 0 : n.theme
    }
  }, t = e.target ?? Mo;
  typeof t == "string" && Go(t);
  const r = qo(rH);
  return r.use(jo, e), r.mount(t), r;
}
export {
  sH as createChat
};
